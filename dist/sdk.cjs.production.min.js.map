{"version":3,"file":"sdk.cjs.production.min.js","sources":["../src/constants.ts","../src/errors.ts","../src/utils.ts","../src/entities/currency.ts","../src/entities/token.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/currencyAmount.ts","../src/entities/fractions/tokenAmount.ts","../src/entities/fractions/price.ts","../src/entities/pair.ts","../src/entities/route.ts","../src/entities/fractions/percent.ts","../src/entities/trade.ts","../src/router.ts","../src/fetcher.ts","../src/entities/stableCalc.ts","../src/entities/swapStorage.ts","../src/entities/stablePool.ts","../src/stablesFetcher.ts","../src/routerV3.ts","../src/entities/stables.ts","../src/entities/stablePairWrapper.ts","../src/entities/routeV3.ts","../src/entities/tradeV3.ts"],"sourcesContent":["import JSBI from 'jsbi'\n// exports for external consumption\nexport type BigintIsh = JSBI | bigint | string\n\nexport enum ChainId {\n  BSC_MAINNET = 56,\n  BSC_TESTNET = 97,\n  AVAX_MAINNET = 43114,\n  AVAX_TESTNET = 43113,\n  ARBITRUM_MAINNET = 42161,\n  ARBITRUM_TETSNET_RINKEBY = 421611,\n  MATIC_MAINNET = 137,\n  MATIC_TESTNET = 80001,\n}\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nexport const FACTORY_ADDRESS: { [chainId: number]: string } = {\n  56: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n  97: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n  80001: '0xf10Bd0dA1f0e69c3334D7F8116C9082746EBC1B4',\n  43113: '0xC07098cdCf93b2dc5c20E749cDd1ba69cB9AcEBe',\n}\n\n// export const INIT_CODE_HASH = '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5'\n\n\nexport const INIT_CODE_HASH: { [chainId: number]: string } = {\n  56: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',\n  97: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',\n  80001: '0xc2b3644608b464a0df0eb711ce9c6ce7535d1bd4d0154b8389738a3e7fbb1a61',\n  43113: '0x197a29e2e90d809812f533e62529432f8e2741455e49d25365a66b4be2a453dd',\n}\n\n\nexport const STABLE_POOL_ADDRESS: { [chainId: number]: string } = {\n  43113: '0x9067e2C2bf8531283AB97C34EaA74599E0004842',\n}\n\nexport const STABLE_POOL_LP_ADDRESS: { [chainId: number]: string } = {\n  43113: '0xDf65aC8079A71f5174A35dE3D29e5458d03D5787'\n}\n\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\n\n// exports for internal consumption\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\nexport const TWO = JSBI.BigInt(2)\nexport const THREE = JSBI.BigInt(3)\nexport const FIVE = JSBI.BigInt(5)\nexport const TEN = JSBI.BigInt(10)\nexport const _100 = JSBI.BigInt(100)\nexport const FEES_NUMERATOR = JSBI.BigInt(9975)\nexport const FEES_DENOMINATOR = JSBI.BigInt(10000)\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: JSBI.BigInt('0xff'),\n  [SolidityType.uint256]: JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}\n","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport JSBI from 'jsbi'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\n\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\n  return bigintIsh instanceof JSBI\n    ? bigintIsh\n    : typeof bigintIsh === 'bigint'\n    ? JSBI.BigInt(bigintIsh.toString())\n    : JSBI.BigInt(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: JSBI): JSBI {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: JSBI = ZERO\n  let x: JSBI\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\n    while (JSBI.lessThan(x, z)) {\n      z = x\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n","import JSBI from 'jsbi'\nimport { ChainId } from '..'\n\nimport { SolidityType } from '../constants'\nimport { validateSolidityTypeInstance } from '../utils'\n\n/**\n * A currency is any fungible financial instrument on Ethereum, including Ether and all ERC20 tokens.\n *\n * The only instance of the base class `Currency` is Ether.\n */\nexport class Currency {\n  public readonly decimals: number\n  public readonly symbol?: string\n  public readonly name?: string\n\n  /**\n   * The only instance of the base class `Currency`.\n   */\n  public static readonly ETHER: Currency = new Currency(18, 'BNB', 'BNB')\n\n  public static readonly NETWORK_CCY: {[chainId in ChainId]:Currency} ={\n    [ChainId.BSC_MAINNET]: new Currency(18, 'BNB', 'BNB'),\n    [ChainId.BSC_TESTNET]: new Currency(18, 'BNB', 'BNB'),\n    [ChainId.ARBITRUM_MAINNET]: new Currency(18, 'ETH', 'ETH'),\n    [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Currency(18, 'ETH', 'ETH'),\n    [ChainId.AVAX_MAINNET]: new Currency(18, 'AVAX', 'AVAX'),\n    [ChainId.AVAX_TESTNET]: new Currency(18, 'AVAX', 'AVAX'),\n    [ChainId.MATIC_MAINNET]: new Currency(18, 'MATIC', 'MATIC'),\n    [ChainId.MATIC_TESTNET]: new Currency(18, 'MATIC', 'MATIC')\n  }\n  /**\n   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.ETHER`.\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  protected constructor(decimals: number, symbol?: string, name?: string) {\n    validateSolidityTypeInstance(JSBI.BigInt(decimals), SolidityType.uint8)\n\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n  }\n}\n\nconst NETWORK_CCY = Currency.NETWORK_CCY\nconst ETHER = Currency.ETHER\nexport { ETHER, NETWORK_CCY }\n","import invariant from 'tiny-invariant'\nimport { ChainId } from '../constants'\nimport { validateAndParseAddress } from '../utils'\nimport { Currency } from './currency'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token extends Currency {\n  public readonly chainId: ChainId\n  public readonly address: string\n  public readonly projectLink?: string\n\n  public constructor(\n    chainId: ChainId,\n    address: string,\n    decimals: number,\n    symbol?: string,\n    name?: string,\n    projectLink?: string\n  ) {\n    super(decimals, symbol, name)\n    this.chainId = chainId\n    this.address = validateAndParseAddress(address)\n    this.projectLink = projectLink\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Token): boolean {\n    // short circuit on reference equality\n    if (this === other) {\n      return true\n    }\n    return this.chainId === other.chainId && this.address === other.address\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n}\n\n/**\n * Compares two currencies for equality\n */\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB)\n  } else if (currencyA instanceof Token) {\n    return false\n  } else if (currencyB instanceof Token) {\n    return false\n  } else {\n    return currencyA === currencyB\n  }\n}\n\nexport const WETH = {\n  [ChainId.BSC_MAINNET]: new Token(\n    ChainId.BSC_MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.BSC_TESTNET]: new Token(\n    ChainId.BSC_TESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_MAINNET]: new Token(\n    ChainId.ARBITRUM_MAINNET,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped ETH',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Token(\n    ChainId.ARBITRUM_TETSNET_RINKEBY,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_MAINNET]: new Token(\n    ChainId.AVAX_MAINNET,\n    '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_TESTNET]: new Token(\n    ChainId.AVAX_TESTNET,\n    '0xd00ae08403B9bbb9124bB305C09058E32C39A48c',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_MAINNET]: new Token(\n    ChainId.MATIC_MAINNET,\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_TESTNET]: new Token(\n    ChainId.MATIC_TESTNET,\n    '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n\n}\n// this has not to be mixed up with the ERC20 token WETH on BSC or MATIC\n// these are the respective wrapped network tokens, e.g. WBNB for Binance\n// or WMATIC for Polygon\nexport const WRAPPED_NETWORK_TOKENS = {\n  [ChainId.BSC_MAINNET]: new Token(\n    ChainId.BSC_MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.BSC_TESTNET]: new Token(\n    ChainId.BSC_TESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_MAINNET]: new Token(\n    ChainId.ARBITRUM_MAINNET,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped ETH',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Token(\n    ChainId.ARBITRUM_TETSNET_RINKEBY,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_MAINNET]: new Token(\n    ChainId.AVAX_MAINNET,\n    '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_TESTNET]: new Token(\n    ChainId.AVAX_TESTNET,\n    '0xd00ae08403B9bbb9124bB305C09058E32C39A48c',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_MAINNET]: new Token(\n    ChainId.MATIC_MAINNET,\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_TESTNET]: new Token(\n    ChainId.MATIC_TESTNET,\n    '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Decimal from 'decimal.js-light'\nimport _Big, { RoundingMode } from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding } from '../../constants'\nimport { ONE } from '../../constants'\nimport { parseBigintIsh } from '../../utils'\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp\n}\n\nexport class Fraction {\n  public readonly numerator: JSBI\n  public readonly denominator: JSBI\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = ONE) {\n    this.numerator = parseBigintIsh(numerator)\n    this.denominator = parseBigintIsh(denominator)\n  }\n\n  // performs floor division\n  public get quotient(): JSBI {\n    return JSBI.divide(this.numerator, this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.add(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.subtract(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.lessThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.equal(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.greaterThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.numerator),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(this.denominator, otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n}\n","import { currencyEquals } from '../token'\nimport { Currency, ETHER, NETWORK_CCY } from '../currency'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Big from 'big.js'\nimport toFormat from 'toformat'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { BigintIsh, Rounding, TEN, SolidityType, ChainId } from '../../constants'\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../utils'\nimport { Fraction } from './fraction'\n\nconst Big = toFormat(_Big)\n\nexport class CurrencyAmount extends Fraction {\n  public readonly currency: Currency\n\n  /**\n   * Helper that calls the constructor with the ETHER currency\n   * @param amount ether amount in wei\n   */\n  public static ether(amount: BigintIsh): CurrencyAmount {\n    return new CurrencyAmount(ETHER, amount)\n  }\n\n  /**\n   * Helper that calls the constructor with the more flexible network currency\n   * dependent on the selected chainId\n   * @param amount ether amount in wei\n   */\n  public static networkCCYAmount(chainId: ChainId, amount: BigintIsh): CurrencyAmount {\n    return new CurrencyAmount(NETWORK_CCY[chainId], amount)\n  }\n\n  // amount _must_ be raw, i.e. in the native representation\n  protected constructor(currency: Currency, amount: BigintIsh) {\n    const parsedAmount = parseBigintIsh(amount)\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\n\n    super(parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(currency.decimals)))\n    this.currency = currency\n  }\n\n  public get raw(): JSBI {\n    return this.numerator\n  }\n\n  public add(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, JSBI.add(this.raw, other.raw))\n  }\n\n  public subtract(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, JSBI.subtract(this.raw, other.raw))\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\n  }\n\n  public toBigNumber(): BigNumber { return BigNumber.from(this.numerator.toString()) }\n}\n","import { CurrencyAmount } from './currencyAmount'\nimport { Token } from '../token'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\n\nimport { BigintIsh } from '../../constants'\n\n\n// minimal interface so the input output comparator may be shared across types\nexport interface InputOutput {\n  readonly inputAmount: CurrencyAmount\n  readonly outputAmount: CurrencyAmount\n}\n\nexport class TokenAmount extends CurrencyAmount {\n  public readonly token: Token\n\n  // amount _must_ be raw, i.e. in the native representation\n  public constructor(token: Token, amount: BigintIsh) {\n    super(token, amount)\n    this.token = token\n  }\n\n  public add(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.add(this.raw, other.raw))\n  }\n\n  public subtract(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.subtract(this.raw, other.raw))\n  }\n}\n","import { Token } from '../token'\nimport { TokenAmount } from './tokenAmount'\nimport { currencyEquals } from '../token'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\n\nimport { BigintIsh, Rounding, TEN } from '../../constants'\nimport { Currency } from '../currency'\nimport { Route } from '../route'\nimport { RouteV3 } from 'entities/routeV3'\nimport { Fraction } from './fraction'\nimport { CurrencyAmount } from './currencyAmount'\n// import { Pair } from 'entities'\nimport { StablePairWrapper } from 'entities/stablePairWrapper'\n\nexport class Price extends Fraction {\n  public readonly baseCurrency: Currency // input i.e. denominator\n  public readonly quoteCurrency: Currency // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n  public static fromRoute(route: Route): Price {\n    const prices: Price[] = []\n    for (const [i, pair] of route.pairs.entries()) {\n      prices.push(\n        route.path[i].equals(pair.token0)\n          ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.raw, pair.reserve1.raw)\n          : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.raw, pair.reserve0.raw)\n      )\n    }\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n  }\n\n  // upgraded version to include StablePairWrappers in a Route\n  public static fromRouteV3(route: RouteV3): Price {\n    const prices: Price[] = []\n    for (const [i, source] of route.sources.entries()) {\n      prices.push(\n        route.path[i].equals(source.token0)\n          ? (source.type === 'Pair'\n            ? new Price(source.reserve0.currency, source.reserve1.currency, source.reserve0.raw, source.reserve1.raw)\n            // here we need the recorded prcing bases\n            : new Price(source.reserve0.currency, source.reserve1.currency, (source as StablePairWrapper).pricingBasesIn[0].raw, (source as StablePairWrapper).pricingBasesOut[1].raw))\n          : (source.type === 'Pair' ?\n            new Price(source.reserve1.currency, source.reserve0.currency, source.reserve1.raw, source.reserve0.raw)\n            // pricing base for stablePriceWrapper\n            : new Price(source.reserve0.currency, source.reserve1.currency, (source as StablePairWrapper).pricingBasesIn[1].raw, (source as StablePairWrapper).pricingBasesOut[0].raw))\n      )\n    }\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n  }\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  public constructor(baseCurrency: Currency, quoteCurrency: Currency, denominator: BigintIsh, numerator: BigintIsh) {\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      JSBI.exponentiate(TEN, JSBI.BigInt(baseCurrency.decimals)),\n      JSBI.exponentiate(TEN, JSBI.BigInt(quoteCurrency.decimals))\n    )\n  }\n\n  public get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n\n  public get adjusted(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public invert(): Price {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  public multiply(other: Price): Price {\n    invariant(currencyEquals(this.quoteCurrency, other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  // performs floor division on overflow\n  public quote(currencyAmount: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(currencyAmount.currency, this.baseCurrency), 'TOKEN')\n    if (this.quoteCurrency instanceof Token) {\n      return new TokenAmount(this.quoteCurrency, super.multiply(currencyAmount.raw).quotient)\n    }\n    return CurrencyAmount.ether(super.multiply(currencyAmount.raw).quotient)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\n\nimport {\n  BigintIsh,\n  FACTORY_ADDRESS,\n  INIT_CODE_HASH,\n  MINIMUM_LIQUIDITY,\n  ZERO,\n  ONE,\n  FIVE,\n  FEES_NUMERATOR,\n  FEES_DENOMINATOR,\n  ChainId,\n} from '../constants'\nimport { sqrt, parseBigintIsh } from '../utils'\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors'\nimport { Token } from './token'\nimport {Source} from './source'\n\nlet PAIR_ADDRESS_CACHE: { [token0Address: string]: { [token1Address: string]: string } } = {}\n\nexport class Pair implements Source{\n  public readonly liquidityToken: Token\n  private readonly tokenAmounts: [TokenAmount, TokenAmount]\n  public readonly type:string\n\n  public static getAddress(tokenA: Token, tokenB: Token): string {\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID')\n    const chainId = tokenA.chainId\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n\n    if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address] === undefined) {\n      PAIR_ADDRESS_CACHE = {\n        ...PAIR_ADDRESS_CACHE,\n        [tokens[0].address]: {\n          ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\n          [tokens[1].address]: getCreate2Address(\n            FACTORY_ADDRESS[chainId],\n            keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]),\n            INIT_CODE_HASH[chainId]\n          ),\n        },\n      }\n    }\n\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address]\n  }\n\n  public constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount) {\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].token.chainId,\n      Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token),\n      18,\n      tokenAmounts[0].token.chainId === 56 ? 'Cake-LP' : 'Requiem-LP',\n      tokenAmounts[0].token.chainId === 56 ? 'Pancake LPs' : 'Requiem LPs'\n    )\n    this.type = 'Pair'\n    this.tokenAmounts = tokenAmounts as [TokenAmount, TokenAmount]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price {\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price {\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].token\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].token\n  }\n\n  public get reserve0(): TokenAmount {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): TokenAmount {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): TokenAmount {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pair] {\n    invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.token)\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR)\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee)\n    const outputAmount = new TokenAmount(\n      inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\n    invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.raw, ZERO) ||\n      JSBI.equal(this.reserve1.raw, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.token)\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR)\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR)\n    const inputAmount = new TokenAmount(\n      outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getLiquidityMinted(\n    totalSupply: TokenAmount,\n    tokenAmountA: TokenAmount,\n    tokenAmountB: TokenAmount\n  ): TokenAmount {\n    invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return new TokenAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: TokenAmount,\n    liquidity: TokenAmount,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): TokenAmount {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: TokenAmount\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      invariant(!!kLast, 'K_LAST')\n      const kLastParsed = parseBigintIsh(kLast)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return new TokenAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n    )\n  }\n}\n","import { ChainId } from '../constants'\nimport invariant from 'tiny-invariant'\n\nimport { Currency, NETWORK_CCY } from './currency'\nimport { Token, WRAPPED_NETWORK_TOKENS } from './token'\nimport { Pair } from './pair'\nimport { Price } from './fractions/price'\n\nexport class Route {\n  public readonly pairs: Pair[]\n  public readonly path: Token[]\n  public readonly input: Currency\n  public readonly output: Currency\n  public readonly midPrice: Price\n\n  public constructor(pairs: Pair[], input: Currency, output?: Currency) {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(\n      pairs.every(pair => pair.chainId === pairs[0].chainId),\n      'CHAIN_IDS'\n    )\n    invariant(\n      (input instanceof Token && pairs[0].involvesToken(input)) ||\n      (input === NETWORK_CCY[pairs[0].chainId] && pairs[0].involvesToken(WRAPPED_NETWORK_TOKENS[pairs[0].chainId])),\n      'INPUT'\n    )\n    invariant(\n      typeof output === 'undefined' ||\n      (output instanceof Token && pairs[pairs.length - 1].involvesToken(output)) ||\n      (output === NETWORK_CCY[pairs[0].chainId] && pairs[pairs.length - 1].involvesToken(WRAPPED_NETWORK_TOKENS[pairs[0].chainId])),\n      'OUTPUT'\n    )\n\n    const path: Token[] = [input instanceof Token ? input : WRAPPED_NETWORK_TOKENS[pairs[0].chainId]]\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\n      path.push(output)\n    }\n\n    this.pairs = pairs\n    this.path = path\n    this.midPrice = Price.fromRoute(this)\n    this.input = input\n    this.output = output ?? path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.pairs[0].chainId\n  }\n}\n","import { Rounding, _100 } from '../../constants'\nimport { Fraction } from './fraction'\n\nconst _100_PERCENT = new Fraction(_100)\n\nexport class Percent extends Fraction {\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\nimport { sortedInsert } from '../utils'\nimport { Currency, NETWORK_CCY } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount, InputOutput } from './fractions/tokenAmount'\nimport { Pair } from './pair'\nimport { Route } from './route'\nimport { currencyEquals, Token, WRAPPED_NETWORK_TOKENS } from './token'\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nfunction computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n  return new Percent(slippage.numerator, slippage.denominator)\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Trade, b: Trade) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === NETWORK_CCY[chainId]) return new TokenAmount(WRAPPED_NETWORK_TOKENS[chainId], currencyAmount.raw)\n  invariant(false, 'CURRENCY')\n}\n\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n  if (currency instanceof Token) return currency\n  if (currency === NETWORK_CCY[chainId]) return WRAPPED_NETWORK_TOKENS[chainId]\n  invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: Route\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The mid price after the trade executes assuming no slippage.\n   */\n  public readonly nextMidPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: Route, amountIn: CurrencyAmount): Trade {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: Route, amountOut: CurrencyAmount): Trade {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(route: Route, amount: CurrencyAmount, tradeType: TradeType) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    const nextPairs: Pair[] = new Array(route.pairs.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n        nextPairs[i] = nextPair\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i])\n        amounts[i - 1] = inputAmount\n        nextPairs[i - 1] = nextPair\n      }\n    }\n\n    this.route = route\n    this.tradeType = tradeType\n    this.inputAmount =\n      tradeType === TradeType.EXACT_INPUT\n        ? amount\n        : route.input === NETWORK_CCY[route.chainId]\n          ? CurrencyAmount.networkCCYAmount(route.chainId,amounts[0].raw)\n          : amounts[0]\n    this.outputAmount =\n      tradeType === TradeType.EXACT_OUTPUT\n        ? amount\n        : route.output === NETWORK_CCY[route.chainId]\n          ? CurrencyAmount.networkCCYAmount(route.chainId,amounts[amounts.length - 1].raw)\n          : amounts[amounts.length - 1]\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input))\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return this.outputAmount instanceof TokenAmount\n        ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n        : CurrencyAmount.networkCCYAmount(this.route.chainId, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return this.inputAmount instanceof TokenAmount\n        ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n        : CurrencyAmount.networkCCYAmount(this.route.chainId,slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn(\n    pairs: Pair[],\n    currencyAmountIn: CurrencyAmount,\n    currencyOut: Currency,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountIn: CurrencyAmount = currencyAmountIn,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountIn instanceof TokenAmount\n        ? currencyAmountIn.token.chainId\n        : currencyOut instanceof Token\n          ? currencyOut.chainId\n          : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = wrappedAmount(currencyAmountIn, chainId)\n    const tokenOut = wrappedCurrency(currencyOut, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: TokenAmount\n      try {\n        ;[amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if ((error as any).isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut),\n            originalAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          amountOut,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentPairs, pair],\n          originalAmountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut(\n    pairs: Pair[],\n    currencyIn: Currency,\n    currencyAmountOut: CurrencyAmount,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountOut: CurrencyAmount = currencyAmountOut,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountOut instanceof TokenAmount\n        ? currencyAmountOut.token.chainId\n        : currencyIn instanceof Token\n          ? currencyIn.chainId\n          : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountOut = wrappedAmount(currencyAmountOut, chainId)\n    const tokenIn = wrappedCurrency(currencyIn, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: TokenAmount\n      try {\n        ;[amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if ((error as any).isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency),\n            originalAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          amountIn,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [pair, ...currentPairs],\n          originalAmountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","import { TradeType } from './constants'\nimport invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from './utils'\nimport { CurrencyAmount, NETWORK_CCY, Percent, Trade } from './entities'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\nexport interface TradeOptionsDeadline extends Omit<TradeOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Router, and has static methods for helping execute trades.\n */\nexport abstract class Router {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(trade: Trade, options: TradeOptions | TradeOptionsDeadline): SwapParameters {\n    const etherIn = trade.inputAmount.currency === NETWORK_CCY[trade.route.chainId]\n    const etherOut = trade.outputAmount.currency === NETWORK_CCY[trade.route.chainId]\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map((token) => token.address)\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = useFeeOnTransfer\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n            : 'swapExactTokensForTokens'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n      case TradeType.EXACT_OUTPUT:\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = 'swapTokensForExactTokens'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n","import { Contract } from '@ethersproject/contracts'\nimport { getNetwork } from '@ethersproject/networks'\nimport { getDefaultProvider } from '@ethersproject/providers'\nimport { TokenAmount } from './entities/fractions/tokenAmount'\nimport { Pair } from './entities/pair'\nimport IPancakePair from '@pancakeswap-libs/pancake-swap-core/build/IPancakePair.json'\nimport invariant from 'tiny-invariant'\nimport ERC20 from './abis/ERC20.json'\nimport { ChainId } from './constants'\nimport { Token } from './entities/token'\n\nlet TOKEN_DECIMALS_CACHE: { [chainId: number]: { [address: string]: number } } = {\n  [ChainId.BSC_MAINNET]: {\n    '0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A': 9 // DGD\n  }\n}\n\n/**\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\n */\nexport abstract class Fetcher {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * Fetch information for a given token on the given chain, using the given ethers provider.\n   * @param chainId chain of the token\n   * @param address address of the token on the chain\n   * @param provider provider used to fetch the token\n   * @param symbol optional symbol of the token\n   * @param name optional name of the token\n   */\n  public static async fetchTokenData(\n    chainId: ChainId,\n    address: string,\n    provider = getDefaultProvider(getNetwork(chainId)),\n    symbol?: string,\n    name?: string\n  ): Promise<Token> {\n    const parsedDecimals =\n      typeof TOKEN_DECIMALS_CACHE?.[chainId]?.[address] === 'number'\n        ? TOKEN_DECIMALS_CACHE[chainId][address]\n        : await new Contract(address, ERC20, provider).decimals().then((decimals: number): number => {\n            TOKEN_DECIMALS_CACHE = {\n              ...TOKEN_DECIMALS_CACHE,\n              [chainId]: {\n                ...TOKEN_DECIMALS_CACHE?.[chainId],\n                [address]: decimals\n              }\n            }\n            return decimals\n          })\n    return new Token(chainId, address, parsedDecimals, symbol, name)\n  }\n\n  /**\n   * Fetches information about a pair and constructs a pair from the given two tokens.\n   * @param tokenA first token\n   * @param tokenB second token\n   * @param provider the provider to use to fetch the data\n   */\n  public static async fetchPairData(\n    tokenA: Token,\n    tokenB: Token,\n    provider = getDefaultProvider(getNetwork(tokenA.chainId))\n  ): Promise<Pair> {\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID')\n    const address = Pair.getAddress(tokenA, tokenB)\n    const [reserves0, reserves1] = await new Contract(address, IPancakePair.abi, provider).getReserves()\n    const balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0]\n    return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]))\n  }\n\n}\n","import { BigNumber } from 'ethers'\nimport invariant from 'tiny-invariant'\nimport { SwapStorage } from './swapStorage'\n\nconst MAX_ITERATION = 256\nexport const A_PRECISION = BigNumber.from(100)\nconst FEE_DENOMINATOR = BigNumber.from(1e10)\n\n\nexport function _xp(balances: BigNumber[], rates: BigNumber[]): BigNumber[] {\n    let result = []\n    for (let i = 0; i < balances.length; i++) {\n        result.push(rates[i].mul(balances[i]))\n    }\n    return result\n}\n\n\nexport function _getAPrecise(blockTimestamp: BigNumber,\n    swapStorage: SwapStorage\n): BigNumber {\n    if (blockTimestamp.gte(swapStorage.futureATime)) {\n        return swapStorage.futureA;\n    }\n\n    if (swapStorage.futureA.gt(swapStorage.initialA)) {\n        return swapStorage.initialA.add(\n            swapStorage.futureA.sub(swapStorage.initialA).mul(blockTimestamp.sub(swapStorage.initialATime)).div(\n                swapStorage.futureATime.sub(swapStorage.initialATime)))\n    }\n\n    return swapStorage.initialA.sub(swapStorage.initialA.sub(swapStorage.futureA).mul(blockTimestamp.sub(swapStorage.initialATime))).div(\n        swapStorage.futureATime.sub(swapStorage.initialATime))\n}\n\nexport function _sumOf(x: BigNumber[]): BigNumber {\n    let sum = BigNumber.from(0);\n    for (let i = 0; i < x.length; i++) {\n        sum = sum.add(x[i])\n    }\n    return sum\n}\n\n\nexport function _distance(x: BigNumber, y: BigNumber): BigNumber {\n    return x.gt(y) ? x.sub(y) : y.sub(x)\n}\n\n/**\n * Calculate D for *NORMALIZED* balances of each tokens\n * @param xp normalized balances of token\n */\nexport function _getD(xp: BigNumber[], amp: BigNumber): BigNumber {\n    const nCoins = xp.length;\n    let sum = _sumOf(xp)\n    if (sum.eq(0)) {\n        return BigNumber.from(0)\n    }\n\n    let Dprev = BigNumber.from(0)\n    let D = sum;\n    let Ann = amp.mul(nCoins)\n\n    for (let i = 0; i < MAX_ITERATION; i++) {\n        let D_P = D;\n        for (let j = 0; j < xp.length; j++) {\n            D_P = D_P.mul(D).div(xp[j].mul(nCoins))\n        }\n\n        Dprev = D;\n        D = ((Ann.mul(sum)).div(A_PRECISION).add(D_P.mul(nCoins)).mul(D)).div(\n            ((Ann.sub(A_PRECISION)).mul(D).div(A_PRECISION)).add(D_P.mul(nCoins + 1)))\n\n        if (_distance(D, Dprev).lte(1)) {\n            return D;\n        }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    invariant(\"invariantCalculationFailed\");\n    return D\n}\n\nexport function _getY(\n    inIndex: number,\n    outIndex: number,\n    inBalance: BigNumber,\n    // self, shoudl be replaced with swapStorage object\n    blockTimestamp: BigNumber,\n    swapStorage: SwapStorage,\n    normalizedBalances: BigNumber[]\n\n): BigNumber {\n    invariant(inIndex != outIndex, \"sameToken\");\n    const nCoins = normalizedBalances.length;\n    invariant(inIndex < nCoins && outIndex < nCoins, \"indexOutOfRange\");\n\n    let amp = _getAPrecise(blockTimestamp, swapStorage);\n    let Ann = amp.mul(nCoins)\n    let D = _getD(normalizedBalances, amp);\n    let sum = BigNumber.from(0) // sum of new balances except output token\n    let c = D;\n    for (let i = 0; i < nCoins; i++) {\n        if (i == outIndex) {\n            continue;\n        }\n\n        let x = i == inIndex ? inBalance : normalizedBalances[i];\n        sum = sum.add(x)\n        c = (c.mul(D)).div(x.mul(nCoins))\n    }\n\n    c = c.mul(D.mul(A_PRECISION)).div(Ann.mul(nCoins))\n    let b = sum.add(D.mul(A_PRECISION).div(Ann))\n\n    let lastY = BigNumber.from(0)\n    let y = D;\n    for (let index = 0; index < MAX_ITERATION; index++) {\n        lastY = y;\n        y = ((y.mul(y)).add(c)).div(y.mul(2).add(b).sub(D))\n        if (_distance(lastY, y).lte(1)) {\n            return y;\n        }\n    }\n\n    invariant(\"yCalculationFailed\")\n    return BigNumber.from(0)\n}\n\nexport function calculateSwap(inIndex: number, outIndex: number, inAmount: BigNumber, // standard fields\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    swapStorage: SwapStorage\n): BigNumber {\n    let normalizedBalances = _xp(balances, swapStorage.tokenMultipliers)\n    let newInBalance = normalizedBalances[inIndex].add(inAmount.mul(swapStorage.tokenMultipliers[inIndex]))\n    let outBalance = _getY(\n        inIndex,\n        outIndex,\n        newInBalance,\n        blockTimestamp, swapStorage,\n        normalizedBalances\n    )\n\n    let outAmount = ((normalizedBalances[outIndex].sub(outBalance)).sub(1)).div(swapStorage.tokenMultipliers[outIndex])\n    let _fee = swapStorage.fee.mul(outAmount).div(FEE_DENOMINATOR)\n    return outAmount.sub(_fee)\n}\n\n\n\n// function to calculate the amounts of stables from the amounts of LP\nexport function _calculateRemoveLiquidity(\n    amount: BigNumber,\n    swapStorage: SwapStorage,\n    totalSupply: BigNumber,\n    currentWithdrawFee: BigNumber,\n    balances: BigNumber[]\n): BigNumber[] {\n\n    invariant(amount.lte(totalSupply), \"Cannot exceed total supply\");\n\n    let feeAdjustedAmount = amount.mul(FEE_DENOMINATOR.sub(currentWithdrawFee)).div(\n        FEE_DENOMINATOR)\n\n    let amounts = []\n\n    for (let i = 0; i < swapStorage.tokenMultipliers.length; i++) {\n        amounts.push((balances[i].mul(feeAdjustedAmount)).div(totalSupply))\n    }\n    return amounts;\n}\n\n\nfunction _getYD(\n    A: BigNumber,\n    index: number,\n    xp: BigNumber[],\n    D: BigNumber\n): BigNumber {\n    let nCoins = xp.length;\n    invariant(index < nCoins, \"INDEX\");\n    let Ann = A.mul(nCoins)\n    let c = D;\n    let s = BigNumber.from(0)\n    let _x = BigNumber.from(0)\n    let yPrev = BigNumber.from(0)\n\n    for (let i = 0; i < nCoins; i++) {\n        if (i == index) {\n            continue;\n        }\n        _x = xp[i];\n        s = s.add(_x)\n        c = (c.mul(D)).div(_x.mul(nCoins))\n    }\n\n    c = (c.mul(D).mul(A_PRECISION)).div(Ann.mul(nCoins))\n    let b = s.add(D.mul(A_PRECISION).div(Ann))\n    let y = D;\n\n    for (let i = 0; i < MAX_ITERATION; i++) {\n        yPrev = y;\n        y = ((y.mul(y)).add(c)).div(((y.mul(2)).add(b)).sub(D))\n        if (_distance(yPrev, y).lt(1)) {\n            return y;\n        }\n    }\n    invariant(\"invariantCalculationFailed\")\n    return BigNumber.from(0)\n}\n\nfunction _feePerToken(swapStorage: SwapStorage): BigNumber {\n    let nCoins = swapStorage.tokenMultipliers.length;\n    return (swapStorage.fee.mul(nCoins)).div(4 * (nCoins - 1));\n}\n\n\nexport function _calculateRemoveLiquidityOneToken(\n    swapStorage: SwapStorage,\n    tokenAmount: BigNumber,\n    index: number,\n    blockTimestamp: BigNumber,\n    balances: BigNumber[],\n    totalSupply: BigNumber,\n    currentWithdrawFee: BigNumber\n): { [returnVal: string]: BigNumber }// {dy:BigNumber, fee:BigNumber} \n{\n    invariant(index < swapStorage.tokenMultipliers.length, \"indexOutOfRange\")\n\n    let amp = _getAPrecise(blockTimestamp, swapStorage)\n    let xp = _xp(balances, swapStorage.tokenMultipliers)\n    let D0 = _getD(xp, amp);\n    let D1 = D0.sub((tokenAmount.mul(D0)).div(totalSupply))\n    let newY = _getYD(amp, index, xp, D1);\n    let reducedXP = xp;\n    let _fee = _feePerToken(swapStorage);\n\n    for (let i = 0; i < swapStorage.tokenMultipliers.length; i++) {\n        let expectedDx = BigNumber.from(0)\n        if (i == index) {\n            expectedDx = ((xp[i].mul(D1)).div(D0)).sub(newY)\n        } else {\n            expectedDx = xp[i].sub(xp[i].mul(D1).div(D0))\n        }\n        reducedXP[i] = reducedXP[i].sub(_fee.mul(expectedDx).div(FEE_DENOMINATOR))\n    }\n\n    let dy = reducedXP[index].sub(_getYD(amp, index, reducedXP, D1))\n    dy = (dy.sub(1)).div(swapStorage.tokenMultipliers[index])\n    let fee = ((xp[index].sub(newY)).div(swapStorage.tokenMultipliers[index])).sub(dy)\n    dy = dy.mul(FEE_DENOMINATOR.sub(currentWithdrawFee)).div(FEE_DENOMINATOR)\n    return { \"dy\": dy, \"fee\": fee }\n}\n\n\n/**\n * Estimate amount of LP token minted or burned at deposit or withdrawal\n * without taking fees into account\n */\nexport function _calculateTokenAmount(\n    swapStorage: SwapStorage,\n    amounts: BigNumber[],\n    deposit: boolean,\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    totalSupply: BigNumber\n): BigNumber {\n    let nCoins = swapStorage.tokenMultipliers.length;\n    invariant(amounts.length == nCoins, \"invalidAmountsLength\");\n    let amp = _getAPrecise(blockTimestamp, swapStorage);\n    let D0 = _getD(_xp(balances, swapStorage.tokenMultipliers), amp);\n\n    let newBalances = balances;\n    for (let i = 0; i < nCoins; i++) {\n        if (deposit) {\n            newBalances[i] = newBalances[i].add(amounts[i])\n        } else {\n            newBalances[i] = newBalances[i].sub(amounts[i])\n        }\n    }\n\n    let D1 = _getD(_xp(newBalances, swapStorage.tokenMultipliers), amp);\n\n\n    if (totalSupply.eq(0)) {\n        return D1; // first depositor take it all\n    }\n\n    let diff = deposit ? D1.sub(D0) : D0.sub(D1)\n    return (diff.mul(totalSupply)).div(D0)\n}","import { BigNumber } from \"ethers\"\n\nexport class SwapStorage {\n    public readonly tokenMultipliers: BigNumber[]\n    public readonly fee: BigNumber\n    public readonly adminFee: BigNumber\n    public readonly initialA: BigNumber\n    public readonly futureA: BigNumber\n    public readonly initialATime: BigNumber\n    public readonly futureATime: BigNumber\n    public readonly lpAddress: string\n\n    constructor(tokenMultipliers: BigNumber[],\n        fee: BigNumber,\n        adminFee: BigNumber,\n        initialA: BigNumber,\n        futureA: BigNumber,\n        initialATime: BigNumber,\n        futureATime: BigNumber,\n        lpAddress: string) {\n        this.lpAddress = lpAddress\n        this.tokenMultipliers = tokenMultipliers\n        this.fee = fee\n        this.adminFee = adminFee\n        this.initialA = initialA\n        this.futureA = futureA\n        this.initialATime = initialATime\n        this.futureATime = futureATime\n    }\n\n    public static mock(): SwapStorage {\n        const dummy = BigNumber.from(0)\n        return new SwapStorage([dummy], dummy, dummy, dummy, dummy, dummy, dummy, '')\n    }\n\n}","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\nimport {\n  _getAPrecise,\n  calculateSwap,\n  _calculateRemoveLiquidity,\n  _calculateRemoveLiquidityOneToken,\n  _calculateTokenAmount\n} from './stableCalc'\nimport { Contract } from '@ethersproject/contracts'\nimport { ethers } from 'ethers'\nimport { SwapStorage } from './swapStorage'\nimport {\n  BigintIsh,\n  ChainId,\n  STABLE_POOL_ADDRESS,\n  STABLE_POOL_LP_ADDRESS\n} from '../constants'\nimport StableSwap from '../abis/RequiemStableSwap.json'\nimport { Token } from './token'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport { Pair } from './pair'\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport class StablePool {\n  // the only LP token\n  public readonly liquidityToken: Token\n  // the index-token map \n  public readonly tokens: { [index: number]: Token }\n  public tokenBalances: BigNumber[]\n  public _A: BigNumber\n  public swapStorage: SwapStorage\n  // public readonly rates: BigNumber[]\n  public blockTimestamp: BigNumber\n\n  public lpTotalSupply: BigNumber\n  public currentWithdrawFee: BigNumber\n\n  public static getRouterAddress(chainId: number): string {\n    return STABLE_POOL_ADDRESS[chainId]\n  }\n\n  public static getLpAddress(chainId: number): string {\n    return STABLE_POOL_LP_ADDRESS[chainId]\n  }\n\n  public constructor(\n    tokens: { [index: number]: Token },\n    tokenBalances: BigNumber[],\n    _A: BigNumber,\n    swapStorage: SwapStorage,\n    blockTimestamp: number,\n    lpTotalSupply: BigNumber,\n    currentWithdrawFee: BigNumber\n  ) {\n    this.currentWithdrawFee = currentWithdrawFee\n    this.lpTotalSupply = lpTotalSupply\n    this.swapStorage = swapStorage\n    this.blockTimestamp = BigNumber.from(blockTimestamp)\n    this.tokens = tokens\n    this.tokenBalances = tokenBalances\n    this._A = _A\n    this.liquidityToken = new Token(\n      tokens[0].chainId,\n      STABLE_POOL_LP_ADDRESS[tokens[0].chainId] ?? '0x0000000000000000000000000000000000000001',\n      18,\n      'RequiemStable-LP',\n      'Requiem StableSwap LPs'\n    )\n\n    for (let i = 0; i < Object.values(this.tokens).length; i++) {\n      invariant(tokens[i].address != ethers.constants.AddressZero, \"invalidTokenAddress\");\n      invariant(tokens[i].decimals <= 18, \"invalidDecimals\");\n      invariant(tokens[i].chainId === tokens[0].chainId, 'INVALID TOKENS')\n    }\n  }\n\n  public static mock() {\n    const dummy = BigNumber.from(0)\n    return new StablePool({ 0: new Token(1, '0x0000000000000000000000000000000000000001', 6, 'Mock USDC', 'MUSDC') }, [dummy], dummy, SwapStorage.mock(), 0, dummy, dummy)\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    let res = false\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      res || token.equals(this.tokens[i])\n    }\n\n    return res\n  }\n\n  public set setCurrentWithdrawFee(feeToSet: BigNumber) {\n    this.currentWithdrawFee = feeToSet\n  }\n\n  // maps the index to the token in the stablePool\n  public tokenFromIndex(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public indexFromToken(token: Token): number {\n    for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n      if (token.equals(this.tokens[index])) {\n        return index\n      }\n    }\n    throw new Error('token not in pool');\n  }\n\n  public getBalances(): BigNumber[] {\n    return Object.keys(this.tokens).map((_, index) => (this.tokenBalances[index]))\n  }\n\n\n  public generatePairs(pairs: Pair[]) {\n    let relevantStables: Token[] = []\n    let generatedPairs: Pair[] = []\n    pairs.forEach(pair => {\n      if (Object.values(this.tokens).includes(pair.token0)) {\n        relevantStables.push(pair.token0)\n      }\n      if (Object.values(this.tokens).includes(pair.token1)) {\n        relevantStables.push(pair.token1)\n      }\n    })\n    if (relevantStables.length === 0) {\n      return []\n    }\n    for (let i = 0; i < relevantStables.length; i++) {\n      for (let j = i + 1; j < relevantStables.length; j++) {\n        //generatedPairs.push(new Pair(relevantStables[i], relevantStables[j]))\n      }\n    }\n    return generatedPairs\n  }\n\n  // calculates the output amount usingn the input for the swableSwap\n  // requires the view on a contract as manual calculation on the frontend would\n  // be inefficient\n  public async calculateSwapViaPing(\n    inIndex: number,\n    outIndex: number,\n    inAmount: BigNumber | BigintIsh,\n    chainId: number,\n    provider: ethers.Signer | ethers.providers.Provider): Promise<BigintIsh> {\n\n    const outAmount: BigintIsh = await new Contract(StablePool.getRouterAddress(chainId), new ethers.utils.Interface(StableSwap), provider).calculateSwap(inIndex, outIndex, inAmount)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwap(\n    inIndex: number,\n    outIndex: number,\n    inAmount: BigNumber): BigNumber {\n\n    const outAmount: BigNumber = calculateSwap(\n      inIndex,\n      outIndex,\n      inAmount,\n      this.getBalances(),\n      this.blockTimestamp,\n      this.swapStorage)\n\n    return outAmount\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount, outIndex: number): TokenAmount {\n    const swap = this.calculateSwap(this.indexFromToken(inputAmount.token), outIndex, inputAmount.toBigNumber())\n    return new TokenAmount(this.tokenFromIndex(outIndex), swap.toBigInt())\n  }\n\n  public getInputAmount(outputAmount: TokenAmount, inIndex: number): TokenAmount {\n    const swap = this.calculateSwap(inIndex, this.indexFromToken(outputAmount.token), outputAmount.toBigNumber())\n    return new TokenAmount(this.tokenFromIndex(inIndex), swap.toBigInt())\n  }\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.tokens[0].chainId\n  }\n\n  public token(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public reserveOf(token: Token): BigNumber {\n    invariant(this.involvesToken(token), 'TOKEN')\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      if (token.equals(this.tokens[i]))\n        return this.tokenBalances[i]\n    }\n    return BigNumber.from(0)\n  }\n\n  public calculateRemoveLiquidity(amountLp: BigNumber): BigNumber[] {\n    return _calculateRemoveLiquidity(\n      amountLp,\n      this.swapStorage,\n      this.lpTotalSupply,\n      this.currentWithdrawFee,\n      this.getBalances()\n    )\n  }\n\n  public calculateRemoveLiquidityOneToken(amount: BigNumber, index: number): { [returnVal: string]: BigNumber } {\n    return _calculateRemoveLiquidityOneToken(\n      this.swapStorage,\n      amount,\n      index,\n      this.blockTimestamp,\n      this.getBalances(),\n      this.lpTotalSupply,\n      this.currentWithdrawFee\n    )\n  }\n\n  public getLiquidityAmount(amounts: BigNumber[], deposit: boolean) {\n    return _calculateTokenAmount(\n      this.swapStorage,\n      amounts,\n      deposit,\n      this.getBalances(),\n      this.blockTimestamp,\n      this.lpTotalSupply\n    )\n  }\n\n  public getLiquidityValue(outIndex: number, userBalances: BigNumber[]): TokenAmount {\n    let amount = BigNumber.from(0)\n    for (let i = 0; i < userBalances.length; i++) {\n      if (i !== outIndex)\n        amount = amount.add(this.calculateSwap(i, outIndex, userBalances[i]))\n    }\n    amount = amount.add(userBalances[outIndex])\n    return new TokenAmount(this.tokens[outIndex], amount.toBigInt())\n  }\n\n  public setSwapStorage(swapStorage: SwapStorage) {\n    this.swapStorage = swapStorage\n  }\n\n  public setTokenBalances(tokenBalances: BigNumber[]) {\n    this.tokenBalances = tokenBalances\n  }\n\n  public setBlockTimestamp(blockTimestamp: BigNumber) {\n    this.blockTimestamp = blockTimestamp\n  }\n\n  public setLpTotalSupply(totalSupply: BigNumber) {\n    this.lpTotalSupply = totalSupply\n  }\n\n  public setBalanceValueByIndex(index: number, newBalance: BigNumber) {\n    this.tokenBalances[index] = newBalance\n  }\n\n  public setBalanceValue(tokenAmount: TokenAmount) {\n    this.tokenBalances[this.indexFromToken(tokenAmount.token)] = tokenAmount.toBigNumber()\n  }\n\n\n  /*\n    public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, StablePool] {\n      invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n      if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n        throw new InsufficientReservesError()\n      }\n      const inputReserve = this.reserveOf(inputAmount.token)\n      const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n      const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR)\n      const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\n      const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee)\n      const outputAmount = new TokenAmount(\n        inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n        JSBI.divide(numerator, denominator)\n      )\n      if (JSBI.equal(outputAmount.raw, ZERO)) {\n        throw new InsufficientInputAmountError()\n      }\n      return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n    }\n  \n    public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\n      invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n      if (\n        JSBI.equal(this.reserve0.raw, ZERO) ||\n        JSBI.equal(this.reserve1.raw, ZERO) ||\n        JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\n      ) {\n        throw new InsufficientReservesError()\n      }\n  \n      const outputReserve = this.reserveOf(outputAmount.token)\n      const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n      const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR)\n      const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR)\n      const inputAmount = new TokenAmount(\n        outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n        JSBI.add(JSBI.divide(numerator, denominator), ONE)\n      )\n      return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n    }\n  \n    public getLiquidityAmount(\n      totalSupply: TokenAmount,\n      tokenAmountA: TokenAmount,\n      tokenAmountB: TokenAmount\n    ): TokenAmount {\n      invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n      const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n        ? [tokenAmountA, tokenAmountB]\n        : [tokenAmountB, tokenAmountA]\n      invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n  \n      let liquidity: JSBI\n      if (JSBI.equal(totalSupply.raw, ZERO)) {\n        liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\n      } else {\n        const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\n        const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\n        liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n      }\n      if (!JSBI.greaterThan(liquidity, ZERO)) {\n        throw new InsufficientInputAmountError()\n      }\n      return new TokenAmount(this.liquidityToken, liquidity)\n    }\n  \n    public getLiquidityValue(\n      token: Token,\n      totalSupply: TokenAmount,\n      liquidity: TokenAmount,\n      feeOn: boolean = false,\n      kLast?: BigintIsh\n    ): TokenAmount {\n      invariant(this.involvesToken(token), 'TOKEN')\n      invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n      invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n      invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n  \n      let totalSupplyAdjusted: TokenAmount\n      if (!feeOn) {\n        totalSupplyAdjusted = totalSupply\n      } else {\n        invariant(!!kLast, 'K_LAST')\n        const kLastParsed = parseBigintIsh(kLast)\n        if (!JSBI.equal(kLastParsed, ZERO)) {\n          const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\n          const rootKLast = sqrt(kLastParsed)\n          if (JSBI.greaterThan(rootK, rootKLast)) {\n            const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\n            const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n            const feeLiquidity = JSBI.divide(numerator, denominator)\n            totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n          } else {\n            totalSupplyAdjusted = totalSupply\n          }\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      }\n  \n      return new TokenAmount(\n        token,\n        JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n      )\n    } */\n}\n","import { ethers } from 'ethers'\n// import { BigNumber } from 'ethers'\n// import { getNetwork } from '@ethersproject/networks'\n// import { getDefaultProvider } from '@ethersproject/providers'\n// import { TokenAmount } from './entities/fractions/tokenAmount'\n// import { Pair } from './entities/pair'\nimport { StablePool } from './entities/stablePool'\n// import IPancakePair from '@pancakeswap-libs/pancake-swap-core/build/IPancakePair.json'\n// import invariant from 'tiny-invariant'\n// import ERC20 from './abis/ERC20.json'\nimport StableSwap from './abis/RequiemStableSwap.json'\n// import { STABLES_INDEX_MAP } from './entities/stables'\n// import { Token } from './entities/token'\n\n\n/**\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\n */\nexport abstract class StablesFetcher {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() { }\n\n  /**\n   * Fetches information about the stablePool and constructs a StablePool Object from the contract deployed.\n   * @param tokenA first token\n   * @param tokenB second token\n   * @param provider the provider to use to fetch the data\n   */\n  public static async fetchStablePoolData(\n    chainId: number,\n    provider: ethers.providers.Provider\n  ): Promise<StablePool> {\n    const address = StablePool.getRouterAddress(chainId)\n    console.log(\"address\", address)\n    const tokenAddresses = await new ethers.Contract(address, StableSwap, provider).getTokens()\n    console.log(\"TokenAddresses\", tokenAddresses)\n    // const tokenReserves = await new ethers.Contract(address, StableSwap, provider).getTokenBalances()\n    let indexes = []\n    for (let i = 0; i < tokenAddresses.length; i++) {\n      indexes.push(i)\n    }\n    // const tokenMap = Object.assign({},\n    //   ...(tokenAddresses as string[]).map((_, index) => ({\n    //     [index]: new TokenAmount(\n    //       STABLES_INDEX_MAP[chainId][index],\n    //       tokenReserves[index])\n    //   })))\n    return StablePool.mock()\n  }\n\n}\n","import { TradeType } from './constants'\nimport invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from './utils'\nimport { CurrencyAmount, NETWORK_CCY, Percent } from './entities'\nimport { TradeV3 } from './entities/tradeV3'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeV3Options {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\nexport interface TradeV3OptionsDeadline extends Omit<TradeV3Options, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Router to execute a trade.\n */\nexport interface SwapV3Parameters {\n  /**\n   * The method to call on the Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Router, and has static methods for helping execute trades.\n */\nexport abstract class RouterV3 {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(trade: TradeV3, options: TradeV3Options | TradeV3OptionsDeadline): SwapV3Parameters {\n    const etherIn = trade.inputAmount.currency === NETWORK_CCY[trade.route.chainId]\n    const etherOut = trade.outputAmount.currency === NETWORK_CCY[trade.route.chainId]\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map((token) => token.address)\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = useFeeOnTransfer\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n            : 'swapExactTokensForTokens'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n      case TradeType.EXACT_OUTPUT:\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = 'swapTokensForExactTokens'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n","import { Token } from './token'\nimport { ChainId } from '../constants'\n\nexport const STABLECOINS: { [chainId: number]: Token[] } = {\n  43113: [\n    new Token(ChainId.AVAX_TESTNET, '0xca9ec7085ed564154a9233e1e7d8fef460438eea', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.AVAX_TESTNET, '0xffb3ed4960cac85372e6838fbc9ce47bcf2d073e', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.AVAX_TESTNET, '0xaea51e4fee50a980928b4353e852797b54deacd8', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.AVAX_TESTNET, '0xccf7ed44c5a0f3cb5c9a9b9f765f8d836fb93ba1', 18, 'TUSD', 'True USD'),\n  ],\n  0: [// dummy value\n    new Token(-1, '0xCa9eC7085Ed564154a9233e1e7D8fEF460438EEA', 6, 'USDC', 'USD Coin')]\n}\n\n\nexport const STABLES_INDEX_MAP: { [chainId: number]: { [index: number]: Token } } = {\n  43113: {\n    0: STABLECOINS[43113][0],\n    1: STABLECOINS[43113][1],\n    2: STABLECOINS[43113][2],\n    3: STABLECOINS[43113][3]\n  }\n}\n\nexport const STABLES_LP_TOKEN: { [chainId: number]: { [index: number]: Token } } = {\n  43113: {\n    0: STABLECOINS[43113][0],\n    1: STABLECOINS[43113][1],\n    2: STABLECOINS[43113][2],\n    3: STABLECOINS[43113][3]\n  }\n}","import { StablePool } from \"./stablePool\";\nimport { Token, } from \"./token\";\nimport { Price } from \"./fractions/price\";\nimport { TokenAmount } from \"./fractions/tokenAmount\";\nimport invariant from \"tiny-invariant\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Source } from './source';\nimport { ChainId, STABLE_POOL_LP_ADDRESS } from \"./../constants\";\n\n// A class that wraps a stablePool to a pair-like structure\nexport class StablePairWrapper implements Source {\n\n    // the tokenAmounts are the reference Balances that we keep track of in the stablePool\n    // whenever we make changes to these, we need to update the stablePool reference Balance to calculate the correct \n    public readonly tokenAmounts: TokenAmount[]\n    public readonly stableIndexes: number[]\n\n    // the tokenAmount for calculating the price\n    // these cannot be derived from the tokenAmounts since\n    // they follow the stableSwap logic for pricing\n    public readonly pricingBasesIn: TokenAmount[]\n    public readonly pricingBasesOut: TokenAmount[]\n    public readonly type: string\n    public readonly referenceMidPrices: Price[]\n    public readonly liquidityToken: Token\n    // public readonly inputReserve: TokenAmount\n    // public readonly outputReserve: TokenAmount\n\n    constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount, indexA: number, indexB: number) {\n\n        invariant(tokenAmountA.token.chainId === tokenAmountB.token.chainId, 'CHAIN_IDS')\n        \n        this.liquidityToken = new Token(\n            tokenAmountA.token.chainId,\n            STABLE_POOL_LP_ADDRESS[tokenAmountA.token.chainId] ?? '0x0000000000000000000000000000000000000001',\n            18,\n            'RequiemStable-LP',\n            'Requiem StableSwap LPs'\n        )\n\n        this.tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA]\n        this.stableIndexes = tokenAmountA.token.sortsBefore(tokenAmountB.token) ? [indexA, indexB] : [indexB, indexA]\n\n        this.pricingBasesIn = tokenAmountA.token.sortsBefore(tokenAmountB.token) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA]\n        this.pricingBasesOut = tokenAmountA.token.sortsBefore(tokenAmountB.token) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA]\n        this.referenceMidPrices = []\n        this.type = 'StablePairWrapper'\n    }\n\n    /**\n     * Returns the chain ID of the tokens in the pair.\n     */\n    public get chainId(): ChainId {\n        return this.token0.chainId\n    }\n\n    public get token0(): Token {\n        return this.tokenAmounts[0].token\n    }\n\n    public get token1(): Token {\n        return this.tokenAmounts[1].token\n    }\n\n    // reserves cannot be this.tokenAmounts because\n    // these are directly used for prices\n    public get reserve0(): TokenAmount {\n        return this.tokenAmounts[0]\n    }\n\n    public get reserve1(): TokenAmount {\n        return this.tokenAmounts[1]\n    }\n\n    // this gets the reserve of the respectve (stable) token\n    public reserveOf(token: Token): TokenAmount {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.reserve0 : this.reserve1\n    }\n\n    public involvesToken(token: Token): boolean {\n        return token.equals(this.token0) || token.equals(this.token1)\n    }\n\n\n    public priceOf(token: Token, stablePool: StablePool, volume: BigNumber) {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.token0Price(stablePool, volume) : this.token1Price(stablePool, volume)\n    }\n\n    /**\n * Returns the current price at given volume of the pair in terms of token0, i.e. the ratio calculated by the stableSwap\n */\n    public token0Price(stablePool: StablePool, volume: BigNumber): Price {\n        const outToken1 = stablePool.calculateSwap(this.stableIndexes[0], this.stableIndexes[1], volume)\n        return new Price(this.token0, this.token1, outToken1.toBigInt(), volume.toBigInt())\n    }\n\n    /**\n * Returns the current mid price of the pair in terms of token1, i.e. the ratio calculated by the stableSwap\n */\n    public token1Price(stablePool: StablePool, volume: BigNumber): Price {\n        const outToken0 = stablePool.calculateSwap(this.stableIndexes[1], this.stableIndexes[0], volume)\n        return new Price(this.token1, this.token0, outToken0.toBigInt(), volume.toBigInt())\n    }\n\n    public priceFromReserve(outToken: Token) {\n        const outIndex = outToken.equals(this.token0) ? 0 : 1\n        const inIndex = outToken.equals(this.token1) ? 0 : 1\n        return new Price(\n            this.pricingBasesIn[inIndex].token,\n            this.pricingBasesOut[outIndex].token,\n            this.pricingBasesIn[inIndex].raw,\n            this.pricingBasesOut[outIndex].raw\n        )\n    }\n\n    // function that wraps the output calculation based on a stablePool\n    public getOutputAmount(inputAmount: TokenAmount, stablePool: StablePool): [TokenAmount, StablePairWrapper] {\n        invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n        const inputReserve = this.reserveOf(inputAmount.token)\n        const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n\n        // set the balance values to the expected valuses\n        stablePool.setBalanceValue(this.tokenAmounts[0])\n        stablePool.setBalanceValue(this.tokenAmounts[1])\n\n        const output = stablePool.getOutputAmount(\n            inputAmount,\n            this.token0.equals(inputAmount.token) ? this.stableIndexes[1] : this.stableIndexes[0])\n\n        // adjust the values based on the supposdly executed trade\n        stablePool.setBalanceValue(inputReserve.add(inputAmount))\n        stablePool.setBalanceValue(outputReserve.subtract(output))\n\n        // here we save the pricing results if it is called\n        const inIndex = inputAmount.token.equals(this.token0) ? 0 : 1\n        const outIndex = output.token.equals(this.token0) ? 0 : 1\n        this.pricingBasesIn[inIndex] = inputAmount\n        this.pricingBasesOut[outIndex] = output\n\n        return [\n            output,\n            new StablePairWrapper(\n                inputReserve.add(inputAmount),\n                outputReserve.subtract(output), stablePool.indexFromToken(inputReserve.token), stablePool.indexFromToken(outputReserve.token))\n        ]\n    }\n\n    // function that wraps the input calculation based on a stablePool\n    public getInputAmount(outputAmount: TokenAmount, stablePool: StablePool): [TokenAmount, StablePairWrapper] {\n        invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n\n        const outputReserve = this.reserveOf(outputAmount.token)\n        const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n        stablePool.setBalanceValue(this.tokenAmounts[0])\n        stablePool.setBalanceValue(this.tokenAmounts[1])\n\n        const input = stablePool.getInputAmount(\n            outputAmount,\n            this.token0.equals(outputAmount.token) ? this.stableIndexes[1] : this.stableIndexes[0])\n\n        // here we save the pricing results if it is called\n        const inIndex = input.token.equals(this.token0) ? 0 : 1\n        const outIndex = outputAmount.token.equals(this.token0) ? 0 : 1\n        this.pricingBasesIn[inIndex] = input\n        this.pricingBasesOut[outIndex] = outputAmount\n\n        stablePool.setBalanceValue(inputReserve.add(input))\n        stablePool.setBalanceValue(outputReserve.subtract(outputAmount))\n\n        return [input,\n            new StablePairWrapper(\n                inputReserve.add(input),\n                outputReserve.subtract(outputAmount), stablePool.indexFromToken(inputReserve.token), stablePool.indexFromToken(outputReserve.token))]\n    }\n}","import { ChainId } from '../constants'\nimport invariant from 'tiny-invariant'\n\nimport { Currency, NETWORK_CCY } from './currency'\nimport { Token, WRAPPED_NETWORK_TOKENS } from './token'\nimport { Pair } from './pair'\nimport { Price } from './fractions/price'\nimport { StablePool } from './stablePool'\nimport { StablePairWrapper } from './stablePairWrapper'\n\n// new version of the route \n// the first verion to include the stable pool for less friction\nexport class RouteV3 {\n  public readonly stablePool: StablePool\n  public readonly sources: (Pair|StablePairWrapper)[]\n  public readonly path: Token[]\n  public readonly input: Currency\n  public readonly output: Currency\n  public readonly midPrice: Price\n\n  public constructor(sources: (Pair|StablePairWrapper)[], stablePool: StablePool, input: Currency, output?: Currency) {\n    invariant(sources.length > 0, 'PAIRS')\n    invariant(\n      sources.every(source => source.chainId === sources[0].chainId),\n      'CHAIN_IDS'\n    )\n    invariant(\n      (input instanceof Token && sources[0].involvesToken(input)) ||\n      (input === NETWORK_CCY[sources[0].chainId] && sources[0].involvesToken(WRAPPED_NETWORK_TOKENS[sources[0].chainId])),\n      'INPUT'\n    )\n    invariant(\n      typeof output === 'undefined' ||\n      (output instanceof Token && sources[sources.length - 1].involvesToken(output)) ||\n      (output === NETWORK_CCY[sources[0].chainId] && sources[sources.length - 1].involvesToken(WRAPPED_NETWORK_TOKENS[sources[0].chainId])),\n      'OUTPUT'\n    )\n\n    const path: Token[] = [input instanceof Token ? input : WRAPPED_NETWORK_TOKENS[sources[0].chainId]]\n    for (const [i, source] of sources.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(source.token0) || currentInput.equals(source.token1), 'PATH')\n      const output = currentInput.equals(source.token0) ? source.token1 : source.token0\n      path.push(output)\n    }\n    this.stablePool = stablePool\n    this.sources = sources\n    this.path = path\n    this.midPrice = Price.fromRouteV3(this)\n    this.input = input\n    this.output = output ?? path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.sources[0].chainId\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\nimport { sortedInsert } from '../utils'\nimport { Currency, NETWORK_CCY } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount, InputOutput } from './fractions/tokenAmount'\nimport { Pair } from './pair'\nimport { RouteV3 } from './routeV3'\nimport { StablePairWrapper } from './stablePairWrapper'\nimport { StablePool } from './stablePool'\nimport { currencyEquals, Token, WRAPPED_NETWORK_TOKENS } from './token'\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nfunction computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n  return new Percent(slippage.numerator, slippage.denominator)\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparatorV3(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparatorV3(a: TradeV3, b: TradeV3) {\n  const ioComp = inputOutputComparatorV3(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptionsV3 {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === NETWORK_CCY[chainId]) return new TokenAmount(WRAPPED_NETWORK_TOKENS[chainId], currencyAmount.raw)\n  invariant(false, 'CURRENCY')\n}\n\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n  if (currency instanceof Token) return currency\n  if (currency === NETWORK_CCY[chainId]) return WRAPPED_NETWORK_TOKENS[chainId]\n  invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class TradeV3 {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: RouteV3\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The mid price after the trade executes assuming no slippage.\n   */\n  public readonly nextMidPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: RouteV3, amountIn: CurrencyAmount): TradeV3 {\n    return new TradeV3(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: RouteV3, amountOut: CurrencyAmount): TradeV3 {\n    return new TradeV3(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(route: RouteV3, amount: CurrencyAmount, tradeType: TradeType) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    const nextSources: (Pair | StablePairWrapper)[] = new Array(route.sources.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const source = route.sources[i]\n        const [outputAmount, nextSource] = source instanceof Pair ?\n          source.getOutputAmount(amounts[i]) :\n          source.getOutputAmount(amounts[i], route.stablePool)\n        amounts[i + 1] = outputAmount\n        nextSources[i] = nextSource\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const source = route.sources[i - 1]\n        const [inputAmount, nextSource] = source instanceof Pair ?\n          source.getInputAmount(amounts[i]) :\n          source.getInputAmount(amounts[i], route.stablePool)\n        amounts[i - 1] = inputAmount\n        nextSources[i - 1] = nextSource\n      }\n    }\n\n    this.route = route\n    this.tradeType = tradeType\n    this.inputAmount =\n      tradeType === TradeType.EXACT_INPUT\n        ? amount\n        : route.input === NETWORK_CCY[route.chainId]\n          ? CurrencyAmount.networkCCYAmount(route.chainId, amounts[0].raw)\n          : amounts[0]\n    this.outputAmount =\n      tradeType === TradeType.EXACT_OUTPUT\n        ? amount\n        : route.output === NETWORK_CCY[route.chainId]\n          ? CurrencyAmount.networkCCYAmount(route.chainId, amounts[amounts.length - 1].raw)\n          : amounts[amounts.length - 1]\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    this.nextMidPrice = Price.fromRouteV3(new RouteV3(nextSources, route.stablePool, route.input))\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return this.outputAmount instanceof TokenAmount\n        ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n        : CurrencyAmount.networkCCYAmount(this.route.chainId, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return this.inputAmount instanceof TokenAmount\n        ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n        : CurrencyAmount.networkCCYAmount(this.route.chainId, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn(\n    stablePool: StablePool,\n    sources: (Pair | StablePairWrapper)[],\n    currencyAmountIn: CurrencyAmount,\n    currencyOut: Currency,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptionsV3 = {},\n    // used in recursion.\n    currentSources: (Pair | StablePairWrapper)[] = [],\n    originalAmountIn: CurrencyAmount = currencyAmountIn,\n    bestTrades: TradeV3[] = []\n  ): TradeV3[] {\n    invariant(sources.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountIn === currencyAmountIn || currentSources.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountIn instanceof TokenAmount\n        ? currencyAmountIn.token.chainId\n        : currencyOut instanceof Token\n          ? currencyOut.chainId\n          : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = wrappedAmount(currencyAmountIn, chainId)\n    const tokenOut = wrappedCurrency(currencyOut, chainId)\n    for (let i = 0; i < sources.length; i++) {\n      let source = sources[i]\n\n\n      if (!source.token0.equals(amountIn.token) && !source.token1.equals(amountIn.token)) continue\n      if (source.reserve0.equalTo(ZERO) || source.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: TokenAmount\n      try {\n        ;[amountOut] = source instanceof Pair ? source.getOutputAmount(amountIn) : source.getOutputAmount(amountIn, stablePool)\n      } catch (error) {\n        // input too low\n        if ((error as any).isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new TradeV3(\n            new RouteV3([...currentSources, source], stablePool, originalAmountIn.currency, currencyOut),\n            originalAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparatorV3\n        )\n      } else if (maxHops > 1 && sources.length > 1) {\n        const sourcesExcludingThisSource = sources.slice(0, i).concat(sources.slice(i + 1, sources.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        TradeV3.bestTradeExactIn(\n          stablePool,\n          sourcesExcludingThisSource,\n          amountOut,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentSources, source],\n          originalAmountIn,\n          bestTrades\n        )\n      }\n\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param stablePool the stalePool used for the iteration - it will undergo changes\n   * @param sources the pairs / wrapped pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentSources used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut(\n    stablePool: StablePool,\n    sources: (Pair | StablePairWrapper)[],\n    currencyIn: Currency,\n    currencyAmountOut: CurrencyAmount,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptionsV3 = {},\n    // used in recursion.\n    currentSources: (Pair | StablePairWrapper)[] = [],\n    originalAmountOut: CurrencyAmount = currencyAmountOut,\n    bestTrades: TradeV3[] = []\n  ): TradeV3[] {\n    invariant(sources.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountOut === currencyAmountOut || currentSources.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountOut instanceof TokenAmount\n        ? currencyAmountOut.token.chainId\n        : currencyIn instanceof Token\n          ? currencyIn.chainId\n          : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountOut = wrappedAmount(currencyAmountOut, chainId)\n    const tokenIn = wrappedCurrency(currencyIn, chainId)\n    for (let i = 0; i < sources.length; i++) {\n      const source = sources[i]\n      // source irrelevant\n      if (!source.token0.equals(amountOut.token) && !source.token1.equals(amountOut.token)) continue\n      if (source.reserve0.equalTo(ZERO) || source.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: TokenAmount\n      try {\n        ;[amountIn] = source instanceof Pair ? source.getInputAmount(amountOut) : source.getInputAmount(amountOut, stablePool)\n      } catch (error) {\n        // not enough liquidity in this source\n        if ((error as any).isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new TradeV3(\n            new RouteV3([source, ...currentSources], stablePool, currencyIn, originalAmountOut.currency),\n            originalAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparatorV3\n        )\n      } else if (maxHops > 1 && sources.length > 1) {\n        const sourcesExcludingThisSource = sources.slice(0, i).concat(sources.slice(i + 1, sources.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        TradeV3.bestTradeExactOut(\n          stablePool,\n          sourcesExcludingThisSource,\n          currencyIn,\n          amountIn,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [source, ...currentSources],\n          originalAmountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n"],"names":["ChainId","TradeType","Rounding","SolidityType","FACTORY_ADDRESS","INIT_CODE_HASH","STABLE_POOL_ADDRESS","STABLE_POOL_LP_ADDRESS","MINIMUM_LIQUIDITY","JSBI","BigInt","ZERO","ONE","TWO","THREE","FIVE","TEN","_100","FEES_NUMERATOR","FEES_DENOMINATOR","SOLIDITY_TYPE_MAXIMA","uint8","uint256","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","name","_this","constructor","setPrototypeOf","prototype","Error","InsufficientInputAmountError","_this2","validateSolidityTypeInstance","value","solidityType","greaterThanOrEqual","invariant","lessThanOrEqual","validateAndParseAddress","address","getAddress","error","parseBigintIsh","bigintIsh","toString","sqrt","y","x","z","greaterThan","add","divide","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop","Currency","decimals","symbol","NETWORK_CCY","BSC_MAINNET","BSC_TESTNET","ARBITRUM_MAINNET","ARBITRUM_TETSNET_RINKEBY","AVAX_MAINNET","AVAX_TESTNET","MATIC_MAINNET","MATIC_TESTNET","ETHER","Token","chainId","projectLink","equals","other","this","sortsBefore","toLowerCase","currencyEquals","currencyA","currencyB","WETH","WRAPPED_NETWORK_TOKENS","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","numerator","denominator","invert","otherParsed","equal","multiply","subtract","equalTo","toSignificant","significantDigits","format","rounding","groupSeparator","Number","isInteger","set","precision","quotient","div","toSignificantDigits","decimalPlaces","toFixed","DP","RM","remainder","CurrencyAmount","currency","amount","parsedAmount","exponentiate","ether","networkCCYAmount","raw","toExact","toBigNumber","BigNumber","from","TokenAmount","token","Price","baseCurrency","quoteCurrency","scalar","fromRoute","route","prices","pairs","entries","pair","path","token0","reserve0","reserve1","slice","reduce","accumulator","currentValue","fromRouteV3","sources","source","type","pricingBasesIn","pricingBasesOut","fraction","quote","currencyAmount","_Fraction","adjusted","PAIR_ADDRESS_CACHE","Pair","tokenAmountA","tokenAmountB","tokenAmounts","liquidityToken","tokenA","tokenB","tokens","undefined","_PAIR_ADDRESS_CACHE2","getCreate2Address","keccak256","pack","involvesToken","token1","priceOf","token0Price","token1Price","reserveOf","getOutputAmount","inputAmount","inputReserve","outputReserve","inputAmountWithFee","outputAmount","getInputAmount","getLiquidityMinted","totalSupply","liquidity","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","Route","input","output","every","currentInput","midPrice","_100_PERCENT","Percent","inputOutputComparator","a","b","tradeComparator","ioComp","priceImpact","wrappedAmount","wrappedCurrency","Trade","tradeType","exactQuote","slippage","amounts","Array","nextPairs","EXACT_INPUT","i","nextPair","EXACT_OUTPUT","executionPrice","nextMidPrice","exactIn","amountIn","exactOut","amountOut","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","currentPairs","originalAmountIn","bestTrades","maxNumResults","maxHops","tokenOut","isInsufficientInputAmountError","pairsExcludingThisPair","concat","bestTradeExactOut","currencyIn","currencyAmountOut","originalAmountOut","tokenIn","isInsufficientReservesError","toHex","Router","swapCallParameters","trade","options","etherIn","etherOut","ttl","methodName","args","to","recipient","allowedSlippage","map","deadline","Math","floor","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer","TOKEN_DECIMALS_CACHE","Fetcher","fetchTokenData","provider","parsedDecimals","getDefaultProvider","getNetwork","_TOKEN_DECIMALS_CACHE2","_TOKEN_DECIMALS_CACHE3","Contract","ERC20","then","_TOKEN_DECIMALS_CACHE4","fetchPairData","IPancakePair","abi","getReserves","reserves0","reserves1","balances","A_PRECISION","FEE_DENOMINATOR","_xp","rates","result","mul","_getAPrecise","blockTimestamp","swapStorage","gte","futureATime","futureA","gt","initialA","sub","initialATime","_distance","_getD","xp","amp","nCoins","sum","_sumOf","eq","Dprev","D","Ann","D_P","j","lte","_getYD","A","index","c","s","_x","lt","SwapStorage","tokenMultipliers","fee","adminFee","lpAddress","mock","dummy","StablePool","tokenBalances","_A","lpTotalSupply","currentWithdrawFee","values","ethers","constants","AddressZero","getRouterAddress","getLpAddress","keys","tokenFromIndex","indexFromToken","getBalances","_","generatePairs","relevantStables","forEach","includes","calculateSwapViaPing","inIndex","outIndex","inAmount","utils","Interface","StableSwap","calculateSwap","normalizedBalances","outBalance","inBalance","_getY","outAmount","_fee","swap","toBigInt","calculateRemoveLiquidity","amountLp","feeAdjustedAmount","_calculateRemoveLiquidity","calculateRemoveLiquidityOneToken","tokenAmount","D0","D1","newY","reducedXP","_feePerToken","expectedDx","dy","_calculateRemoveLiquidityOneToken","getLiquidityAmount","deposit","newBalances","_calculateTokenAmount","userBalances","setSwapStorage","setTokenBalances","setBlockTimestamp","setLpTotalSupply","setBalanceValueByIndex","newBalance","setBalanceValue","feeToSet","StablesFetcher","fetchStablePoolData","console","log","getTokens","tokenAddresses","indexes","RouterV3","STABLECOINS","STABLES_INDEX_MAP","STABLES_LP_TOKEN","StablePairWrapper","indexA","indexB","stableIndexes","referenceMidPrices","stablePool","volume","outToken1","outToken0","priceFromReserve","outToken","RouteV3","inputOutputComparatorV3","tradeComparatorV3","TradeV3","nextSources","nextSource","currentSources","sourcesExcludingThisSource"],"mappings":"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"}