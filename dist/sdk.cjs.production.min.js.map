{"version":3,"file":"sdk.cjs.production.min.js","sources":["../src/constants.ts","../src/errors.ts","../src/helperUtils.ts","../src/entities/currency.ts","../src/entities/token.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/percent.ts","../src/entities/fractions/currencyAmount.ts","../src/entities/fractions/tokenAmount.ts","../src/entities/fractions/price.ts","../src/entities/calculators/LogExpMath.ts","../src/entities/calculators/FixedPoint.ts","../src/entities/calculators/WeightedMath.ts","../src/entities/calculators/WeightedPoolLib.ts","../src/entities/calculators/weightedPairCalc.ts","../src/entities/pools/pool.ts","../src/entities/calculators/weightedSwapStorage.ts","../src/entities/calculators/stableSwapStorage.ts","../src/entities/pools/weightedPair/amplifiedWeightedPair.ts","../src/entities/pools/weightedPool/weightedPool.ts","../src/entities/calculators/stableCalc.ts","../src/entities/pools/stable/stablePool.ts","../src/entities/pools/swapData.ts","../src/entities/pools/pairData.ts","../src/entities/bonds/bondCalculator.ts","../src/entities/bonds/fixedPoint.ts","../src/entities/bonds/bondDepository.ts","../src/entities/route.ts","../src/entities/swap.ts","../src/entities/swapRoute.ts","../src/routeProvider.ts","../src/swapRouter.ts"],"sourcesContent":["import { BigNumber } from 'ethers'\n\n// exports for external consumption\nexport type BigintIsh = BigNumber | bigint | string | number\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport const FACTORY_ADDRESS: { [chainId: number]: string } = {\n  56: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n  97: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n  80001: '0xf10Bd0dA1f0e69c3334D7F8116C9082746EBC1B4',\n  43113: '0xFb94c4CeA93f8369Fe18C3078060605eE2B14eC3',\n}\n\nexport const WEIGHTED_FACTORY_ADDRESS: { [chainId: number]: string } = {\n  43113: '0xacd3602152763C3AAFA705D8a90C36661ecD7d46',\n  42261: '0x0459e858F17ef5D927625f34602432f4fac6941e',\n  110001: '0xe092CB3124aF36a0B851839D8EC51CaaD9a3DCD0'\n}\n\n// export const INIT_CODE_HASH = '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5'\n\n\nexport const INIT_CODE_HASH: { [chainId: number]: string } = {\n  56: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',\n  97: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',\n  80001: '0xc2b3644608b464a0df0eb711ce9c6ce7535d1bd4d0154b8389738a3e7fbb1a61',\n  43113: '0x98fcd7ed545dc443aa0c7e57e5f54affba6cf755a7eadfd269143f9bf62024d8',\n}\n\nexport const INIT_CODE_HASH_WEIGHTED: { [chainId: number]: string } = {\n  43113: '0xbeec252b6527ff023d9f20fa336f9f131a002be662ce64ef7f9ed17b5ea8b591',\n  42261: '0x98fcd7ed545dc443aa0c7e57e5f54affba6cf755a7eadfd269143f9bf62024d8',\n  110001: '0x98fcd7ed545dc443aa0c7e57e5f54affba6cf755a7eadfd269143f9bf62024d8'\n}\n\nexport const STABLE_POOL_ADDRESS: { [chainId: number]: string } = {\n  43113: '0x0Be60C571BdA7841D8F6eE68afDBa648EC710fD7',\n  42261: '0x2a90276992ddC21C3585FE50f5B43D0Cf62aDe03',\n  110001: '0x211F00f4071A4af8f0cC289d9853d778047DB8Ba',\n}\n\nexport const STABLE_POOL_LP_ADDRESS: { [chainId: number]: string } = {\n  43113: '0x3372de341a07418765ae12f77aee9029eaa4442a',\n  42261: '0x9364E91ca784ca51f88dE2a76a35Ba2665bdad04',\n  110001: '0x029f9f8e2c27627341824120ee814F31a1551256'\n}\n\nexport const MINIMUM_LIQUIDITY = BigNumber.from(1000)\n\n// exports for internal consumption\nexport const ZERO = BigNumber.from(0)\nexport const ONE = BigNumber.from(1)\nexport const TWO = BigNumber.from(2)\nexport const THREE = BigNumber.from(3)\nexport const FIVE = BigNumber.from(5)\nexport const TEN = BigNumber.from(10)\nexport const TENK = BigNumber.from(10000)\nexport const _100 = BigNumber.from(100)\nexport const FEES_NUMERATOR = BigNumber.from(9975)\nexport const FEES_DENOMINATOR = BigNumber.from(10000)\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: BigNumber.from('0xff'),\n  [SolidityType.uint256]: BigNumber.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\nimport { BigNumber } from 'ethers'\n\nexport function validateSolidityTypeInstance(value: BigNumber, solidityType: SolidityType): void {\n  invariant(value.gte(ZERO), `${value} is not a ${solidityType}.`)\n  invariant(value.lte(SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): BigNumber {\n  return bigintIsh instanceof BigNumber\n    ? bigintIsh\n    : typeof bigintIsh === 'bigint'\n    ? BigNumber.from(bigintIsh.toString())\n    : BigNumber.from(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: BigNumber): BigNumber {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: BigNumber = ZERO\n  let x: BigNumber\n  if (y.gt(THREE)) {\n    z = y\n    x = y.div(TWO).add(ONE)\n    while (x.lt(z)) {\n      z = x\n      x = y.div(x).add( x).div(TWO)\n    }\n  } else if (!y.eq(ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n","/**\n * A currency is any fungible financial instrument on Ethereum, including Ether and all ERC20 tokens.\n *\n * The only instance of the base class `Currency` is Ether.\n */\nexport class Currency {\n  public readonly decimals: number\n  public readonly chainId: number\n  public readonly symbol?: string\n  public readonly name?: string\n\n  /**\n   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.ETHER`.\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  constructor(chainId: number, decimals: number, symbol?: string, name?: string) {\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n    this.chainId = chainId\n  }\n}\n\n\nexport enum ChainId {\n  BSC_MAINNET = 56,\n  BSC_TESTNET = 97,\n  AVAX_MAINNET = 43114,\n  AVAX_TESTNET = 43113,\n  ARBITRUM_MAINNET = 42161,\n  ARBITRUM_TETSNET_RINKEBY = 421611,\n  MATIC_MAINNET = 137,\n  MATIC_TESTNET = 80001,\n  OASIS_TESTNET = 42261,\n  OASIS_MAINNET = 42262,\n  QUARKCHAIN_DEV_S0 = 110001,\n}\n\nexport const NETWORK_CCY: { [chainId: number]: Currency } = {\n  [ChainId.BSC_MAINNET]: new Currency(ChainId.BSC_MAINNET, 18, 'BNB', 'BNB'),\n  [ChainId.BSC_TESTNET]: new Currency(ChainId.BSC_TESTNET, 18, 'BNB', 'BNB'),\n  [ChainId.ARBITRUM_MAINNET]: new Currency(ChainId.ARBITRUM_MAINNET, 18, 'ETH', 'ETH'),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Currency(ChainId.ARBITRUM_TETSNET_RINKEBY, 18, 'ETH', 'ETH'),\n  [ChainId.AVAX_MAINNET]: new Currency(ChainId.AVAX_MAINNET, 18, 'AVAX', 'AVAX'),\n  [ChainId.AVAX_TESTNET]: new Currency(ChainId.AVAX_TESTNET, 18, 'AVAX', 'AVAX'),\n  [ChainId.MATIC_MAINNET]: new Currency(ChainId.MATIC_MAINNET, 18, 'MATIC', 'MATIC'),\n  [ChainId.MATIC_TESTNET]: new Currency(ChainId.MATIC_TESTNET, 18, 'MATIC', 'MATIC'),\n  [ChainId.OASIS_MAINNET]: new Currency(ChainId.OASIS_MAINNET, 18, 'ROSE', 'ROSE'),\n  [ChainId.OASIS_TESTNET]: new Currency(ChainId.OASIS_TESTNET, 18, 'ROSE', 'ROSE'),\n  [ChainId.QUARKCHAIN_DEV_S0]: new Currency(ChainId.QUARKCHAIN_DEV_S0, 18, 'QKC', 'QKC')\n}\n","import invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from '../helperUtils'\nimport { Currency, ChainId } from './currency'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token extends Currency {\n  public readonly address: string\n  public readonly projectLink?: string\n\n  public constructor(\n    chainId: ChainId,\n    address: string,\n    decimals: number,\n    symbol?: string,\n    name?: string,\n    projectLink?: string\n  ) {\n    super(chainId, decimals, symbol, name)\n    this.address = validateAndParseAddress(address)\n    this.projectLink = projectLink\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Token): boolean {\n    // short circuit on reference equality\n    if (this === other) {\n      return true\n    }\n    return this.chainId === other.chainId && this.address === other.address\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n}\n\n/**\n * Compares two currencies for equality\n */\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB)\n  } else if (currencyA instanceof Token) {\n    return false\n  } else if (currencyB instanceof Token) {\n    return false\n  } else {\n    return currencyA === currencyB\n  }\n}\n\nexport const WETH = {\n  [ChainId.BSC_MAINNET]: new Token(\n    ChainId.BSC_MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.BSC_TESTNET]: new Token(\n    ChainId.BSC_TESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_MAINNET]: new Token(\n    ChainId.ARBITRUM_MAINNET,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped ETH',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Token(\n    ChainId.ARBITRUM_TETSNET_RINKEBY,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_MAINNET]: new Token(\n    ChainId.AVAX_MAINNET,\n    '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_TESTNET]: new Token(\n    ChainId.AVAX_TESTNET,\n    '0xd00ae08403B9bbb9124bB305C09058E32C39A48c',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_MAINNET]: new Token(\n    ChainId.MATIC_MAINNET,\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_TESTNET]: new Token(\n    ChainId.MATIC_TESTNET,\n    '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n\n}\n// this has not to be mixed up with the ERC20 token WETH on BSC or MATIC\n// these are the respective wrapped network tokens, e.g. WBNB for Binance\n// or WMATIC for Polygon\nexport const WRAPPED_NETWORK_TOKENS:{[chainId:number]:Token} = {\n  [ChainId.BSC_MAINNET]: new Token(\n    ChainId.BSC_MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.BSC_TESTNET]: new Token(\n    ChainId.BSC_TESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_MAINNET]: new Token(\n    ChainId.ARBITRUM_MAINNET,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped ETH',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Token(\n    ChainId.ARBITRUM_TETSNET_RINKEBY,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_MAINNET]: new Token(\n    ChainId.AVAX_MAINNET,\n    '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_TESTNET]: new Token(\n    ChainId.AVAX_TESTNET,\n    '0xd00ae08403B9bbb9124bB305C09058E32C39A48c',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_MAINNET]: new Token(\n    ChainId.MATIC_MAINNET,\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_TESTNET]: new Token(\n    ChainId.MATIC_TESTNET,\n    '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.OASIS_TESTNET]:\n  new Token( ChainId.OASIS_TESTNET,\n    '0x792296e2a15e6Ceb5f5039DecaE7A1f25b00B0B0',\n    18,\n    'wROSE',\n    'Wrapped ROSE',\n    'https://docs.oasis.dev/'\n  ),\n  [ChainId.OASIS_MAINNET]:\n  new Token( ChainId.OASIS_MAINNET,\n    '0xfb40cd35C0cF322fA3cfB8D67b533Bd9ad7df056',\n    18,\n    'wROSE',\n    'Wrapped ROSE',\n    'https://docs.oasis.dev/'\n  ),\n  [ChainId.QUARKCHAIN_DEV_S0]:\n  new Token( ChainId.OASIS_MAINNET,\n    '0x56fB4da0E246003DEc7dD108e47f5d8e8F4cC493',\n    18,\n    'wQKC',\n    'Wrapped QKC',\n    'https://docs.oasis.dev/'\n  ),\n\n}\n\n\n\nexport const STABLECOINS: { [chainId: number]: Token[] } = {\n  43113: [\n    new Token(ChainId.AVAX_TESTNET, '0xca9ec7085ed564154a9233e1e7d8fef460438eea', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.AVAX_TESTNET, '0xffb3ed4960cac85372e6838fbc9ce47bcf2d073e', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.AVAX_TESTNET, '0xaea51e4fee50a980928b4353e852797b54deacd8', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.AVAX_TESTNET, '0xccf7ed44c5a0f3cb5c9a9b9f765f8d836fb93ba1', 18, 'TUSD', 'True USD'),\n  ],\n  42261 :[\n    new Token(ChainId.OASIS_TESTNET, '0x9aEeeD65aE87e3b28793aefAeED59c3f10ef956b', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.OASIS_TESTNET, '0xfA0D8065755Fb3b6520149e86Ac5A3Dc3ee5Dc92', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.OASIS_TESTNET, '0xf10Bd0dA1f0e69c3334D7F8116C9082746EBC1B4', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.OASIS_TESTNET, '0x4e8848da06E40E866b82f6b52417494936c9509b', 18, 'TUSD', 'True USD'),\n  ],\n  110001 :[\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0xE59c1Ddf4fAAC4Fa7C8c93d9392d4bBa55383268', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0x1a69a6e206c680A8559c59b951527437CBCe6Ed7', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0x51b90a5Bc99B7c76EDf3863E1d61ca6197a6e542', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0xD71C821a373E16D607277DB6C1356c1209C7d866', 18, 'TUSD', 'True USD'),\n  ],\n  0: [// dummy value\n    new Token(-1, '0xCa9eC7085Ed564154a9233e1e7D8fEF460438EEA', 6, 'USDC', 'USD Coin')]\n}\n\n\nexport const STABLES_INDEX_MAP: { [chainId: number]: { [index: number]: Token } } = {\n  43113: {\n    0: STABLECOINS[43113][0],\n    1: STABLECOINS[43113][1],\n    2: STABLECOINS[43113][2],\n    3: STABLECOINS[43113][3]\n  },\n  42261: {\n    0: STABLECOINS[42261][0],\n    1: STABLECOINS[42261][1],\n    2: STABLECOINS[42261][2],\n    3: STABLECOINS[42261][3]\n  },\n  110001: {\n    0: STABLECOINS[110001][0],\n    1: STABLECOINS[110001][1],\n    2: STABLECOINS[110001][2],\n    3: STABLECOINS[110001][3]\n  }\n}\n\nexport const STABLES_LP_TOKEN: { [chainId: number]: { [index: number]: Token } } = {\n  43113: {\n    0: STABLECOINS[43113][0],\n    1: STABLECOINS[43113][1],\n    2: STABLECOINS[43113][2],\n    3: STABLECOINS[43113][3]\n  }\n}","import invariant from 'tiny-invariant'\nimport _Decimal from 'decimal.js-light'\nimport _Big, { RoundingMode } from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh } from '../../constants'\nimport { ONE } from '../../constants'\nimport { parseBigintIsh } from '../../helperUtils'\nimport { BigNumber } from 'ethers'\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp\n}\n\nexport class Fraction {\n  public readonly numerator: BigNumber\n  public readonly denominator: BigNumber\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = ONE) {\n    this.numerator = parseBigintIsh(numerator)\n    this.denominator = parseBigintIsh(denominator)\n  }\n\n  // performs floor division\n  public get quotient(): BigNumber {\n    return this.numerator.div(this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(this.numerator.mod(this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (this.denominator.eq(otherParsed.denominator)) {\n      return new Fraction(this.numerator.add(otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator).add(\n        otherParsed.numerator.mul(this.denominator)\n      ),\n      this.denominator.mul(otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (this.denominator.eq(otherParsed.denominator)) {\n      return new Fraction(this.numerator.sub(otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator).sub(\n       otherParsed.numerator.mul(this.denominator)\n      ),\n      this.denominator.mul(otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return this.numerator.mul(otherParsed.denominator).lt(\n      otherParsed.numerator.mul(this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return this.numerator.mul(otherParsed.denominator).eq(\n      otherParsed.numerator.mul(this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return this.numerator.mul(otherParsed.denominator).gt(otherParsed.numerator.mul(this.denominator))\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n     this.numerator.mul(otherParsed.numerator),\n      this.denominator.mul(otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator),\n      this.denominator.mul(otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n}\n","import { _100 } from '../../constants'\nimport { Fraction, Rounding } from './fraction'\n\nconst _100_PERCENT = new Fraction(_100)\n\nexport class Percent extends Fraction {\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { currencyEquals } from '../token'\nimport { Currency, ChainId, NETWORK_CCY } from '../currency'\nimport invariant from 'tiny-invariant'\nimport _Big from 'big.js'\nimport toFormat from 'toformat'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { BigintIsh, TEN, SolidityType } from '../../constants'\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../helperUtils'\nimport { Fraction, Rounding } from './fraction'\n\nconst Big = toFormat(_Big)\n\nexport class CurrencyAmount extends Fraction {\n  public readonly currency: Currency\n\n  /**\n   * Helper that calls the constructor with the more flexible network currency\n   * dependent on the selected chainId\n   * @param amount ether amount in wei\n   */\n  public static networkCCYAmount(chainId: ChainId, amount: BigintIsh): CurrencyAmount {\n    return new CurrencyAmount(NETWORK_CCY[chainId], amount)\n  }\n\n  // amount _must_ be raw, i.e. in the native representation\n  protected constructor(currency: Currency, amount: BigintIsh) {\n    const parsedAmount = parseBigintIsh(amount)\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\n\n    super(parsedAmount, TEN.pow(currency.decimals))\n    this.currency = currency\n  }\n\n  public get raw(): BigNumber {\n    return this.numerator\n  }\n\n  public add(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, this.raw.add(other.raw))\n  }\n\n  public subtract(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, this.raw.sub(other.raw))\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\n  }\n\n  public toBigNumber(): BigNumber { return BigNumber.from(this.numerator.toString()) }\n}\n","import { CurrencyAmount } from './currencyAmount'\nimport { Token } from '../token'\nimport invariant from 'tiny-invariant'\nimport { BigintIsh } from '../../constants'\n\n\n// minimal interface so the input output comparator may be shared across types\nexport interface InputOutput {\n  readonly inputAmount: CurrencyAmount\n  readonly outputAmount: CurrencyAmount\n}\n\nexport class TokenAmount extends CurrencyAmount {\n  public readonly token: Token\n\n  // amount _must_ be raw, i.e. in the native representation\n  public constructor(token: Token, amount: BigintIsh) {\n    super(token, amount)\n    this.token = token\n  }\n\n  public add(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, this.raw.add(other.raw))\n  }\n\n  public subtract(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, this.raw.sub(other.raw))\n  }\n}\n","import { Token } from '../token'\nimport { TokenAmount } from './tokenAmount'\nimport { currencyEquals } from '../token'\nimport invariant from 'tiny-invariant'\n\nimport { BigintIsh, TEN } from '../../constants'\nimport { Currency } from '../currency'\n\nimport { Fraction, Rounding } from './fraction'\nimport { CurrencyAmount } from './currencyAmount'\n\nimport { Pool } from '../pools/pool'\nimport { Route } from '../route'\n\nexport class Price extends Fraction {\n  public readonly baseCurrency: Currency // input i.e. denominator\n  public readonly quoteCurrency: Currency // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n\n  // upgraded version to include StablePairWrappers in a Route\n  // as well as weighted pairs\n  public static fromRoute(route: Route, poolDict: { [id: string]: Pool }): Price {\n    const prices: Price[] = []\n    // console.log(\"=========PATH\", route.path.map(x=>x.symbol))\n    // console.log(\"=========PATH PAIRs\", route.pairData.map(x=>[x.token0.symbol, x.token1.symbol]))\n    for (const [i, pool] of route.pairData.entries()) {\n      const price = pool.poolPrice(route.path[i], route.path[i + 1], poolDict)\n      prices.push(price)\n    }\n    // console.log(\"=========PRICE\", prices.map(p=>[p.baseCurrency.symbol, p.quoteCurrency.symbol]))\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n  }\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  public constructor(baseCurrency: Currency, quoteCurrency: Currency, denominator: BigintIsh, numerator: BigintIsh) {\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      TEN.pow(baseCurrency.decimals),\n      TEN.pow(quoteCurrency.decimals)\n    )\n  }\n\n  public get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n\n  public get adjusted(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public invert(): Price {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  public multiply(other: Price): Price {\n    invariant(currencyEquals(this.quoteCurrency, other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  // performs floor division on overflow\n  public quote(chainId: number, currencyAmount: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(currencyAmount.currency, this.baseCurrency), 'TOKEN')\n    if (this.quoteCurrency instanceof Token) {\n      return new TokenAmount(this.quoteCurrency, super.multiply(currencyAmount.raw).quotient)\n    }\n    return CurrencyAmount.networkCCYAmount(chainId, super.multiply(currencyAmount.raw).quotient)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the “Software”), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport { BigNumber } from '@ethersproject/bignumber'\n// import { ethers } from 'ethers'\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\n\n// All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n// two numbers, and multiply by ONE when dividing them.\nexport const ZERO = BigNumber.from(0)\n// All arguments and return values are 18 decimal fixed point numbers.\nexport const ONE_18 = BigNumber.from('1000000000000000000');\n\n// Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n// case of ln36, 36 decimals.\nconst ONE_20 = BigNumber.from('100000000000000000000');\nconst ONE_36 = BigNumber.from('1000000000000000000000000000000000000');\n\n// The domain of natural exponentiation is bound by the word size and number of decimals used.\n//\n// Because internally the result will be stored using 20 decimals, the largest possible result is\n// (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n// The smallest possible result is 10^(-18), which makes largest negative argument\n// ln(10^(-18)) = -41.446531673892822312.\n// We use 130.0 and -41.0 to have some safety margin.\n// const MAX_NATURAL_EXPONENT = BigNumber.from('130000000000000000000');\n// const MIN_NATURAL_EXPONENT = BigNumber.from(-'41000000000000000000');\n\n// Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n// 256 bit integer.\nconst LN_36_LOWER_BOUND = ONE_18.sub(BigNumber.from('100000000000000000'));\nconst LN_36_UPPER_BOUND = ONE_18.add(BigNumber.from('100000000000000000'));\n\n// const MILD_EXPONENT_BOUND = ethers.constants.MaxUint256.div(ONE_20);\n\n// 18 decimal constants\nconst x0 = BigNumber.from('128000000000000000000'); // 2ˆ7\nconst a0 = BigNumber.from('38877084059945950922200000000000000000000000000000000000'); // eˆ(x0) (no decimals)\nconst x1 = BigNumber.from('64000000000000000000'); // 2ˆ6\nconst a1 = BigNumber.from('6235149080811616882910000000'); // eˆ(x1) (no decimals)\n\n// 20 decimal constants\nconst x2 = BigNumber.from('3200000000000000000000'); // 2ˆ5\nconst a2 = BigNumber.from('7896296018268069516100000000000000'); // eˆ(x2)\nconst x3 = BigNumber.from('1600000000000000000000'); // 2ˆ4\nconst a3 = BigNumber.from('888611052050787263676000000'); // eˆ(x3)\nconst x4 = BigNumber.from('800000000000000000000'); // 2ˆ3\nconst a4 = BigNumber.from('298095798704172827474000'); // eˆ(x4)\nconst x5 = BigNumber.from('400000000000000000000'); // 2ˆ2\nconst a5 = BigNumber.from('5459815003314423907810'); // eˆ(x5)\nconst x6 = BigNumber.from('200000000000000000000'); // 2ˆ1\nconst a6 = BigNumber.from('738905609893065022723'); // eˆ(x6)\nconst x7 = BigNumber.from('100000000000000000000'); // 2ˆ0\nconst a7 = BigNumber.from('271828182845904523536'); // eˆ(x7)\nconst x8 = BigNumber.from('50000000000000000000'); // 2ˆ-1\nconst a8 = BigNumber.from('164872127070012814685'); // eˆ(x8)\nconst x9 = BigNumber.from('25000000000000000000'); // 2ˆ-2\nconst a9 = BigNumber.from('128402541668774148407'); // eˆ(x9)\nconst x10 = BigNumber.from('12500000000000000000'); // 2ˆ-3\nconst a10 = BigNumber.from('113314845306682631683'); // eˆ(x10)\nconst x11 = BigNumber.from('6250000000000000000'); // 2ˆ-4\nconst a11 = BigNumber.from('106449445891785942956'); // eˆ(x11)\n\n/**\n * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n *\n * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n */\nexport function pow(x: BigNumber, y: BigNumber): BigNumber {\n    if (y.eq(0)) {\n        // We solve the 0^0 indetermination by making it equal one.\n        return ONE_18;\n    }\n\n    if (x.eq(0)) {\n        return ZERO;\n    }\n    let x_int256 = x;\n    let y_int256 = y\n    let logx_times_y\n    if (LN_36_LOWER_BOUND.lt(x_int256) && x_int256.lt(LN_36_UPPER_BOUND)) {\n        let ln_36_x = _ln_36(x_int256);\n\n        // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n        // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n        // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n        // (downscaled) last 18 decimals.\n        logx_times_y = (ln_36_x.div(ONE_18).mul(y_int256)).add(ln_36_x.mod(ONE_18).mul(y_int256).div(ONE_18))\n    } else {\n        logx_times_y = _ln(x_int256).mul(y_int256);\n    }\n    logx_times_y = logx_times_y.div(ONE_18);\n\n\n    return exp(logx_times_y); // that +1 differs from the original variant\n}\n\n/**\n * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n *\n * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n */\nexport function exp(x: BigNumber): BigNumber {\n\n    if (x.lt(ZERO)) {\n        // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n        // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n        // Fixed point division requires multiplying by ONE_18.\n        return (ONE_18.mul(ONE_18)).div(exp(x.mul(-1)));\n    }\n    // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n    // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n    // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n    // decomposition.\n    // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n    // decomposition, which will be lower than the smallest x_n.\n    // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n    // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n    // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n    // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n    // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n    // decomposition.\n\n    // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n    // it and compute the accumulated product.\n\n    let firstAN;\n    if (x.gte(x0)) {\n        x = x.sub(x0);\n        firstAN = a0;\n    } else if (x.gte(x1)) {\n        x = x.sub(x1);\n        firstAN = a1;\n    } else {\n        firstAN = BigNumber.from(1); // One with no decimal places\n    }\n\n    // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n    // smaller terms.\n    x = x.mul(100);\n\n    // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n    // one. Recall that fixed point multiplication requires dividing by ONE_20.\n    let product = ONE_20;\n\n    if (x.gte(x2)) {\n        x = x.sub(x2);\n        product = product.mul(a2).div(ONE_20);\n    }\n    if (x.gte(x3)) {\n        x = x.sub(x3);\n        product = product.mul(a3).div(ONE_20);\n    }\n    if (x.gte(x4)) {\n        x = x.sub(x4);\n        product = product.mul(a4).div(ONE_20);\n    }\n    if (x.gte(x5)) {\n        x = x.sub(x5);\n        product = product.mul(a5).div(ONE_20);\n    }\n    if (x.gte(x6)) {\n        x = x.sub(x6);\n        product = product.mul(a6).div(ONE_20);\n    }\n    if (x.gte(x7)) {\n        x = x.sub(x7);\n        product = product.mul(a7).div(ONE_20);\n    }\n    if (x.gte(x8)) {\n        x = x.sub(x8);\n        product = product.mul(a8).div(ONE_20);\n    }\n    if (x.gte(x9)) {\n        x = x.sub(x9);\n        product = product.mul(a9).div(ONE_20);\n    }\n\n    // x10 and x11 are unnecessary here since we have high enough precision already.\n\n    // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n    // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n    let seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n    let term; // Each term in the sum, where the nth term is (x^n / n!).\n\n    // The first term is simply x.\n    term = x;\n    seriesSum = seriesSum.add(term);\n\n    // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n    // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n    term = term.mul(x).div(ONE_20).div(2);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(3);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(4);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(5);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(6);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(7);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(8);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(9);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(10);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(11);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(12);\n    seriesSum = seriesSum.add(term);\n\n    // 12 Taylor terms are sufficient for 18 decimal precision.\n\n    // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n    // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n    // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n    // and then drop two digits to return an 18 decimal value.\n\n    return ((product.mul(seriesSum)).div(ONE_20).mul(firstAN)).div(100);\n}\n\n/**\n * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n */\nexport function log(arg: BigNumber, base: BigNumber): BigNumber {\n    // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n    // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n    // upscaling.\n\n    let logBase;\n    if (LN_36_LOWER_BOUND.lt(base) && base.lt(LN_36_UPPER_BOUND)) {\n        logBase = _ln_36(base);\n    } else {\n        logBase = _ln(base).mul(ONE_18);\n    }\n\n    let logArg;\n    if (LN_36_LOWER_BOUND.lt(arg) && arg.lt(LN_36_UPPER_BOUND)) {\n        logArg = _ln_36(arg);\n    } else {\n        logArg = _ln(arg).mul(ONE_18);\n    }\n\n    // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n    return logArg.mul(ONE_18).div(logBase);\n}\n\n/**\n * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n */\nexport function ln(a: BigNumber): BigNumber {\n    // The real natural logarithm is not defined for negative numbers or zero.\n\n    if (LN_36_LOWER_BOUND.lt(a) && a.lt(LN_36_UPPER_BOUND)) {\n        return _ln_36(a).div(ONE_18);\n    } else {\n        return _ln(a);\n    }\n}\n\n/**\n * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n */\nexport function _ln(a: BigNumber): BigNumber {\n    if (a.lt(ONE_18)) {\n        // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n        // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n        // Fixed point division requires multiplying by ONE_18.\n        return (_ln((ONE_18.mul(ONE_18)).div(a))).mul(-1);\n    }\n\n    // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n    // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n    // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n    // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n    // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n    // decomposition, which will be lower than the smallest a_n.\n    // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n    // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n    // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n    // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n    // ONE_18 to convert them to fixed point.\n    // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n    // by it and compute the accumulated sum.\n\n    let sum = ZERO;\n    if (a.gte(a0.mul(ONE_18))) {\n        a = a.div(a0); // Integer, not fixed point division\n        sum = sum.add(x0);\n    }\n\n    if (a.gte(a1.mul(ONE_18))) {\n        a = a.div(a1); // Integer, not fixed point division\n        sum = sum.add(x1);\n    }\n\n    // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n    sum = sum.mul(100);\n    a = a.mul(100);\n\n    // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n    if (a.gte(a2)) {\n        a = a.mul(ONE_20).div(a2);\n        sum = sum.add(x2);\n    }\n\n    if (a.gte(a3)) {\n        a = a.mul(ONE_20).div(a3);\n        sum = sum.add(x3);\n    }\n\n    if (a.gte(a4)) {\n        a = a.mul(ONE_20).div(a4);\n        sum = sum.add(x4);\n    }\n\n    if (a.gte(a5)) {\n        a = a.mul(ONE_20).div(a5);\n        sum = sum.add(x5);\n    }\n\n    if (a.gte(a6)) {\n        a = a.mul(ONE_20).div(a6);\n        sum = sum.add(x6);\n    }\n\n    if (a.gte(a7)) {\n        a = a.mul(ONE_20).div(a7);\n        sum = sum.add(x7);\n    }\n\n    if (a.gte(a8)) {\n        a = a.mul(ONE_20).div(a8);\n        sum = sum.add(x8);\n    }\n\n    if (a.gte(a9)) {\n        a = a.mul(ONE_20).div(a9);\n        sum = sum.add(x9);\n    }\n\n    if (a.gte(a10)) {\n        a = a.mul(ONE_20).div(a10);\n        sum = sum.add(x10);\n    }\n\n    if (a.gte(a11)) {\n        a = a.mul(ONE_20).div(a11);\n        sum = sum.add(x11);\n    }\n\n    // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n    // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n    // Let z = (a - 1) / (a + 1).\n    // ln(a) =2.mul((z + z^.div( 3) + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n    // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n    // division by ONE_20.\n    let z = ((a.sub(ONE_20)).mul(ONE_20)).div(a.add(ONE_20));\n    let z_squared = (z.mul(z)).div(ONE_20);\n\n    // num is the numerator of the series: the z^(2 * n + 1) term\n    let num = z;\n\n    // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n    let seriesSum = num;\n\n    // In each step, the numerator is multiplied by z^2\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(3));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(5));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(7));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(9));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(11));\n\n    // 6 Taylor terms are sufficient for 36 decimal precision.\n\n    // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n    seriesSum = seriesSum.mul(2);\n\n    // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n    // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n    // value.\n\n    return sum.add(seriesSum).div(100);\n}\n\n/**\n * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n * for x close to one.\n *\n * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n */\nexport function _ln_36(x: BigNumber): BigNumber {\n    // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n    // worthwhile.\n\n    // First, we transform x to a 36 digit fixed point value.\n    x = x.mul(ONE_18);\n\n    // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n    // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n    // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n    // division by ONE_36.\n    let z = x.sub(ONE_36).mul(ONE_36).div(x.add(ONE_36));\n    let z_squared = z.mul(z).div(ONE_36);\n\n    // num is the numerator of the series: the z^(2 * n + 1) term\n    let num = z;\n\n    // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n    let seriesSum = num;\n\n    // In each step, the numerator is multiplied by z^2\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(3));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(5));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(7));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(9));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(11));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(13));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(15));\n\n    // 8 Taylor terms are sufficient for 36 decimal precision.\n\n    // All that remains is multiplying by 2 (non fixed point).\n    return seriesSum.mul(2);\n}\n\n","\n// import invariant from 'tiny-invariant'\nimport { BigNumber } from '@ethersproject/bignumber'\n\n\nimport { pow, ZERO, ONE_18 } from \"./LogExpMath\";\n\nexport const ONE = ONE_18\n/* solhint-disable private-vars-leading-underscore */\n\n// const ONE = BigNumber.from(1e18); // 18 decimal places\nconst MAX_POW_RELATIVE_ERROR = BigNumber.from(10000); // 10^(-14)\n\n// Minimum base for the power function when the exponent is 'free' (larger than ONE).\nexport const MIN_POW_BASE_FREE_EXPONENT = BigNumber.from('700000000000000000');\n\n\nexport function mulDown(a: BigNumber, b: BigNumber): BigNumber {\n    const product = a.mul(b);\n\n    return product.div(ONE);\n}\n\nexport function mulUp(a: BigNumber, b: BigNumber): BigNumber {\n    const product = a.mul(b);\n\n    if (product.eq(0)) {\n        return BigNumber.from(0);\n    } else {\n        // The traditional divUp formula is:\n        // divUp(x, y) := (x + y - 1) / y\n        // To avoid intermediate overflow in the addition, we distribute the division and get:\n        // divUp(x, y) := (x - 1) / y + 1\n        // Note that this requires x != 0, which we already tested for.\n\n        return (product.sub(1).div(ONE)).add(1);\n    }\n}\n\nexport function divDown(a: BigNumber, b: BigNumber): BigNumber {\n\n    if (a.eq(ZERO)) {\n        return ZERO;\n    } else {\n        let aInflated = a.mul(ONE);\n        return aInflated.div(b);\n    }\n}\n\nexport function divUp(a: BigNumber, b: BigNumber): BigNumber {\n\n    if (a.eq(ZERO)) {\n        return ZERO;\n    } else {\n        let aInflated = a.mul(ONE);\n\n        // The traditional divUp formula is:\n        // divUp(x, y) := (x + y - 1) / y\n        // To avoid intermediate overflow in the addition, we distribute the division and get:\n        // divUp(x, y) := (x - 1) / y + 1\n        // Note that this requires x != 0, which we already tested for.\n\n        return aInflated.sub(1).div(b).add(1);\n    }\n}\n\n/**\n * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n * the true value (that is, the error function expected - actual is always positive).\n */\nexport function powDown(x: BigNumber, y: BigNumber): BigNumber {\n    let raw = pow(x, y);\n    let maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR).add(1);\n\n    if (raw.lt(maxError)) {\n        return ZERO;\n    } else {\n        return raw.sub(maxError);\n    }\n}\n\n/**\n * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n * the true value (that is, the error function expected - actual is always negative).\n */\nexport function powUp(x: BigNumber, y: BigNumber): BigNumber {\n    const raw = pow(x, y);\n    const maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR).add(1);\n\n    return raw.add(maxError);\n}\n\n/**\n * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\n *\n * Useful when computing the complement for values with some level of relative error, as it strips this error and\n * prevents intermediate negative values.\n */\nexport function complement(x: BigNumber): BigNumber {\n    return x.lt(ONE) ? ONE.sub(x) : ZERO;\n}\n\n\n/**\n * @dev Returns the largest of two numbers of 256 bits.\n */\nexport function max(a: BigNumber, b: BigNumber): BigNumber {\n    return a.gte(b) ? a : b;\n}\n\n/**\n * @dev Returns the smallest of two numbers of 256 bits.\n */\nexport function min(a: BigNumber, b: BigNumber): BigNumber {\n    return a.lt(b) ? a : b;\n}\n\n","\nimport { BigNumber } from '@ethersproject/bignumber'\nimport invariant from 'tiny-invariant'\nimport { mulDown, powUp, powDown, divUp, divDown, complement, ONE, mulUp, max, MIN_POW_BASE_FREE_EXPONENT } from './FixedPoint'\nimport { ZERO } from './LogExpMath';\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\n// should be fixed.\n// solhint-disable private-vars-leading-underscore\n\n\n\n// A minimum normalized weight imposes a maximum weight ratio. We need this due to limitations in the\n// implementation of the power function, as these ratios are often exponents.\n// const _MIN_WEIGHT = BigNumber.from(0.01e18);\n// Having a minimum normalized weight imposes a limit on the maximum number of tokens;\n// i.e., the largest possible pool is one where all tokens have exactly the minimum weight.\n// const _MAX_WEIGHTED_TOKENS = BigNumber.from(100);\n\n// Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\n// ratio).\n\n// Swap limits: amounts swapped may not be larger than this percentage of total balance.\nconst _MAX_IN_RATIO = BigNumber.from('300000000000000000'); //0.3e18\nconst _MAX_OUT_RATIO = BigNumber.from('300000000000000000'); //0.3e18\n\n// Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\nconst _MAX_INVARIANT_RATIO = BigNumber.from('3000000000000000000'); //3e18\n// Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\nconst _MIN_INVARIANT_RATIO = BigNumber.from('700000000000000000'); //0.7e18\n\n// About swap fees on joins and exits:\n// Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\n// equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\n// swap fees, it follows that (some) joins and exits should as well.\n// On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\n// is the one to which swap fees are applied.\n\n// Invariant is used to collect protocol swap fees by comparing its value between two times.\n// So we can round always to the same direction. It is also used to initiate the BPT amount\n// and, because there is a minimum BPT, we round down the invariant.\nexport function _calculateInvariant(normalizedWeights: BigNumber[], balances: BigNumber[]): BigNumber {\n    /**********************************************************************************************\n    // invariant               _____                                                             //\n    // wi = weight index i      | |      wi                                                      //\n    // bi = balance index i     | |  bi ^   = i                                                  //\n    // i = invariant                                                                             //\n    **********************************************************************************************/\n\n    let _invariant = ONE;\n    for (let i = 0; i < normalizedWeights.length; i++) {\n        _invariant = mulDown(_invariant, powUp(balances[i], normalizedWeights[i]));\n    }\n\n    invariant(_invariant.gt(0), \"ZERO_INVARIANT\");\n\n    return _invariant\n}\n\n\n\n// Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\n// current balances and weights.\nexport function _calcOutGivenIn(\n    balanceIn: BigNumber,\n    weightIn: BigNumber,\n    balanceOut: BigNumber,\n    weightOut: BigNumber,\n    amountIn: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n    // outGivenIn                                                                                //\n    // aO = amountOut                                                                            //\n    // bO = balanceOut                                                                           //\n    // bI = balanceIn              /      /            bI             \\    (wI / wO) \\           //\n    // aI = amountIn    aO = bO * |  1 - | --------------------------  | ^            |          //\n    // wI = weightIn               \\      \\       ( bI + aI )         /              /           //\n    // wO = weightOut                                                                            //\n    **********************************************************************************************/\n\n    // Amount out, so we round down overall.\n\n    // The multiplication rounds down, and the subtrahend (power) rounds up (so the base rounds up too).\n    // Because bI / (bI + aI) <= 1, the exponent rounds down.\n\n    // Cannot exceed maximum in ratio\n    invariant(amountIn.lte(mulDown(balanceIn, _MAX_IN_RATIO)), \"MAX_IN_RATIO\");\n\n    const denominator = balanceIn.add(amountIn);\n    const base = divUp(balanceIn, denominator);\n    const exponent = divDown(weightIn, weightOut);\n    const power = powUp(base, exponent);\n\n    return mulDown(balanceOut, complement(power));\n}\n\n// Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\n// current balances and weights.\nexport function _calcInGivenOut(\n    balanceIn: BigNumber,\n    weightIn: BigNumber,\n    balanceOut: BigNumber,\n    weightOut: BigNumber,\n    amountOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n    // inGivenOut                                                                                //\n    // aO = amountOut                                                                            //\n    // bO = balanceOut                                                                           //\n    // bI = balanceIn              /  /            bO             \\    (wO / wI)      \\          //\n    // aI = amountIn    aI = bI * |  | --------------------------  | ^            - 1  |         //\n    // wI = weightIn               \\  \\       ( bO - aO )         /                   /          //\n    // wO = weightOut                                                                            //\n    **********************************************************************************************/\n\n    // Amount in, so we round up overall.\n\n    // The multiplication rounds up, and the power rounds up (so the base rounds up too).\n    // Because b0 / (b0 - a0) >= 1, the exponent rounds up.\n\n    // Cannot exceed maximum out ratio\n    invariant(amountOut.lte(mulDown(balanceOut, _MAX_OUT_RATIO)), \"MAX_OUT_RATIO\");\n\n    const base = divUp(balanceOut, balanceOut.sub(amountOut));\n    const exponent = divUp(weightOut, weightIn);\n    const power = powUp(base, exponent);\n\n    // Because the base is larger than one (and the power rounds up), the power should always be larger than one, so\n    // the following subtraction should never revert.\n    const ratio = power.sub(ONE);\n\n    return mulUp(balanceIn, ratio);\n}\n\nexport function _calcLpOutGivenExactTokensIn(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsIn: BigNumber[],\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { lpOut: BigNumber, swapFees: BigNumber[] } {\n    // BPT out, so we round down overall.\n\n    let balanceRatiosWithFee = [];\n\n    let invariantRatioWithFees = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        balanceRatiosWithFee.push(divDown(balances[i].add(amountsIn[i]), balances[i]));\n        invariantRatioWithFees = invariantRatioWithFees.add(mulDown(balanceRatiosWithFee[i], normalizedWeights[i]));\n    }\n\n    const { invariantRatio, swapFees } = _computeJoinExactTokensInInvariantRatio(\n        balances,\n        normalizedWeights,\n        amountsIn,\n        balanceRatiosWithFee,\n        invariantRatioWithFees,\n        swapFeePercentage\n    );\n\n    const lpOut = invariantRatio.gt(ONE) ? mulDown(lpTotalSupply, invariantRatio.sub(ONE)) : ZERO;\n    return { lpOut, swapFees };\n}\n\n/**\n * @dev Intermediate function to avoid stack-too-deep \"\n */\nexport function _computeJoinExactTokensInInvariantRatio(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsIn: BigNumber[],\n    balanceRatiosWithFee: BigNumber[],\n    invariantRatioWithFees: BigNumber,\n    swapFeePercentage: BigNumber\n): { invariantRatio: BigNumber, swapFees: BigNumber[] } {\n    // Swap fees are charged on all tokens that are being added in a larger proportion than the overall invariant\n    // increase.\n    let swapFees = [];\n    let invariantRatio = ONE;\n\n    for (let i = 0; i < balances.length; i++) {\n        let amountInWithoutFee;\n\n        if (balanceRatiosWithFee[i].gt(invariantRatioWithFees)) {\n            const nonTaxableAmount = mulDown(balances[i], invariantRatioWithFees.sub(ONE));\n            const taxableAmount = amountsIn[i].sub(nonTaxableAmount);\n            const swapFee = mulUp(taxableAmount, swapFeePercentage);\n\n            amountInWithoutFee = nonTaxableAmount.add(taxableAmount.sub(swapFee));\n            swapFees[i] = swapFee;\n        } else {\n            amountInWithoutFee = amountsIn[i];\n        }\n\n        const balanceRatio = divDown(balances[i].add(amountInWithoutFee), balances[i]);\n\n        invariantRatio = mulDown(invariantRatio, powDown(balanceRatio, normalizedWeights[i]));\n    }\n\n    return { invariantRatio, swapFees }\n}\n\nexport function _calcTokenInGivenExactLpOut(\n    balance: BigNumber,\n    normalizedWeight: BigNumber,\n    lpAmountOut: BigNumber,\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { amountIn: BigNumber, swapFee: BigNumber } {\n    /******************************************************************************************\n    // tokenInForExactLpOut                                                                 //\n    // a = amountIn                                                                          //\n    // b = balance                      /  /    totalBPT + LpOut      \\    (1 / w)       \\  //\n    // LpOut = lpAmountOut   a = b * |  | --------------------------  | ^          - 1  |  //\n    // lp = totalBPT                   \\  \\       totalBPT            /                  /  //\n    // w = weight                                                                            //\n    ******************************************************************************************/\n\n    // Token in, so we round up overall.\n\n    // Calculate the factor by which the invariant will increase after minting BPTAmountOut\n    const invariantRatio = divUp(lpTotalSupply.add(lpAmountOut), lpTotalSupply);\n    invariant(invariantRatio.lte(_MAX_INVARIANT_RATIO), \"MAX_OUT_LP\");\n\n    // Calculate by how much the token balance has to increase to match the invariantRatio\n    const balanceRatio = powUp(invariantRatio, divUp(ONE, normalizedWeight));\n\n    const amountInWithoutFee = mulUp(balance, balanceRatio.sub(ONE));\n\n    // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\n    // accordingly.\n    const taxablePercentage = complement(normalizedWeight);\n    const taxableAmount = mulUp(amountInWithoutFee, taxablePercentage);\n    const nonTaxableAmount = amountInWithoutFee.sub(taxableAmount);\n\n    const taxableAmountPlusFees = divUp(taxableAmount, ONE.sub(swapFeePercentage));\n\n    return {\n        swapFee: taxableAmountPlusFees.sub(taxableAmount),\n        amountIn: nonTaxableAmount.add(taxableAmountPlusFees)\n    }\n}\n\nexport function _calcAllTokensInGivenExactLpOut(\n    balances: BigNumber[],\n    lpAmountOut: BigNumber,\n    totalBPT: BigNumber\n): BigNumber[] {\n    /************************************************************************************\n    // tokensInForExactLpOut                                                          //\n    // (per token)                                                                     //\n    // aI = amountIn                   /   LpOut   \\                                  //\n    // b = balance           aI = b * | ------------ |                                 //\n    // LpOut = lpAmountOut           \\  totalBPT  /                                  //\n    // lp = totalBPT                                                                  //\n    ************************************************************************************/\n\n    // Tokens in, so we round up overall.\n    const lpRatio = divUp(lpAmountOut, totalBPT);\n\n    let amountsIn = [];\n    for (let i = 0; i < balances.length; i++) {\n        amountsIn.push(mulUp(balances[i], lpRatio));\n    }\n\n    return amountsIn;\n}\n\nexport function _calcLpInGivenExactTokensOut(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsOut: BigNumber[],\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { lpIn: BigNumber, swapFees: BigNumber[] } {\n    // BPT in, so we round up overall.\n\n    let balanceRatiosWithoutFee = Array(balances.length);\n    let invariantRatioWithoutFees = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        balanceRatiosWithoutFee[i] = divUp(balances[i].sub(amountsOut[i]), balances[i]);\n        invariantRatioWithoutFees = invariantRatioWithoutFees.add(mulUp(balanceRatiosWithoutFee[i], normalizedWeights[i]));\n    }\n\n    const { invariantRatio, swapFees } = _computeExitExactTokensOutInvariantRatio(\n        balances,\n        normalizedWeights,\n        amountsOut,\n        balanceRatiosWithoutFee,\n        invariantRatioWithoutFees,\n        swapFeePercentage\n    );\n\n    const lpIn = mulUp(lpTotalSupply, complement(invariantRatio));\n    return { lpIn, swapFees };\n}\n\n/**\n * @dev Intermediate function to avoid stack-too-deep \"\n */\nexport function _computeExitExactTokensOutInvariantRatio(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsOut: BigNumber[],\n    balanceRatiosWithoutFee: BigNumber[],\n    invariantRatioWithoutFees: BigNumber,\n    swapFeePercentage: BigNumber\n): { invariantRatio: BigNumber, swapFees: BigNumber[] } {\n    let swapFees = Array(balances.length);\n    let invariantRatio = ONE;\n\n    for (let i = 0; i < balances.length; i++) {\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n        // 'token out'. This results in slightly larger price impact.\n\n        let amountOutWithFee;\n        if (invariantRatioWithoutFees.gt(balanceRatiosWithoutFee[i])) {\n            const nonTaxableAmount = mulDown(balances[i], complement(invariantRatioWithoutFees));\n            const taxableAmount = amountsOut[i].sub(nonTaxableAmount);\n            const taxableAmountPlusFees = divUp(taxableAmount, ONE.sub(swapFeePercentage));\n\n            swapFees[i] = taxableAmountPlusFees.sub(taxableAmount);\n            amountOutWithFee = nonTaxableAmount.add(taxableAmountPlusFees);\n        } else {\n            amountOutWithFee = amountsOut[i];\n        }\n\n        const balanceRatio = divDown(balances[i].sub(amountOutWithFee), balances[i]);\n\n        invariantRatio = mulDown(invariantRatio, powDown(balanceRatio, normalizedWeights[i]));\n    }\n\n    return { invariantRatio, swapFees }\n}\n\nexport function _calcTokenOutGivenExactLpIn(\n    balance: BigNumber,\n    normalizedWeight: BigNumber,\n    lpAmountIn: BigNumber,\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { amountOut: BigNumber, swapFee: BigNumber } {\n    /*****************************************************************************************\n    // exactBPTInForTokenOut                                                                //\n    // a = amountOut                                                                        //\n    // b = balance                     /      /    totalBPT - lpIn       \\    (1 / w)  \\   //\n    // lpIn = lpAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\n    // lp = totalBPT                  \\      \\       totalBPT            /             /   //\n    // w = weight                                                                           //\n    *****************************************************************************************/\n\n    // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\n    // rounds up). Because (totalBPT - lpIn) / totalBPT <= 1, the exponent rounds down.\n\n    // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\n    const invariantRatio = divUp(lpTotalSupply.sub(lpAmountIn), lpTotalSupply);\n    invariant(invariantRatio >= _MIN_INVARIANT_RATIO, \"MIN_LP_IN\");\n\n    // Calculate by how much the token balance has to decrease to match invariantRatio\n    const balanceRatio = powUp(invariantRatio, divDown(ONE, normalizedWeight));\n\n    // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\n    const amountOutWithoutFee = mulDown(balance, complement(balanceRatio));\n\n    // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n    // in swap fees.\n    const taxablePercentage = complement(normalizedWeight);\n\n    // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n    // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n    const taxableAmount = mulUp(amountOutWithoutFee, taxablePercentage);\n    const nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n    const swapFee = mulUp(taxableAmount, swapFeePercentage)\n    return {\n        swapFee,\n        amountOut: nonTaxableAmount.add(taxableAmount.sub(swapFee))\n    }\n}\n\nexport function _calcTokensOutGivenExactLpIn(\n    balances: BigNumber[],\n    lpAmountIn: BigNumber,\n    totalBPT: BigNumber\n): BigNumber[] {\n    /**********************************************************************************************\n    // exactBPTInForTokensOut                                                                    //\n    // (per token)                                                                               //\n    // aO = amountOut                  /        lpIn         \\                                  //\n    // b = balance           a0 = b * | ---------------------  |                                 //\n    // lpIn = lpAmountIn             \\       totalBPT       /                                  //\n    // lp = totalBPT                                                                            //\n    **********************************************************************************************/\n\n    // Since we're computing an amount out, we round down overall. This means rounding down on both the\n    // multiplication and division.\n\n    const lpRatio = divDown(lpAmountIn, totalBPT);\n\n    let amountsOut = [];\n    for (let i = 0; i < balances.length; i++) {\n        amountsOut.push(mulDown(balances[i], lpRatio));\n    }\n\n    return amountsOut;\n}\n\nexport function _calcDueTokenProtocolSwapFeeAmount(\n    balance: BigNumber,\n    normalizedWeight: BigNumber,\n    previousInvariant: BigNumber,\n    currentInvariant: BigNumber,\n    protocolSwapFeePercentage: BigNumber\n): BigNumber {\n    /*********************************************************************************\n    /*  protocolSwapFeePercentage * balanceToken * ( 1 - (previousInvariant / currentInvariant) ^ (1 / weightToken))\n    *********************************************************************************/\n\n    if (currentInvariant.lte(previousInvariant)) {\n        // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\n        // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\n        return ZERO;\n    }\n\n    // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol\n    // fees to the Vault.\n\n    // Fee percentage and balance multiplications round down, while the subtrahend (power) rounds up (as does the\n    // base). Because previousInvariant / currentInvariant <= 1, the exponent rounds down.\n\n    let base = divUp(previousInvariant, currentInvariant);\n    const exponent = divDown(ONE, normalizedWeight);\n\n    // Because the exponent is larger than one, the base of the power function has a lower bound. We cap to this\n    // value to avoid numeric issues, which means in the extreme case (where the invariant growth is larger than\n    // 1 / min exponent) the Pool will pay less in protocol fees than it should.\n    base = max(base, MIN_POW_BASE_FREE_EXPONENT);\n\n    const power = powUp(base, exponent);\n\n    const tokenAccruedFees = mulDown(balance, complement(power));\n    return mulDown(tokenAccruedFees, protocolSwapFeePercentage);\n}\n\n","// SPDX-License-Identifier: MIT\n\nimport { WeightedSwapStorage } from \"./weightedSwapStorage\";\n\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { _calcAllTokensInGivenExactLpOut, _calcInGivenOut, _calcLpInGivenExactTokensOut, _calcLpOutGivenExactTokensIn, _calcOutGivenIn, _calcTokenOutGivenExactLpIn } from \"./WeightedMath\";\nimport { ONE_18, ZERO } from \"./LogExpMath\";\n\nconst FEE_DENOMINATOR = ONE_18\n\nexport function calculateRemoveLiquidityOneTokenExactIn(\n    self: WeightedSwapStorage,\n    outIndex: number,\n    lpAmount: BigNumber,\n    lpSupply:BigNumber,\n    tokenBalances: BigNumber[]\n): { amountOut: BigNumber, swapFee: BigNumber } {\n    return _calcTokenOutGivenExactLpIn(\n        tokenBalances[outIndex].mul(self.tokenMultipliers[outIndex]),\n        self.normalizedWeights[outIndex],\n        lpAmount,\n        lpSupply,\n        self.fee\n    );\n}\n\nexport function calculateRemoveLiquidityExactIn(\n    self: WeightedSwapStorage,\n    lpAmount: BigNumber,\n    lpSupply:BigNumber,\n     tokenBalances: BigNumber[]\n): BigNumber[] {\n\n    return _calcAllTokensInGivenExactLpOut(\n        _xp(tokenBalances, self.tokenMultipliers),\n        lpAmount,\n        lpSupply\n    );\n}\n\n/**\n * Estimate amount of LP token minted or burned at deposit or withdrawal\n */\nexport function calculateTokenAmount(\n    self: WeightedSwapStorage,\n    amounts: BigNumber[],\n    lpSupply:BigNumber,\n    deposit: boolean,\n    tokenBalances: BigNumber[]\n): BigNumber {\n    let lpTokenAmount = ZERO\n    if (deposit) {\n        const { lpOut } = _calcLpOutGivenExactTokensIn(\n            _xp(tokenBalances, self.tokenMultipliers),\n            self.normalizedWeights,\n            _xp(amounts, self.tokenMultipliers),\n            lpSupply,\n            self.fee\n        );\n        lpTokenAmount = lpOut\n    } else {\n        const { lpIn } = _calcLpInGivenExactTokensOut(\n            _xp(tokenBalances, self.tokenMultipliers),\n            self.normalizedWeights,\n            _xp(amounts, self.tokenMultipliers),\n            lpSupply,\n            self.fee\n        );\n        lpTokenAmount = lpIn\n    }\n\n    return lpTokenAmount\n}\n\nexport function calculateSwapGivenIn(self: WeightedSwapStorage, inIndex: number, outIndex: number, amountIn: BigNumber, tokenBalances: BigNumber[]): BigNumber {\n    // use in amount with fee alredy deducted\n    const amountInWithFee = amountIn.mul(self.tokenMultipliers[inIndex]).mul(FEE_DENOMINATOR.sub(self.fee));\n\n    // calculate out amount\n    let amountOut = _calcOutGivenIn(\n        tokenBalances[inIndex].mul(self.tokenMultipliers[inIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[inIndex],\n        tokenBalances[outIndex].mul(self.tokenMultipliers[outIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[outIndex],\n        amountInWithFee\n    );\n\n    // downscale out amount\n    return amountOut.div(FEE_DENOMINATOR).div(self.tokenMultipliers[outIndex]);\n\n}\n\n\nexport function calculateSwapGivenOut(self: WeightedSwapStorage, inIndex: number, outIndex: number, amountOut: BigNumber,tokenBalances: BigNumber[]): BigNumber {\n    // calculate in amount with upscaled balances\n    const amountIn = _calcInGivenOut(\n        tokenBalances[inIndex].mul(self.tokenMultipliers[inIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[inIndex],\n        tokenBalances[outIndex].mul(self.tokenMultipliers[outIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[outIndex],\n        amountOut.mul(self.tokenMultipliers[outIndex]).mul(FEE_DENOMINATOR)\n    );\n    // adjust for fee and scale down - rounding up\n    return amountIn.div(FEE_DENOMINATOR.sub(self.fee)).div(self.tokenMultipliers[inIndex]).add(1);\n}\n\n\nexport function _xp(balances: BigNumber[], rates: BigNumber[]): BigNumber[] {\n    let result = []\n    for (let i = 0; i < balances.length; i++) {\n        result.push(rates[i].mul(balances[i]))\n    }\n    return result\n}","import invariant from 'tiny-invariant'\nimport { BigNumber } from '@ethersproject/bignumber'\n\nconst ZERO = BigNumber.from(0)\nconst ONE = BigNumber.from(1)\nconst TWO = BigNumber.from(2)\nconst TENK = BigNumber.from(10000)\nconst _256 = BigNumber.from('256')\nconst _128 = BigNumber.from('128')\nconst MIN_PRECISION = 32;\nconst MAX_PRECISION = 127;\n\nconst FIXED_1 = BigNumber.from('0x080000000000000000000000000000000')\nconst FIXED_2 = BigNumber.from('0x100000000000000000000000000000000')\nconst MAX_NUM = BigNumber.from('0x200000000000000000000000000000000')\n\nconst LN2_NUMERATOR = BigNumber.from('0x3f80fe03f80fe03f80fe03f80fe03f8')\nconst LN2_DENOMINATOR = BigNumber.from('0x5b9de1d10bf4103d647b0955897ba80')\n\nconst OPT_LOG_MAX_VAL = BigNumber.from('0x15bf0a8b1457695355fb8ac404e7a79e3')\nconst OPT_EXP_MAX_VAL = BigNumber.from('0x800000000000000000000000000000000')\n\n// const LAMBERT_CONV_RADIUS = BigNumber.from('0x002f16ac6c59de6f8d5d6f63c1482a7c86')\n// const LAMBERT_POS2_SAMPLE = BigNumber.from('0x0003060c183060c183060c183060c18306')\n// const LAMBERT_POS2_MAXVAL = BigNumber.from('0x01af16ac6c59de6f8d5d6f63c1482a7c80')\n// const LAMBERT_POS3_MAXVAL = BigNumber.from('0x6b22d43e72c326539cceeef8bb48f255ff')\n\n// const MAX_UNF_WEIGHT = BigNumber.from('0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9')\n\nconst maxExpArray = new Array<BigNumber>(128)\nmaxExpArray[32] = BigNumber.from('0x1c35fedd14ffffffffffffffffffffffff')\nmaxExpArray[33] = BigNumber.from('0x1b0ce43b323fffffffffffffffffffffff')\nmaxExpArray[34] = BigNumber.from('0x19f0028ec1ffffffffffffffffffffffff')\nmaxExpArray[35] = BigNumber.from('0x18ded91f0e7fffffffffffffffffffffff')\nmaxExpArray[36] = BigNumber.from('0x17d8ec7f0417ffffffffffffffffffffff')\nmaxExpArray[37] = BigNumber.from('0x16ddc6556cdbffffffffffffffffffffff')\nmaxExpArray[38] = BigNumber.from('0x15ecf52776a1ffffffffffffffffffffff')\nmaxExpArray[39] = BigNumber.from('0x15060c256cb2ffffffffffffffffffffff')\nmaxExpArray[40] = BigNumber.from('0x1428a2f98d72ffffffffffffffffffffff')\nmaxExpArray[41] = BigNumber.from('0x13545598e5c23fffffffffffffffffffff')\nmaxExpArray[42] = BigNumber.from('0x1288c4161ce1dfffffffffffffffffffff')\nmaxExpArray[43] = BigNumber.from('0x11c592761c666fffffffffffffffffffff')\nmaxExpArray[44] = BigNumber.from('0x110a688680a757ffffffffffffffffffff')\nmaxExpArray[45] = BigNumber.from('0x1056f1b5bedf77ffffffffffffffffffff')\nmaxExpArray[46] = BigNumber.from('0x0faadceceeff8bffffffffffffffffffff')\nmaxExpArray[47] = BigNumber.from('0x0f05dc6b27edadffffffffffffffffffff')\nmaxExpArray[48] = BigNumber.from('0x0e67a5a25da4107fffffffffffffffffff')\nmaxExpArray[49] = BigNumber.from('0x0dcff115b14eedffffffffffffffffffff')\nmaxExpArray[50] = BigNumber.from('0x0d3e7a392431239fffffffffffffffffff')\nmaxExpArray[51] = BigNumber.from('0x0cb2ff529eb71e4fffffffffffffffffff')\nmaxExpArray[52] = BigNumber.from('0x0c2d415c3db974afffffffffffffffffff')\nmaxExpArray[53] = BigNumber.from('0x0bad03e7d883f69bffffffffffffffffff')\nmaxExpArray[54] = BigNumber.from('0x0b320d03b2c343d5ffffffffffffffffff')\nmaxExpArray[55] = BigNumber.from('0x0abc25204e02828dffffffffffffffffff')\nmaxExpArray[56] = BigNumber.from('0x0a4b16f74ee4bb207fffffffffffffffff')\nmaxExpArray[57] = BigNumber.from('0x09deaf736ac1f569ffffffffffffffffff')\nmaxExpArray[58] = BigNumber.from('0x0976bd9952c7aa957fffffffffffffffff')\nmaxExpArray[59] = BigNumber.from('0x09131271922eaa606fffffffffffffffff')\nmaxExpArray[60] = BigNumber.from('0x08b380f3558668c46fffffffffffffffff')\nmaxExpArray[61] = BigNumber.from('0x0857ddf0117efa215bffffffffffffffff')\nmaxExpArray[62] = BigNumber.from('0x07ffffffffffffffffffffffffffffffff')\nmaxExpArray[63] = BigNumber.from('0x07abbf6f6abb9d087fffffffffffffffff')\nmaxExpArray[64] = BigNumber.from('0x075af62cbac95f7dfa7fffffffffffffff')\nmaxExpArray[65] = BigNumber.from('0x070d7fb7452e187ac13fffffffffffffff')\nmaxExpArray[66] = BigNumber.from('0x06c3390ecc8af379295fffffffffffffff')\nmaxExpArray[67] = BigNumber.from('0x067c00a3b07ffc01fd6fffffffffffffff')\nmaxExpArray[68] = BigNumber.from('0x0637b647c39cbb9d3d27ffffffffffffff')\nmaxExpArray[69] = BigNumber.from('0x05f63b1fc104dbd39587ffffffffffffff')\nmaxExpArray[70] = BigNumber.from('0x05b771955b36e12f7235ffffffffffffff')\nmaxExpArray[71] = BigNumber.from('0x057b3d49dda84556d6f6ffffffffffffff')\nmaxExpArray[72] = BigNumber.from('0x054183095b2c8ececf30ffffffffffffff')\nmaxExpArray[73] = BigNumber.from('0x050a28be635ca2b888f77fffffffffffff')\nmaxExpArray[74] = BigNumber.from('0x04d5156639708c9db33c3fffffffffffff')\nmaxExpArray[75] = BigNumber.from('0x04a23105873875bd52dfdfffffffffffff')\nmaxExpArray[76] = BigNumber.from('0x0471649d87199aa990756fffffffffffff')\nmaxExpArray[77] = BigNumber.from('0x04429a21a029d4c1457cfbffffffffffff')\nmaxExpArray[78] = BigNumber.from('0x0415bc6d6fb7dd71af2cb3ffffffffffff')\nmaxExpArray[79] = BigNumber.from('0x03eab73b3bbfe282243ce1ffffffffffff')\nmaxExpArray[80] = BigNumber.from('0x03c1771ac9fb6b4c18e229ffffffffffff')\nmaxExpArray[81] = BigNumber.from('0x0399e96897690418f785257fffffffffff')\nmaxExpArray[82] = BigNumber.from('0x0373fc456c53bb779bf0ea9fffffffffff')\nmaxExpArray[83] = BigNumber.from('0x034f9e8e490c48e67e6ab8bfffffffffff')\nmaxExpArray[84] = BigNumber.from('0x032cbfd4a7adc790560b3337ffffffffff')\nmaxExpArray[85] = BigNumber.from('0x030b50570f6e5d2acca94613ffffffffff')\nmaxExpArray[86] = BigNumber.from('0x02eb40f9f620fda6b56c2861ffffffffff')\nmaxExpArray[87] = BigNumber.from('0x02cc8340ecb0d0f520a6af58ffffffffff')\nmaxExpArray[88] = BigNumber.from('0x02af09481380a0a35cf1ba02ffffffffff')\nmaxExpArray[89] = BigNumber.from('0x0292c5bdd3b92ec810287b1b3fffffffff')\nmaxExpArray[90] = BigNumber.from('0x0277abdcdab07d5a77ac6d6b9fffffffff')\nmaxExpArray[91] = BigNumber.from('0x025daf6654b1eaa55fd64df5efffffffff')\nmaxExpArray[92] = BigNumber.from('0x0244c49c648baa98192dce88b7ffffffff')\nmaxExpArray[93] = BigNumber.from('0x022ce03cd5619a311b2471268bffffffff')\nmaxExpArray[94] = BigNumber.from('0x0215f77c045fbe885654a44a0fffffffff')\nmaxExpArray[95] = BigNumber.from('0x01ffffffffffffffffffffffffffffffff')\nmaxExpArray[96] = BigNumber.from('0x01eaefdbdaaee7421fc4d3ede5ffffffff')\nmaxExpArray[97] = BigNumber.from('0x01d6bd8b2eb257df7e8ca57b09bfffffff')\nmaxExpArray[98] = BigNumber.from('0x01c35fedd14b861eb0443f7f133fffffff')\nmaxExpArray[99] = BigNumber.from('0x01b0ce43b322bcde4a56e8ada5afffffff')\nmaxExpArray[100] = BigNumber.from('0x019f0028ec1fff007f5a195a39dfffffff')\nmaxExpArray[101] = BigNumber.from('0x018ded91f0e72ee74f49b15ba527ffffff')\nmaxExpArray[102] = BigNumber.from('0x017d8ec7f04136f4e5615fd41a63ffffff')\nmaxExpArray[103] = BigNumber.from('0x016ddc6556cdb84bdc8d12d22e6fffffff')\nmaxExpArray[104] = BigNumber.from('0x015ecf52776a1155b5bd8395814f7fffff')\nmaxExpArray[105] = BigNumber.from('0x015060c256cb23b3b3cc3754cf40ffffff')\nmaxExpArray[106] = BigNumber.from('0x01428a2f98d728ae223ddab715be3fffff')\nmaxExpArray[107] = BigNumber.from('0x013545598e5c23276ccf0ede68034fffff')\nmaxExpArray[108] = BigNumber.from('0x01288c4161ce1d6f54b7f61081194fffff')\nmaxExpArray[109] = BigNumber.from('0x011c592761c666aa641d5a01a40f17ffff')\nmaxExpArray[110] = BigNumber.from('0x0110a688680a7530515f3e6e6cfdcdffff')\nmaxExpArray[111] = BigNumber.from('0x01056f1b5bedf75c6bcb2ce8aed428ffff')\nmaxExpArray[112] = BigNumber.from('0x00faadceceeff8a0890f3875f008277fff')\nmaxExpArray[113] = BigNumber.from('0x00f05dc6b27edad306388a600f6ba0bfff')\nmaxExpArray[114] = BigNumber.from('0x00e67a5a25da41063de1495d5b18cdbfff')\nmaxExpArray[115] = BigNumber.from('0x00dcff115b14eedde6fc3aa5353f2e4fff')\nmaxExpArray[116] = BigNumber.from('0x00d3e7a3924312399f9aae2e0f868f8fff')\nmaxExpArray[117] = BigNumber.from('0x00cb2ff529eb71e41582cccd5a1ee26fff')\nmaxExpArray[118] = BigNumber.from('0x00c2d415c3db974ab32a51840c0b67edff')\nmaxExpArray[119] = BigNumber.from('0x00bad03e7d883f69ad5b0a186184e06bff')\nmaxExpArray[120] = BigNumber.from('0x00b320d03b2c343d4829abd6075f0cc5ff')\nmaxExpArray[121] = BigNumber.from('0x00abc25204e02828d73c6e80bcdb1a95bf')\nmaxExpArray[122] = BigNumber.from('0x00a4b16f74ee4bb2040a1ec6c15fbbf2df')\nmaxExpArray[123] = BigNumber.from('0x009deaf736ac1f569deb1b5ae3f36c130f')\nmaxExpArray[124] = BigNumber.from('0x00976bd9952c7aa957f5937d790ef65037')\nmaxExpArray[125] = BigNumber.from('0x009131271922eaa6064b73a22d0bd4f2bf')\nmaxExpArray[126] = BigNumber.from('0x008b380f3558668c46c91c49a2f8e967b9')\nmaxExpArray[127] = BigNumber.from('0x00857ddf0117efa215952912839f6473e6')\n\nfunction leftShift(num: BigNumber, shift: BigNumber) {\n    return num.mul(TWO.pow(shift))\n}\n\nfunction signedRightShift(num: BigNumber, shift: BigNumber) {\n    return num.div(TWO.pow(shift))\n}\n\n/**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\nexport function power(\n    _baseN: BigNumber,\n    _baseD: BigNumber,\n    _expN: BigNumber,\n    _expD: BigNumber\n): [BigNumber, number] {\n    invariant(_baseN.gt(_baseD), \"not support _baseN < _baseD\");\n    invariant(_baseN.lt(MAX_NUM))\n\n    let baseLog;\n    let base = (_baseN.mul(FIXED_1)).div(_baseD);\n    if (base.lt(OPT_LOG_MAX_VAL)) {\n        baseLog = optimalLog(base);\n    } else {\n        baseLog = generalLog(base);\n    }\n\n    let baseLogTimesExp = (baseLog.mul(_expN)).div(_expD);\n    if (baseLogTimesExp.lt(OPT_EXP_MAX_VAL)) {\n        return [optimalExp(baseLogTimesExp), MAX_PRECISION]\n    } else {\n        let precision = findPositionInMaxExpArray(baseLogTimesExp);\n        return [generalExp(signedRightShift(baseLogTimesExp, BigNumber.from(MAX_PRECISION - precision)), BigNumber.from(precision)), precision]\n    }\n}\n\n/**\n * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n */\nfunction floorLog2(_n: BigNumber): BigNumber {\n    let res = ZERO;\n    if (_n.lt(_256)) {\n        // At most 8 iterations\n        while (_n.gt(ONE)) {\n            _n = signedRightShift(_n, ONE);\n            res = res.add(ONE);\n        }\n    } else {\n        // Exactly 8 iterations\n        for (let s = _128; s.gt(ZERO); s = signedRightShift(s, ONE)) {\n            if (_n.gt(leftShift(ONE, s))) {\n                _n = signedRightShift(_n, s)\n                res = res.or(s);\n            }\n        }\n    }\n\n    return res;\n}\n\n/**\n * @dev computes log(x / FIXED_1) * FIXED_1.\n * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n */\nexport function generalLog(x: BigNumber): BigNumber {\n    let res = ZERO;\n    // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n    if (x.gte(FIXED_2)) {\n        const count = floorLog2(x.div(FIXED_1));\n        x = signedRightShift(x, count);\n        // now x < 2\n        res = count.mul(FIXED_1);\n    }\n\n    // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n    if (x.gt(FIXED_1)) {\n        for (let i = MAX_PRECISION; i > 0; --i) {\n            x = (x.mul(x)).div(FIXED_1);\n            // now 1 < x < 4\n            if (x.gte(FIXED_2)) {\n                x = signedRightShift(x, ONE);\n                // now 1 < x < 2\n                res = res.add(leftShift(ONE, BigNumber.from(i - 1)));\n            }\n        }\n    }\n\n    return (res.mul(LN2_NUMERATOR)).div(LN2_DENOMINATOR)\n}\n\n/**\n    * @dev computes log(x / FIXED_1) * FIXED_1\n    * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\n    * Auto-generated via \"PrintFunctionOptimalLog.py\"\n    * Detailed description:\n    * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n    * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n    * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n    * - The natural logarithm of the input is calculated by summing up the intermediate results above\n    * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n    */\nexport function optimalLog(x: BigNumber): BigNumber {\n    let res = ZERO;\n\n    let y;\n    let z;\n    let w;\n\n    if (x.gte('0xd3094c70f034de4b96ff7d5b6f99fcd8')) {\n        res = res.add(BigNumber.from('0x40000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0xd3094c70f034de4b96ff7d5b6f99fcd8'));\n    }\n    // add 1 / 2^1\n    if (x.gte('0xa45af1e1f40c333b3de1db4dd55f29a7')) {\n        res = res.add(BigNumber.from('0x20000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0xa45af1e1f40c333b3de1db4dd55f29a7'));\n    }\n    // add 1 / 2^2\n    if (x.gte('0x910b022db7ae67ce76b441c27035c6a1')) {\n        res = res.add(BigNumber.from('0x10000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x910b022db7ae67ce76b441c27035c6a1'));\n    }\n    // add 1 / 2^3\n    if (x.gte('0x88415abbe9a76bead8d00cf112e4d4a8')) {\n        res = res.add(BigNumber.from('0x08000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x88415abbe9a76bead8d00cf112e4d4a8'));\n    }\n    // add 1 / 2^4\n    if (x.gte('0x84102b00893f64c705e841d5d4064bd3')) {\n        res = res.add(BigNumber.from('0x04000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x84102b00893f64c705e841d5d4064bd3'));\n    }\n    // add 1 / 2^5\n    if (x.gte('0x8204055aaef1c8bd5c3259f4822735a2')) {\n        res = res.add(BigNumber.from('0x02000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x8204055aaef1c8bd5c3259f4822735a2'));\n    }\n    // add 1 / 2^6\n    if (x.gte('0x810100ab00222d861931c15e39b44e99')) {\n        res = res.add(BigNumber.from('0x01000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x810100ab00222d861931c15e39b44e99'));\n    }\n    // add 1 / 2^7\n    if (x.gte('0x808040155aabbbe9451521693554f733')) {\n        res = res.add(BigNumber.from('0x00800000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x808040155aabbbe9451521693554f733'));\n    }\n    // add 1 / 2^8\n\n    z = y = x.sub(FIXED_1);\n    w = (y.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x100000000000000000000000000000000').sub(y)).div(BigNumber.from('0x100000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^01 / 01 - y^02 / 02\n    res = res.add(z.mul(BigNumber.from('0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa').sub(y)).div(BigNumber.from('0x200000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^03 / 03 - y^04 / 04\n    res = res.add(z.mul(BigNumber.from('0x099999999999999999999999999999999').sub(y)).div(BigNumber.from('0x300000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^05 / 05 - y^06 / 06\n    res = res.add(z.mul(BigNumber.from('0x092492492492492492492492492492492').sub(y)).div(BigNumber.from('0x400000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^07 / 07 - y^08 / 08\n    res = res.add(z.mul(BigNumber.from('0x08e38e38e38e38e38e38e38e38e38e38e').sub(y)).div(BigNumber.from('0x500000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^09 / 09 - y^10 / 10\n    res = res.add(z.mul(BigNumber.from('0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b').sub(y)).div(BigNumber.from('0x600000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^11 / 11 - y^12 / 12\n    res = res.add(z.mul(BigNumber.from('0x089d89d89d89d89d89d89d89d89d89d89').sub(y)).div(BigNumber.from('0x700000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^13 / 13 - y^14 / 14\n    res = res.add(z.mul(BigNumber.from('0x088888888888888888888888888888888').sub(y)).div(BigNumber.from('0x800000000000000000000000000000000')));\n    // add y^15 / 15 - y^16 / 16\n\n    return res;\n}\n\nexport function optimalExp(x: BigNumber): BigNumber {\n    let res = ZERO;\n\n    let y;\n    let z;\n\n    z = y = x.mod(BigNumber.from('0x10000000000000000000000000000000'));\n    // get the input modulo 2^(-3)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x10e1b3be415a0000')));\n    // add y^02 * (20! / 02!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x05a0913f6b1e0000')));\n    // add y^03 * (20! / 03!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0168244fdac78000')));\n    // add y^04 * (20! / 04!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x004807432bc18000')));\n    // add y^05 * (20! / 05!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000c0135dca04000')));\n    // add y^06 * (20! / 06!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0001b707b1cdc000')));\n    // add y^07 * (20! / 07!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000036e0f639b800')));\n    // add y^08 * (20! / 08!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x00000618fee9f800')));\n    // add y^09 * (20! / 09!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000009c197dcc00')));\n    // add y^10 * (20! / 10!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000e30dce400')));\n    // add y^11 * (20! / 11!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000000012ebd1300')));\n    // add y^12 * (20! / 12!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000017499f00')));\n    // add y^13 * (20! / 13!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000001a9d480')));\n    // add y^14 * (20! / 14!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x00000000001c6380')));\n    // add y^15 * (20! / 15!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000000000001c638')));\n    // add y^16 * (20! / 16!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000000001ab8')));\n    // add y^17 * (20! / 17!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000000000000017c')));\n    // add y^18 * (20! / 18!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000000000014')));\n    // add y^19 * (20! / 19!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000000000001')));\n    // add y^20 * (20! / 20!)\n    res = res.div(BigNumber.from('0x21c3677c82b40000')).add(y).add(FIXED_1);\n    // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n    if (!(x.and(BigNumber.from('0x010000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x1c3d6a24ed82218787d624d3e5eba95f9'))).div(BigNumber.from('0x18ebef9eac820ae8682b9793ac6d1e776'));\n    // multiply by e^2^(-3)\n    if (!(x.and(BigNumber.from('0x020000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x18ebef9eac820ae8682b9793ac6d1e778'))).div(BigNumber.from('0x1368b2fc6f9609fe7aceb46aa619baed4'));\n    // multiply by e^2^(-2)\n    if (!(x.and(BigNumber.from('0x040000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x1368b2fc6f9609fe7aceb46aa619baed5'))).div(BigNumber.from('0x0bc5ab1b16779be3575bd8f0520a9f21f'));\n    // multiply by e^2^(-1)\n    if (!(x.and(BigNumber.from('0x080000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x0bc5ab1b16779be3575bd8f0520a9f21e'))).div(BigNumber.from('0x0454aaa8efe072e7f6ddbab84b40a55c9'));\n    // multiply by e^2^(+0)\n    if (!(x.and(BigNumber.from('0x100000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x0454aaa8efe072e7f6ddbab84b40a55c5'))).div(BigNumber.from('0x00960aadc109e7a3bf4578099615711ea'));\n    // multiply by e^2^(+1)\n    if (!(x.and(BigNumber.from('0x200000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x00960aadc109e7a3bf4578099615711d7'))).div(BigNumber.from('0x0002bf84208204f5977f9a8cf01fdce3d'));\n    // multiply by e^2^(+2)\n    if (!(x.and(BigNumber.from('0x400000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x0002bf84208204f5977f9a8cf01fdc307'))).div(BigNumber.from('0x0000003c6ab775dd0b95b4cbee7e65d11'));\n    // multiply by e^2^(+3)\n\n    return res;\n}\n\n/**\n   * @dev this function can be auto-generated by the script \"PrintFunctionGeneralExp.py\".\n   * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n   * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n   * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n   * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n   */\nexport function generalExp(_x: BigNumber, _precision: BigNumber) {\n    let xi = _x;\n    let res = ZERO;\n\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x3442c4e6074a82f1797f72ac0000000'));\n    // add x^02 * (33! / 02!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x116b96f757c380fb287fd0e40000000'));\n    // add x^03 * (33! / 03!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x045ae5bdd5f0e03eca1ff4390000000'));\n    // add x^04 * (33! / 04!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00defabf91302cd95b9ffda50000000'));\n    // add x^05 * (33! / 05!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x002529ca9832b22439efff9b8000000'));\n    // add x^06 * (33! / 06!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00054f1cf12bd04e516b6da88000000'));\n    // add x^07 * (33! / 07!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000a9e39e257a09ca2d6db51000000'));\n    // add x^08 * (33! / 08!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000012e066e7b839fa050c309000000'));\n    // add x^09 * (33! / 09!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000001e33d7d926c329a1ad1a800000'));\n    // add x^10 * (33! / 10!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000002bee513bdb4a6b19b5f800000'));\n    // add x^11 * (33! / 11!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000003a9316fa79b88eccf2a00000'));\n    // add x^12 * (33! / 12!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000048177ebe1fa812375200000'));\n    // add x^13 * (33! / 13!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000005263fe90242dcbacf00000'));\n    // add x^14 * (33! / 14!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000057e22099c030d94100000'));\n    // add x^15 * (33! / 15!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000057e22099c030d9410000'));\n    // add x^16 * (33! / 16!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000052b6b54569976310000'));\n    // add x^17 * (33! / 17!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000004985f67696bf748000'));\n    // add x^18 * (33! / 18!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000003dea12ea99e498000'));\n    // add x^19 * (33! / 19!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000031880f2214b6e000'));\n    // add x^20 * (33! / 20!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000000025bcff56eb36000'));\n    // add x^21 * (33! / 21!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000000001b722e10ab1000'));\n    // add x^22 * (33! / 22!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000001317c70077000'));\n    // add x^23 * (33! / 23!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000cba84aafa00'));\n    // add x^24 * (33! / 24!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000082573a0a00'));\n    // add x^25 * (33! / 25!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000005035ad900'));\n    // add x^26 * (33! / 26!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000000000000002f881b00'));\n    // add x^27 * (33! / 27!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000001b29340'));\n    // add x^28 * (33! / 28!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000000000efc40'));\n    // add x^29 * (33! / 29!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000007fe0'));\n    // add x^30 * (33! / 30!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000000420'));\n    // add x^31 * (33! / 31!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000000021'));\n    // add x^32 * (33! / 32!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000000001'));\n    // add x^33 * (33! / 33!)\n\n\n    return (res.div(BigNumber.from('0x688589cc0e9505e2f2fee5580000000'))).add(_x).add(leftShift(ONE, _precision));\n    // divide by 33! and then add x^1 / 1! + x^0 / 0!\n}\n\n/**\n    * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n    * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n    * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n    */\nexport function findPositionInMaxExpArray(_x: BigNumber): number {\n    let lo = MIN_PRECISION;\n    let hi = MAX_PRECISION;\n\n    while (lo + 1 < hi) {\n        let mid = (lo + hi) / 2;\n        if (maxExpArray[mid].gte(_x)) lo = mid;\n        else hi = mid;\n    }\n\n    if (maxExpArray[hi].gte(_x)) return hi;\n    if (maxExpArray[lo].gte(_x)) return lo;\n\n    invariant(false);\n}\n\n/**\n * @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset,\n *\n * Formula:\n * return = reserveOut * (1 - (reserveIn * 10000 / (reserveIn * 10000 + amountIn * (10000 - swapFee))) ^ (tokenWeightIn / tokenWeightOut))\n *\n * @param amountIn                  source reserve amount\n * @param reserveIn    source reserve balance\n * @param reserveOut    target reserve balance\n * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n * @param swapFee                  swap fee of the conversion\n *\n * @return amountOut\n */\nexport function getAmountOut(\n    amountIn: BigNumber,\n    reserveIn: BigNumber,\n    reserveOut: BigNumber,\n    tokenWeightIn: BigNumber,\n    tokenWeightOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    // validate input\n    invariant(amountIn.gt(ZERO), \"RequiemFormula: INSUFFICIENT_INPUT_AMOUNT\");\n    // if (amountIn.lte(ZERO) || amountIn.eq(ZERO))\n    //     return ZERO\n\n    invariant(reserveIn.gt(ZERO) && reserveOut.gt(ZERO), \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n    const amountInWithFee = amountIn.mul(TENK.sub(swapFee))\n    // special case for equal weights\n    if (tokenWeightIn.eq(tokenWeightOut)) {\n        return (reserveOut.mul(amountInWithFee)).div(reserveIn.mul(TENK).add(amountInWithFee));\n    }\n\n    // let result;\n    // let precision: number;\n    const baseN = (reserveIn.mul(TENK)).add(amountInWithFee)\n    const [result, precision] = power(baseN, reserveIn.mul(TENK), tokenWeightIn, tokenWeightOut);\n\n    const temp1 = reserveOut.mul(result);\n    const temp2 = leftShift(reserveOut, BigNumber.from(precision));\n\n    return (temp1.sub(temp2)).div(result)\n}\n\n/**\n * @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n *\n * Formula:\n * return = reserveIn * ( (reserveOut / (reserveOut - amountOut)) ^ (tokenWeightOut / tokenWeightIn) - 1) * (10000/ (10000 - swapFee)\n *\n * @param amountOut     target reserve amount\n * @param reserveIn    source reserve balance\n * @param reserveOut    target reserve balance\n * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n * @param swapFee                  swap fee of the conversion\n *\n * @return amountIn\n */\nexport function getAmountIn(\n    amountOut: BigNumber,\n    reserveIn: BigNumber,\n    reserveOut: BigNumber,\n    tokenWeightIn: BigNumber,\n    tokenWeightOut: BigNumber,\n    swapFee: BigNumber\n) {\n    // validate input\n    invariant(amountOut.gt(ZERO), \"RequiemFormula: INSUFFICIENT_OUTPUT_AMOUNT\");\n\n    // if (amountOut.gte(ZERO) || amountOut.eq(ZERO))\n    //     return ZERO\n\n    invariant(reserveIn.gt(ZERO) && reserveOut.gt(ZERO), \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n    // special case for equal weights\n    if (tokenWeightIn.eq(tokenWeightOut)) {\n        const numerator = reserveIn.mul(amountOut).mul(TENK);\n        const denominator = reserveOut.sub(amountOut).mul(TENK.sub(swapFee));\n        return (numerator.div(denominator)).add(1);\n    }\n\n    const baseD = reserveOut.sub(amountOut);\n    const [result, precision] = power(reserveOut, baseD, tokenWeightOut, tokenWeightIn);\n    const baseReserveIn = reserveIn.mul(TENK);\n    const temp1 = baseReserveIn.mul(result);\n    const temp2 = leftShift(baseReserveIn, BigNumber.from(precision));\n    return (signedRightShift(temp1.sub(temp2), BigNumber.from(precision)).div(TENK.sub(swapFee))).add(1);\n}\n\n","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\nimport { Token } from '../token'\nimport { Price, TokenAmount } from '../fractions'\n\n// const ZERO = BigNumber.from(0)\n\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport abstract class Pool {\n\n    // the index-token map \n    public abstract readonly tokens: Token[]\n    public abstract readonly liquidityToken: Token\n    public abstract tokenBalances: BigNumber[]\n    public abstract readonly address: string\n    public abstract _name: string\n\n    /**\n     * Returns true if the token is either token0 or token1\n     * @param token to check\n     */\n    public involvesToken(token: Token): boolean {\n        let res = false\n        for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n            res || token.equals(this.tokens[i])\n        }\n\n        return res\n    }\n\n    // maps the index to the token in the stablePool\n    public tokenFromIndex(index: number): Token {\n        return this.tokens[index]\n    }\n\n    public indexFromToken(token: Token): number {\n        for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n            if (token.equals(this.tokens[index])) {\n                return index\n            }\n        }\n        throw new Error('token not in pool');\n    }\n\n    public getBalances(): BigNumber[] {\n        return Object.keys(this.tokens).map((_, index) => (this.tokenBalances[index]))\n    }\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public abstract calculateSwapGivenIn(\n        tokenIn: Token,\n        tokenOut: Token,\n        inAmount: BigNumber): BigNumber;\n\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public abstract calculateSwapGivenOut(\n        tokenIn: Token,\n        tokenOut: Token,\n        outAmount: BigNumber): BigNumber;\n\n    /**\n     * Returns the chain ID of the tokens in the pair.\n     */\n    public get chainId(): number {\n        return this.tokens[0].chainId\n    }\n\n    public token(index: number): Token {\n        return this.tokens[index]\n    }\n\n    public reserveOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n            if (token.equals(this.tokens[i]))\n                return this.tokenBalances[i]\n        }\n        return BigNumber.from(0)\n    }\n\n    public set name(value: string) {\n        this._name = value\n    }\n\n    public get name(): string {\n        return this._name\n    }\n\n\n    public setBalanceValueByIndex(index: number, newBalance: BigNumber) {\n        this.tokenBalances[index] = newBalance\n    }\n\n    public getTokenAmounts(): TokenAmount[] {\n        return this.tokens.map((t, i) => new TokenAmount(t, this.tokenBalances[i]))\n    }\n\n    public setTokenBalances(tokenBalances: BigNumber[]) {\n        this.tokenBalances = tokenBalances\n    }\n\n    public subtractBalanceValue(tokenAmount: TokenAmount) {\n        let newBalances = [] // safe way for replacement\n        for (let i = 0; i < this.tokenBalances.length; i++) {\n            newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].sub(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n        }\n        this.setTokenBalances(newBalances)\n    }\n\n    public abstract poolPrice(tokenIn: Token, tokenOut: Token): Price;\n\n    public abstract poolPriceBases(tokenIn: Token, tokenOut: Token): {\n        priceBaseIn: BigNumber\n        priceBaseOut: BigNumber\n\n    };\n\n}\n\n\nexport enum PoolType {\n    Pair = 'Pair',\n    StablePairWrapper = 'StablePairWrapper',\n    AmplifiedWeightedPair = 'AmplifiedWeightedPair',\n    PoolPairWrapper = 'PoolPairWrapper',\n}\n\nexport type PoolDictionary = { [id: string]: Pool }\n\nexport type PoolHops = {\n    [tokenAddress: string]: Set<Token>; // the set of pool ids\n}","import { BigNumber } from \"ethers\"\nimport { ZERO } from \"./LogExpMath\"\n\nexport class WeightedSwapStorage {\n    public readonly tokenMultipliers: BigNumber[]\n    public readonly normalizedWeights: BigNumber[]\n    public readonly fee: BigNumber\n    public readonly adminFee: BigNumber\n    constructor(\n        tokenMultipliers: BigNumber[],\n        normalizedWeights: BigNumber[],\n        fee: BigNumber,\n        adminFee: BigNumber,\n    ) {\n        this.tokenMultipliers = tokenMultipliers\n        this.normalizedWeights = normalizedWeights\n        this.fee = fee\n        this.adminFee = adminFee\n\n    }\n\n    public static mock(): WeightedSwapStorage {\n        return new WeightedSwapStorage([ZERO], [ZERO], ZERO, ZERO)\n    }\n\n}","import { BigNumber } from \"ethers\"\n\nexport class StableSwapStorage {\n    public readonly tokenMultipliers: BigNumber[]\n    public readonly fee: BigNumber\n    public readonly adminFee: BigNumber\n    public readonly initialA: BigNumber\n    public readonly futureA: BigNumber\n    public readonly initialATime: BigNumber\n    public readonly futureATime: BigNumber\n    public readonly lpAddress: string\n\n    constructor(tokenMultipliers: BigNumber[],\n        fee: BigNumber,\n        adminFee: BigNumber,\n        initialA: BigNumber,\n        futureA: BigNumber,\n        initialATime: BigNumber,\n        futureATime: BigNumber,\n        lpAddress: string) {\n        this.lpAddress = lpAddress\n        this.tokenMultipliers = tokenMultipliers\n        this.fee = fee\n        this.adminFee = adminFee\n        this.initialA = initialA\n        this.futureA = futureA\n        this.initialATime = initialATime\n        this.futureATime = futureATime\n    }\n\n    public static mock(): StableSwapStorage {\n        const dummy = BigNumber.from(0)\n        return new StableSwapStorage([dummy], dummy, dummy, dummy, dummy, dummy, dummy, '')\n    }\n\n}","import { Price } from '../../fractions/price'\nimport { TokenAmount } from '../../fractions/tokenAmount'\nimport invariant from 'tiny-invariant'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport {\n    BigintIsh,\n    MINIMUM_LIQUIDITY,\n    ZERO,\n    // ONE,\n    FIVE,\n    // _100,\n    // FEES_NUMERATOR,\n    // FEES_DENOMINATOR,\n    FACTORY_ADDRESS,\n} from '../../../constants'\nimport { sqrt, parseBigintIsh } from '../../../helperUtils'\nimport {\n    // InsufficientReservesError,\n    InsufficientInputAmountError, InsufficientReservesError\n} from '../../../errors'\nimport { Token } from '../../token'\nimport { getAmountOut, getAmountIn } from '../../calculators/weightedPairCalc'\nimport { PoolType, Pool } from '../pool'\n// import { getAmountIn, getAmountOut } from 'entities/calculators/weightedPairCalc'\nimport { ethers } from 'ethers'\nimport { ChainId } from '../../currency'\n\nconst _100 = BigNumber.from(100)\n\nlet PAIR_ADDRESS_CACHE: {\n    [token0Address: string]: {\n        [token1Address: string]: {\n            [weight0: string]: string\n        }\n    }\n} = {}\n\nconst PAIR_HASH: { [chainId: number]: string } = {\n    [ChainId.AVAX_TESTNET]: '0x9054fb12bf026c7ef2c6d1f68fbbead8f68cdbfa477faca7f9d8ec63173f87ff',\n    [ChainId.BSC_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.AVAX_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.OASIS_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.OASIS_TESTNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.BSC_TESTNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.MATIC_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.MATIC_TESTNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.QUARKCHAIN_DEV_S0]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.ARBITRUM_TETSNET_RINKEBY]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.ARBITRUM_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84'\n}\n\nexport class AmplifiedWeightedPair extends Pool {\n    public readonly address: string\n    public readonly tokens: Token[]\n    public tokenBalances: BigNumber[]\n    public virtualReserves: BigNumber[]\n    public readonly liquidityToken: Token\n    private readonly weights: BigNumber[]\n    private readonly fee: BigNumber\n    private readonly ampBPS: BigNumber\n    public readonly type: PoolType\n    public _name: string\n\n    public static getAddress(tokenA: Token, tokenB: Token, weightA: BigNumber): string {\n        const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n        const weights = tokenA.sortsBefore(tokenB) ? [weightA.toString(), _100.sub(weightA).toString()] : [_100.sub(weightA).toString(), weightA.toString()] // does safety checks\n        if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address]?.[`${weights[0]}`] === undefined) {\n            PAIR_ADDRESS_CACHE = {\n                ...PAIR_ADDRESS_CACHE,\n                [tokens[0].address]: {\n                    ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\n                    [tokens[1].address]: {\n                        ...PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address],\n                        [`${weights[0]}`]: getCreate2Address(\n                            FACTORY_ADDRESS[tokens[0].chainId],\n                            keccak256(\n                                ['bytes'],\n                                [pack(\n                                    ['address', 'address', 'uint32'],\n                                    [tokens[0].address, tokens[1].address, weights[0]]\n                                )]\n                            ),\n                            PAIR_HASH[tokens[0].chainId]\n                        )\n                    },\n                },\n            }\n        }\n\n        return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address][`${weights[0]}`]\n    }\n\n    public constructor(tokens: Token[], tokenBalances: BigNumber[], virtualReserves: BigNumber[], weightA: BigNumber, fee: BigNumber, amp: BigNumber, address?: string) {\n        super()\n\n        this.tokenBalances = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? tokenBalances\n            : [tokenBalances[1], tokenBalances[0]]\n        this.tokens = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? tokens\n            : [tokens[1], tokens[0]]\n\n        this.ampBPS = amp\n        this.weights = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? [weightA, _100.sub(weightA)]\n            : [_100.sub(weightA), weightA]\n\n        this.virtualReserves = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? virtualReserves\n            : [virtualReserves[1], virtualReserves[0]]\n\n\n        this.fee = fee\n        this.liquidityToken = new Token(\n            tokens[0].chainId,\n            address ? ethers.utils.getAddress(address) : AmplifiedWeightedPair.getAddress(this.tokens[0], this.tokens[1], this.weights[0]),\n            18,\n            'Requiem-LP',\n            'Requiem LPs'\n        )\n        this.type = PoolType.AmplifiedWeightedPair\n        this.address = !address ? AmplifiedWeightedPair.getAddress(this.token0, this.token1, this.weight0) : address\n\n        this._name = tokens.map(t => t.symbol).join('-')\n    }\n\n    public static fromBigIntish(tokens: Token[], tokenBalances: BigintIsh[], virtualReserves: BigintIsh[], weightA: BigintIsh, fee: BigintIsh, amp: BigintIsh, address?: string): AmplifiedWeightedPair {\n        return new AmplifiedWeightedPair(\n            tokens,\n            tokenBalances.map(b => BigNumber.from(b)),\n            virtualReserves.map(b => BigNumber.from(b)),\n            BigNumber.from(weightA),\n            BigNumber.from(fee),\n            BigNumber.from(amp),\n            address\n        )\n    }\n\n    public getAddressForRouter(): string {\n        return this.liquidityToken.address\n    }\n\n    /**\n     * Returns true if the token is either token0 or token1\n     * @param token to check\n     */\n    public involvesToken(token: Token): boolean {\n        return token.equals(this.token0) || token.equals(this.token1)\n    }\n\n    public get amp(): BigNumber {\n        return this.ampBPS\n    }\n\n    /**\n     * Returns the current mid price of the pair in terms of token0 in virtual reserves\n     */\n    public get token0Price(): Price {\n        return new Price(\n            this.token0,\n            this.token1,\n            this.virtualReserves[0].mul(this.weights[1]),\n            this.virtualReserves[1].mul(this.weights[0])\n        )\n    }\n\n    /**\n     * Returns the current mid price of the pair in terms of token1 in virtual reserves\n     */\n    public get token1Price(): Price {\n        return new Price(\n            this.token1,\n            this.token0,\n            this.virtualReserves[1].mul(this.weights[0]),\n            this.virtualReserves[0].mul(this.weights[1])\n        )\n    }\n\n    public poolPrice(tokenIn: Token, _: Token): Price {\n        return tokenIn.equals(this.token0) ? this.token0Price : this.token1Price\n    }\n\n    public get fee0(): BigNumber {\n        return this.fee\n    }\n\n    public poolPriceBases(tokenIn: Token, _: Token): { priceBaseIn: BigNumber; priceBaseOut: BigNumber; } {\n        if (tokenIn.equals(this.token0)) {\n            return {\n                priceBaseIn: this.virtualReserves[0].mul(this.weights[1]),\n                priceBaseOut: this.virtualReserves[1].mul(this.weights[0])\n            }\n        } else {\n            return {\n                priceBaseIn: this.virtualReserves[1].mul(this.weights[0]),\n                priceBaseOut: this.virtualReserves[0].mul(this.weights[1])\n            }\n        }\n    }\n\n    /**\n     * Return the price of the given token in terms of the other token in the pair.\n     * @param token token to return price of\n     */\n    public priceOf(token: Token): Price {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.token0Price : this.token1Price\n    }\n\n    /**\n     * Returns the chain ID of the tokens in the pair.\n     */\n    public get chainId(): ChainId {\n        return this.token0.chainId\n    }\n\n    public get token0(): Token {\n        return this.tokens[0]\n    }\n\n    public get token1(): Token {\n        return this.tokens[1]\n    }\n\n    public get reserve0(): TokenAmount {\n        return new TokenAmount(this.tokens[0], this.tokenBalances[0])\n    }\n\n    public get reserve1(): TokenAmount {\n        return new TokenAmount(this.tokens[1], this.tokenBalances[1])\n    }\n\n    public get virtualReserve0(): TokenAmount {\n        return new TokenAmount(this.tokens[0], this.virtualReserves[0])\n    }\n\n    public get virtualReserve1(): TokenAmount {\n        return new TokenAmount(this.tokens[1], this.virtualReserves[1])\n    }\n\n    public get weight0(): BigNumber {\n        return this.weights[0]\n    }\n\n    public get weight1(): BigNumber {\n        return this.weights[1]\n    }\n\n\n    public reserveOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.reserve0.raw : this.reserve1.raw\n    }\n\n\n    public virtualReserveOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.virtualReserve0.raw : this.virtualReserve1.raw\n    }\n\n    public weightOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.weight0 : this.weight1\n    }\n\n\n    public getLiquidityMinted(\n        totalSupply: TokenAmount,\n        tokenAmountA: TokenAmount,\n        tokenAmountB: TokenAmount\n    ): TokenAmount {\n        invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n        const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n            ? [tokenAmountA, tokenAmountB]\n            : [tokenAmountB, tokenAmountA]\n        invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n        let liquidity: BigNumber\n        if (totalSupply.raw.eq(ZERO)) {\n            liquidity = sqrt(tokenAmounts[0].raw.mul(tokenAmounts[1].raw)).sub(MINIMUM_LIQUIDITY)\n        } else {\n            const amount0 = tokenAmounts[0].raw.mul(totalSupply.raw).div(this.reserve0.raw)\n            const amount1 = tokenAmounts[1].raw.mul(totalSupply.raw).div(this.reserve1.raw)\n            liquidity = amount0.lte(amount1) ? amount0 : amount1\n        }\n        if (!liquidity.gt(ZERO)) {\n            throw new InsufficientInputAmountError()\n        }\n        return new TokenAmount(this.liquidityToken, liquidity)\n    }\n\n    public getLiquidityValue(\n        token: Token,\n        totalSupply: TokenAmount,\n        liquidity: TokenAmount,\n        feeOn: boolean = false,\n        kLast?: BigintIsh\n    ): TokenAmount {\n        invariant(this.involvesToken(token), 'TOKEN')\n        invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n        invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n        invariant(liquidity.raw.lte(totalSupply.raw), 'LIQUIDITY')\n\n        let totalSupplyAdjusted: TokenAmount\n        if (!feeOn) {\n            totalSupplyAdjusted = totalSupply\n        } else {\n            invariant(!!kLast, 'K_LAST')\n            const kLastParsed = parseBigintIsh(kLast)\n            if (!kLastParsed.eq(ZERO)) {\n                const rootK = sqrt(this.reserve0.raw.mul(this.reserve1.raw))\n                const rootKLast = sqrt(kLastParsed)\n                if (rootK.gt(rootKLast)) {\n                    const numerator = totalSupply.raw.mul(rootK.sub(rootKLast))\n                    const denominator = rootK.mul(FIVE).add(rootKLast)\n                    const feeLiquidity = numerator.div(denominator)\n                    totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n                } else {\n                    totalSupplyAdjusted = totalSupply\n                }\n            } else {\n                totalSupplyAdjusted = totalSupply\n            }\n        }\n\n        return new TokenAmount(\n            token,\n            liquidity.raw.mul(this.reserveOf(token)).div(totalSupplyAdjusted.raw)\n        )\n    }\n\n    public clone(): AmplifiedWeightedPair {\n        return new AmplifiedWeightedPair(this.tokens, this.tokenBalances, this.virtualReserves, this.weight0, this.fee, this.ampBPS)\n    }\n\n    // these are only supposed to be used for liquidity calculations\n    /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n    public get token0PriceRaw(): Price {\n        return new Price(this.token0, this.token1, this.tokenBalances[0], this.tokenBalances[1])\n    }\n\n    /**\n     * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n     */\n    public get token1PriceRaw(): Price {\n        return new Price(this.token1, this.token0, this.tokenBalances[1], this.tokenBalances[0])\n    }\n\n    /**\n     * Return the price of the given token in terms of the other token in the pair.\n     * @param token token to return price of\n     */\n    public priceRatioOf(token: Token): Price {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.token0PriceRaw : this.token1PriceRaw\n    }\n\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public calculateSwapGivenIn(\n        tokenIn: Token,\n        tokenOut: Token,\n        inAmount: BigNumber): BigNumber {\n        if (\n            inAmount.gte(this.reserveOf(tokenIn))\n        ) {\n            throw new InsufficientReservesError()\n        }\n        const inputReserve = this.virtualReserveOf(tokenIn)\n        const outputReserve = this.virtualReserveOf(tokenOut)\n\n        const inputWeight = this.weightOf(tokenIn)\n        const outputWeight = this.weightOf(tokenOut)\n\n        return getAmountOut(\n            inAmount,\n            inputReserve,\n            outputReserve,\n            inputWeight,\n            outputWeight,\n            this.fee\n        )\n    }\n\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public calculateSwapGivenOut(\n        tokenIn: Token,\n        tokenOut: Token,\n        outAmount: BigNumber): BigNumber {\n        if (\n            outAmount.gte(this.reserveOf(tokenOut))\n        ) {\n            throw new InsufficientReservesError()\n        }\n\n        const outputReserve = this.virtualReserveOf(tokenOut)\n        const inputReserve = this.virtualReserveOf(tokenIn)\n\n        const outputWeight = this.weightOf(tokenOut)\n        const inputWeight = this.weightOf(tokenIn)\n\n\n        return getAmountIn(\n            outAmount,\n            inputReserve,\n            outputReserve,\n            inputWeight,\n            outputWeight,\n            this.fee\n        )\n\n    }\n\n    public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pool] {\n        invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n        if (this.reserve0.raw.eq(ZERO) || this.reserve1.raw.eq(ZERO)) {\n            throw new InsufficientReservesError()\n        }\n        const inputReserve = this.virtualReserveOf(inputAmount.token)\n        const outputReserve = this.virtualReserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n        const inputWeight = this.weightOf(inputAmount.token)\n        const outputWeight = this.weightOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n\n        const outputAmount = new TokenAmount(\n            inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n\n            getAmountOut(\n                inputAmount.toBigNumber(),\n                inputReserve,\n                outputReserve,\n                inputWeight,\n                outputWeight,\n                this.fee\n            )\n        )\n        // console.log(\"OA\", outputAmount.raw.toString())\n        if (outputAmount.raw.eq(ZERO)) {\n            throw new InsufficientInputAmountError()\n        }\n\n        return [\n            outputAmount,\n            new AmplifiedWeightedPair(\n                [inputAmount.token, inputAmount.token.equals(this.token0) ? this.token1 : this.token0], // tokens\n                [this.reserveOf(inputAmount.token).add(inputAmount.raw), this.reserveOf(outputAmount.token).sub(outputAmount.raw)], // reserves\n                [inputReserve.add(inputAmount.raw), outputReserve.sub(outputAmount.raw)], // virtual reserves\n                inputWeight,\n                this.ampBPS,\n                this.fee\n            )\n        ]\n    }\n\n    public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pool] {\n        invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n        console.log(\"-- this 0\", this.reserve0.raw, \"1\", this.reserve1.raw, \"out\", outputAmount.raw)\n        if (\n            this.reserve0.raw.eq(ZERO) ||\n            this.reserve1.raw.eq(ZERO) ||\n            outputAmount.raw.gte(this.reserveOf(outputAmount.token))\n        ) {\n            throw new Error(\"insufficcient reserves\")\n        }\n\n        const outputReserve = this.virtualReserveOf(outputAmount.token)\n        const inputReserve = this.virtualReserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n        const outputWeight = this.weightOf(outputAmount.token)\n        const inputWeight = this.weightOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n        const inputAmount = new TokenAmount(\n            outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n            getAmountIn(\n                outputAmount.toBigNumber(),\n                inputReserve,\n                outputReserve,\n                inputWeight,\n                outputWeight,\n                this.fee\n            )\n        )\n\n        return [\n            inputAmount,\n            new AmplifiedWeightedPair(\n                [inputAmount.token, outputAmount.token],\n                [this.reserveOf(inputAmount.token).add(inputAmount.raw), this.reserveOf(outputAmount.token).sub(outputAmount.raw)],\n                [inputReserve.add(inputAmount.raw), outputReserve.sub(outputAmount.raw)],\n                inputWeight,\n                this.ampBPS,\n                this.fee\n            )\n        ]\n    }\n\n}\n\n\n","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\n\nimport { Contract } from '@ethersproject/contracts'\nimport { ethers } from 'ethers'\nimport { WeightedSwapStorage } from '../../calculators/weightedSwapStorage'\nimport {\n  BigintIsh,\n} from '../../../constants'\nimport weightedPoolABI from '../../../abis/WeightedPool.json'\nimport { Token } from '../../token'\nimport { TokenAmount } from '../../fractions/tokenAmount'\nimport { ZERO } from '../../calculators/LogExpMath'\nimport { calculateRemoveLiquidityExactIn, calculateRemoveLiquidityOneTokenExactIn, calculateSwapGivenIn, calculateSwapGivenOut, calculateTokenAmount } from '../../calculators/WeightedPoolLib'\nimport { Pool } from '../pool'\nimport { Price } from '../../fractions'\nimport { ChainId } from '../../currency'\n// const ZERO = BigNumber.from(0)\n\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport class WeightedPool extends Pool {\n  public readonly address: string\n  // the only LP token\n  public readonly liquidityToken: Token\n  // the index-token map \n  public readonly tokens: Token[]\n  public tokenBalances: BigNumber[]\n  public swapStorage: WeightedSwapStorage\n  public _name: string\n\n  public lpTotalSupply: BigNumber\n\n  public constructor(\n    poolAddress: string,\n    tokens: Token[],\n    tokenBalances: BigNumber[],\n    swapStorage: WeightedSwapStorage,\n    lpTotalSupply: BigNumber,\n    lpAddress?: string\n  ) {\n    super()\n    this.tokens = tokens\n    this.tokenBalances = tokenBalances\n    this.address = ethers.utils.getAddress(poolAddress)\n    this.lpTotalSupply = lpTotalSupply\n    this.swapStorage = swapStorage\n    this.tokens = tokens\n    this.tokenBalances = tokenBalances\n    this.liquidityToken = new Token(\n      tokens[0].chainId,\n      lpAddress ?? '0x0000000000000000000000000000000000000001',\n      18,\n      'Requiem-LP',\n      'Requiem Swap LPs'\n    )\n\n    for (let i = 0; i < Object.values(this.tokens).length; i++) {\n      invariant(tokens[i].address != ethers.constants.AddressZero, \"invalidTokenAddress\");\n      invariant(tokens[i].decimals <= 18, \"invalidDecimals\");\n      invariant(tokens[i].chainId === tokens[0].chainId, 'INVALID TOKENS')\n    }\n\n    this._name = 'Weighted Pool'\n  }\n\n  public static mock() {\n    return new WeightedPool('', [new Token(1, '0x0000000000000000000000000000000000000001', 6, 'Mock USDC', 'MUSDC')], [ZERO], WeightedSwapStorage.mock(), ZERO)\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    let res = false\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      res || token.equals(this.tokens[i])\n    }\n\n    return res\n  }\n\n  // maps the index to the token in the stablePool\n  public tokenFromIndex(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public indexFromToken(token: Token): number {\n    for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n      if (token.equals(this.tokens[index])) {\n        return index\n      }\n    }\n    throw new Error('token not in pool');\n  }\n\n  // calculates the output amount usingn the input for the swableSwap\n  // requires the view on a contract as manual calculation on the frontend would\n  // be inefficient\n  public async calculateSwapViaPing(\n    inToken: Token,\n    outToken: Token,\n    inAmount: BigNumber | BigintIsh,\n    // chainId: number,\n    provider: ethers.Signer | ethers.providers.Provider): Promise<BigintIsh> {\n\n    const outAmount: BigintIsh = await new Contract(\n      '0xCc62754F15f7F35E4c58Ce6aD5608fA575C5583E',\n      new ethers.utils.Interface(weightedPoolABI as any),\n      provider\n    ).calculateSwapGivenIn(inToken.address, outToken.address, inAmount)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenIn(\n    tokenIn: Token,\n    tokenOut: Token,\n    inAmount: BigNumber): BigNumber {\n\n    const outAmount: BigNumber = calculateSwapGivenIn(\n      this.swapStorage,\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      inAmount,\n      this.tokenBalances\n    )\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenOut(\n    tokenIn: Token,\n    tokenOut: Token,\n    outAmount: BigNumber): BigNumber {\n\n    const inAmount: BigNumber = calculateSwapGivenOut(\n      this.swapStorage,\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      outAmount,\n      this.tokenBalances,\n    )\n\n    return inAmount\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount, tokenOut: Token): TokenAmount {\n    const swap = this.calculateSwapGivenIn(inputAmount.token, tokenOut, inputAmount.raw)\n    return new TokenAmount(tokenOut, swap)\n  }\n\n  public getInputAmount(outputAmount: TokenAmount, tokenIn: Token): TokenAmount {\n    const swap = this.calculateSwapGivenOut(tokenIn, outputAmount.token, outputAmount.raw)\n    return new TokenAmount(tokenIn, swap.toBigInt())\n  }\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.tokens[0].chainId\n  }\n\n  public token(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public reserveOf(token: Token): BigNumber {\n    invariant(this.involvesToken(token), 'TOKEN')\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      if (token.equals(this.tokens[i]))\n        return this.tokenBalances[i]\n    }\n    return BigNumber.from(0)\n  }\n\n  public calculateRemoveLiquidity(amountLp: BigNumber): BigNumber[] {\n    return calculateRemoveLiquidityExactIn(\n      this.swapStorage,\n      amountLp,\n      this.lpTotalSupply,\n      this.tokenBalances\n    ).map((x, i) => x.div(this.swapStorage.tokenMultipliers[i]))\n  }\n\n  public calculateRemoveLiquidityOneToken(amount: BigNumber, index: number): { amountOut: BigNumber, swapFee: BigNumber } {\n    const { amountOut, swapFee } = calculateRemoveLiquidityOneTokenExactIn(\n      this.swapStorage,\n      index,\n      amount,\n      this.lpTotalSupply,\n      this.tokenBalances\n    )\n    return {\n      amountOut: amountOut.div(this.swapStorage.tokenMultipliers[index]),\n      swapFee\n    }\n  }\n\n  public getLiquidityAmount(amounts: BigNumber[], deposit: boolean) {\n    return calculateTokenAmount(\n      this.swapStorage,\n      amounts,\n      this.lpTotalSupply,\n      deposit,\n      this.tokenBalances,\n    )\n  }\n\n  public getLiquidityValue(outIndex: number, userBalances: BigNumber[]): TokenAmount {\n    let amount = BigNumber.from(0)\n    for (let i = 0; i < userBalances.length; i++) {\n      if (i !== outIndex)\n        amount = amount.add(this.calculateSwapGivenIn(this.tokens[i], this.tokens[outIndex], userBalances[i]))\n    }\n    amount = amount.add(userBalances[outIndex])\n    return new TokenAmount(this.tokens[outIndex], amount)\n  }\n\n  public setSwapStorage(swapStorage: WeightedSwapStorage) {\n    this.swapStorage = swapStorage\n  }\n\n  public setTokenBalances(tokenBalances: BigNumber[]) {\n    this.tokenBalances = tokenBalances\n  }\n\n  public setLpTotalSupply(totalSupply: BigNumber) {\n    this.lpTotalSupply = totalSupply\n  }\n\n  public setBalanceValueByIndex(index: number, newBalance: BigNumber) {\n    this.tokenBalances[index] = newBalance\n  }\n\n  public setBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? tokenAmount.toBigNumber() : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public addBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].add(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public subtractBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].sub(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public clone(): WeightedPool {\n    return new WeightedPool(\n      this.address,\n      this.tokens,\n      this.tokenBalances,\n      this.swapStorage,\n      this.lpTotalSupply\n    )\n  }\n\n  public poolPrice(tokenIn: Token, tokenOut: Token): Price {\n    const inIndex = this.indexFromToken(tokenIn)\n    const outIndex = this.indexFromToken(tokenOut)\n    return new Price(\n      tokenIn,\n      tokenOut,\n      this.swapStorage.normalizedWeights[outIndex].mul(this.tokenBalances[inIndex]),\n      this.swapStorage.normalizedWeights[inIndex].mul(this.tokenBalances[outIndex])\n    )\n  }\n\n  public poolPriceBases(tokenIn: Token, tokenOut: Token): { priceBaseIn: BigNumber; priceBaseOut: BigNumber; } {\n    const inIndex = this.indexFromToken(tokenIn)\n    const outIndex = this.indexFromToken(tokenOut)\n    return {\n      priceBaseIn: this.swapStorage.normalizedWeights[outIndex].mul(this.tokenBalances[inIndex]),\n      priceBaseOut: this.swapStorage.normalizedWeights[inIndex].mul(this.tokenBalances[outIndex])\n    }\n  }\n}\n","import { BigNumber } from 'ethers'\nimport invariant from 'tiny-invariant'\nimport { StableSwapStorage } from './stableSwapStorage'\n\nconst MAX_ITERATION = 256\nexport const A_PRECISION = BigNumber.from(100)\nconst FEE_DENOMINATOR = BigNumber.from(1e10)\nconst ONE = BigNumber.from(1)\n\nexport function _xp(balances: BigNumber[], rates: BigNumber[]): BigNumber[] {\n    let result = []\n    for (let i = 0; i < balances.length; i++) {\n        result.push(rates[i].mul(balances[i]))\n    }\n    return result\n}\n\n\nexport function _getAPrecise(blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage\n): BigNumber {\n    if (blockTimestamp.gte(swapStorage.futureATime)) {\n        return swapStorage.futureA;\n    }\n\n    if (swapStorage.futureA.gt(swapStorage.initialA)) {\n        return swapStorage.initialA.add(\n            swapStorage.futureA.sub(swapStorage.initialA).mul(blockTimestamp.sub(swapStorage.initialATime)).div(\n                swapStorage.futureATime.sub(swapStorage.initialATime)))\n    }\n\n    return swapStorage.initialA.sub(swapStorage.initialA.sub(swapStorage.futureA).mul(blockTimestamp.sub(swapStorage.initialATime))).div(\n        swapStorage.futureATime.sub(swapStorage.initialATime))\n}\n\nexport function _sumOf(x: BigNumber[]): BigNumber {\n    let sum = BigNumber.from(0);\n    for (let i = 0; i < x.length; i++) {\n        sum = sum.add(x[i])\n    }\n    return sum\n}\n\n\nexport function _distance(x: BigNumber, y: BigNumber): BigNumber {\n    return x.gt(y) ? x.sub(y) : y.sub(x)\n}\n\n/**\n * Calculate D for *NORMALIZED* balances of each tokens\n * @param xp normalized balances of token\n */\nexport function _getD(xp: BigNumber[], amp: BigNumber): BigNumber {\n    const nCoins = xp.length;\n    let sum = _sumOf(xp)\n    if (sum.eq(0)) {\n        return BigNumber.from(0)\n    }\n\n    let Dprev = BigNumber.from(0)\n    let D = sum;\n    let Ann = amp.mul(nCoins)\n\n    for (let i = 0; i < MAX_ITERATION; i++) {\n        let D_P = D;\n        for (let j = 0; j < xp.length; j++) {\n            D_P = D_P.mul(D).div(xp[j].mul(nCoins))\n        }\n\n        Dprev = D;\n        D = ((Ann.mul(sum)).div(A_PRECISION).add(D_P.mul(nCoins)).mul(D)).div(\n            ((Ann.sub(A_PRECISION)).mul(D).div(A_PRECISION)).add(D_P.mul(nCoins + 1)))\n\n        if (_distance(D, Dprev).lte(1)) {\n            return D;\n        }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    invariant(\"invariantCalculationFailed\");\n    return D\n}\n\nexport function _getY(\n    inIndex: number,\n    outIndex: number,\n    inBalance: BigNumber,\n    // self, shoudl be replaced with swapStorage object\n    blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage,\n    normalizedBalances: BigNumber[]\n\n): BigNumber {\n    invariant(inIndex != outIndex, \"sameToken\");\n    const nCoins = normalizedBalances.length;\n    invariant(inIndex < nCoins && outIndex < nCoins, \"indexOutOfRange\");\n\n    let amp = _getAPrecise(blockTimestamp, swapStorage);\n    let Ann = amp.mul(nCoins)\n    let D = _getD(normalizedBalances, amp);\n    let sum = BigNumber.from(0) // sum of new balances except output token\n    let c = D;\n    for (let i = 0; i < nCoins; i++) {\n        if (i == outIndex) {\n            continue;\n        }\n\n        let x = i == inIndex ? inBalance : normalizedBalances[i];\n        sum = sum.add(x)\n        c = (c.mul(D)).div(x.mul(nCoins))\n    }\n\n    c = c.mul(D.mul(A_PRECISION)).div(Ann.mul(nCoins))\n    let b = sum.add(D.mul(A_PRECISION).div(Ann))\n\n    let lastY = BigNumber.from(0)\n    let y = D;\n    for (let index = 0; index < MAX_ITERATION; index++) {\n        lastY = y;\n        y = ((y.mul(y)).add(c)).div(y.mul(2).add(b).sub(D))\n        if (_distance(lastY, y).lte(1)) {\n            return y;\n        }\n    }\n\n    invariant(\"yCalculationFailed\")\n    return BigNumber.from(0)\n}\n\nexport function calculateSwapGivenIn(inIndex: number, outIndex: number, inAmount: BigNumber, // standard fields\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage\n): BigNumber {\n    let normalizedBalances = _xp(balances, swapStorage.tokenMultipliers)\n    let newInBalance = normalizedBalances[inIndex].add(inAmount.mul(swapStorage.tokenMultipliers[inIndex]))\n    let outBalance = _getY(\n        inIndex,\n        outIndex,\n        newInBalance,\n        blockTimestamp,\n        swapStorage,\n        normalizedBalances\n    )\n\n    let outAmount = ((normalizedBalances[outIndex].sub(outBalance)).sub(ONE)).div(swapStorage.tokenMultipliers[outIndex])\n    let _fee = swapStorage.fee.mul(outAmount).div(FEE_DENOMINATOR)\n    return outAmount.sub(_fee)\n}\n\nexport function calculateSwapGivenOut(inIndex: number, outIndex: number, outAmount: BigNumber, // standard fields\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage\n): BigNumber {\n\n    let normalizedBalances = _xp(balances, swapStorage.tokenMultipliers)\n\n    let _amountOutInclFee = outAmount.mul(FEE_DENOMINATOR).div(FEE_DENOMINATOR.sub(swapStorage.fee));\n    let newOutBalance = normalizedBalances[outIndex].sub(_amountOutInclFee.mul(swapStorage.tokenMultipliers[outIndex]));\n\n    let inBalance = _getY(\n        outIndex,\n        inIndex,\n        newOutBalance,\n        blockTimestamp,\n        swapStorage,\n        normalizedBalances\n    )\n\n    const inAmount = ((inBalance.sub(normalizedBalances[inIndex]).sub(ONE)).div(swapStorage.tokenMultipliers[inIndex])).add(ONE)\n    return inAmount;\n}\n\n// function to calculate the amounts of stables from the amounts of LP\nexport function _calculateRemoveLiquidity(\n    amount: BigNumber,\n    swapStorage: StableSwapStorage,\n    totalSupply: BigNumber,\n    currentWithdrawFee: BigNumber,\n    balances: BigNumber[]\n): BigNumber[] {\n\n    invariant(amount.lte(totalSupply), \"Cannot exceed total supply\");\n\n    let feeAdjustedAmount = amount.mul(FEE_DENOMINATOR.sub(currentWithdrawFee)).div(\n        FEE_DENOMINATOR)\n\n    let amounts = []\n\n    for (let i = 0; i < swapStorage.tokenMultipliers.length; i++) {\n        amounts.push((balances[i].mul(feeAdjustedAmount)).div(totalSupply))\n    }\n    return amounts;\n}\n\n\nfunction _getYD(\n    A: BigNumber,\n    index: number,\n    xp: BigNumber[],\n    D: BigNumber\n): BigNumber {\n    let nCoins = xp.length;\n    invariant(index < nCoins, \"INDEX\");\n    let Ann = A.mul(nCoins)\n    let c = D;\n    let s = BigNumber.from(0)\n    let _x = BigNumber.from(0)\n    let yPrev = BigNumber.from(0)\n\n    for (let i = 0; i < nCoins; i++) {\n        if (i == index) {\n            continue;\n        }\n        _x = xp[i];\n        s = s.add(_x)\n        c = (c.mul(D)).div(_x.mul(nCoins))\n    }\n\n    c = (c.mul(D).mul(A_PRECISION)).div(Ann.mul(nCoins))\n    let b = s.add(D.mul(A_PRECISION).div(Ann))\n    let y = D;\n\n    for (let i = 0; i < MAX_ITERATION; i++) {\n        yPrev = y;\n        y = ((y.mul(y)).add(c)).div(((y.mul(2)).add(b)).sub(D))\n        if (_distance(yPrev, y).lt(1)) {\n            return y;\n        }\n    }\n    invariant(\"invariantCalculationFailed\")\n    return BigNumber.from(0)\n}\n\nfunction _feePerToken(swapStorage: StableSwapStorage): BigNumber {\n    let nCoins = swapStorage.tokenMultipliers.length;\n    return (swapStorage.fee.mul(nCoins)).div(4 * (nCoins - 1));\n}\n\n\nexport function _calculateRemoveLiquidityOneToken(\n    swapStorage: StableSwapStorage,\n    tokenAmount: BigNumber,\n    index: number,\n    blockTimestamp: BigNumber,\n    balances: BigNumber[],\n    totalSupply: BigNumber,\n    currentWithdrawFee: BigNumber\n): { [returnVal: string]: BigNumber }// {dy:BigNumber, fee:BigNumber} \n{\n    invariant(index < swapStorage.tokenMultipliers.length, \"indexOutOfRange\")\n\n    let amp = _getAPrecise(blockTimestamp, swapStorage)\n    let xp = _xp(balances, swapStorage.tokenMultipliers)\n    let D0 = _getD(xp, amp);\n    let D1 = D0.sub((tokenAmount.mul(D0)).div(totalSupply))\n    let newY = _getYD(amp, index, xp, D1);\n    let reducedXP = xp;\n    let _fee = _feePerToken(swapStorage);\n\n    for (let i = 0; i < swapStorage.tokenMultipliers.length; i++) {\n        let expectedDx = BigNumber.from(0)\n        if (i == index) {\n            expectedDx = ((xp[i].mul(D1)).div(D0)).sub(newY)\n        } else {\n            expectedDx = xp[i].sub(xp[i].mul(D1).div(D0))\n        }\n        reducedXP[i] = reducedXP[i].sub(_fee.mul(expectedDx).div(FEE_DENOMINATOR))\n    }\n\n    let dy = reducedXP[index].sub(_getYD(amp, index, reducedXP, D1))\n    dy = (dy.sub(1)).div(swapStorage.tokenMultipliers[index])\n    let fee = ((xp[index].sub(newY)).div(swapStorage.tokenMultipliers[index])).sub(dy)\n    dy = dy.mul(FEE_DENOMINATOR.sub(currentWithdrawFee)).div(FEE_DENOMINATOR)\n    return { \"dy\": dy, \"fee\": fee }\n}\n\n\n/**\n * Estimate amount of LP token minted or burned at deposit or withdrawal\n * without taking fees into account\n */\nexport function _calculateTokenAmount(\n    swapStorage: StableSwapStorage,\n    amounts: BigNumber[],\n    deposit: boolean,\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    totalSupply: BigNumber\n): BigNumber {\n    let nCoins = swapStorage.tokenMultipliers.length;\n    invariant(amounts.length == nCoins, \"invalidAmountsLength\");\n    let amp = _getAPrecise(blockTimestamp, swapStorage);\n    let D0 = _getD(_xp(balances, swapStorage.tokenMultipliers), amp);\n\n    let newBalances = balances;\n    for (let i = 0; i < nCoins; i++) {\n        if (deposit) {\n            newBalances[i] = newBalances[i].add(amounts[i])\n        } else {\n            newBalances[i] = newBalances[i].sub(amounts[i])\n        }\n    }\n\n    let D1 = _getD(_xp(newBalances, swapStorage.tokenMultipliers), amp);\n\n\n    if (totalSupply.eq(0)) {\n        return D1; // first depositor take it all\n    }\n\n    let diff = deposit ? D1.sub(D0) : D0.sub(D1)\n    return (diff.mul(totalSupply)).div(D0)\n}","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\nimport {\n  _getAPrecise,\n  calculateSwapGivenIn,\n  _calculateRemoveLiquidity,\n  _calculateRemoveLiquidityOneToken,\n  _calculateTokenAmount,\n  calculateSwapGivenOut\n} from '../../calculators/stableCalc'\nimport { Contract } from '@ethersproject/contracts'\nimport { ethers } from 'ethers'\nimport { StableSwapStorage } from '../../calculators/stableSwapStorage'\nimport {\n  BigintIsh,\n  STABLE_POOL_ADDRESS,\n  STABLE_POOL_LP_ADDRESS\n} from '../../../constants'\nimport StableSwap from '../../../abis/RequiemStableSwap.json'\nimport { Token } from '../../token'\nimport { TokenAmount } from '../../fractions/tokenAmount'\nimport { Pool } from '../pool'\nimport { Price } from '../../fractions'\n\n// const ZERO = BigNumber.from(0)\n\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport class StablePool extends Pool {\n  public readonly address: string\n  // the only LP token\n  public readonly liquidityToken: Token\n  // the index-token map \n  public readonly tokens: Token[]\n  public tokenBalances: BigNumber[]\n  public _A: BigNumber\n  public swapStorage: StableSwapStorage\n  // public readonly rates: BigNumber[]\n  public blockTimestamp: BigNumber\n\n  public lpTotalSupply: BigNumber\n  public currentWithdrawFee: BigNumber\n  public _name: string\n\n  public constructor(\n    tokens: Token[],\n    tokenBalances: BigNumber[],\n    _A: BigNumber,\n    swapStorage: StableSwapStorage,\n    blockTimestamp: number,\n    lpTotalSupply: BigNumber,\n    currentWithdrawFee: BigNumber,\n    poolAddress: string,\n    lpAddress?: string\n  ) {\n    super()\n    this.tokens = tokens\n    this.currentWithdrawFee = currentWithdrawFee\n    this.lpTotalSupply = lpTotalSupply\n    this.swapStorage = swapStorage\n    this.blockTimestamp = BigNumber.from(blockTimestamp)\n    this.tokenBalances = tokenBalances\n    this._A = _A\n    this.liquidityToken = new Token(\n      tokens[0].chainId,\n      lpAddress ?? STABLE_POOL_LP_ADDRESS[tokens[0].chainId],\n      18,\n      'RequiemStable-LP',\n      'Requiem StableSwap LPs'\n    )\n    this.address = ethers.utils.getAddress(poolAddress)\n\n    for (let i = 0; i < Object.values(this.tokens).length; i++) {\n      invariant(tokens[i].address != ethers.constants.AddressZero, \"invalidTokenAddress\");\n      invariant(tokens[i].decimals <= 18, \"invalidDecimals\");\n      invariant(tokens[i].chainId === tokens[0].chainId, 'INVALID TOKENS')\n    }\n\n    this._name = 'Stable Pool'\n  }\n\n  public static mock() {\n    const dummy = BigNumber.from(0)\n    return new StablePool([new Token(1, '0x0000000000000000000000000000000000000001', 6, 'Mock USDC', 'MUSDC')], [dummy], dummy, StableSwapStorage.mock(), 0, dummy, dummy, '0x0000000000000000000000000000000000000001')\n  }\n\n  public getAddressForRouter(): string {\n    return STABLE_POOL_ADDRESS[this.tokens[0].chainId]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    let res = false\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      res || token.equals(this.tokens[i])\n    }\n\n    return res\n  }\n\n  public set setCurrentWithdrawFee(feeToSet: BigNumber) {\n    this.currentWithdrawFee = feeToSet\n  }\n\n  // maps the index to the token in the stablePool\n  public tokenFromIndex(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public indexFromToken(token: Token): number {\n    for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n      if (token.equals(this.tokens[index])) {\n        return index\n      }\n    }\n    throw new Error('token not in pool');\n  }\n\n  public getBalances(): BigNumber[] {\n    return Object.keys(this.tokens).map((_, index) => (this.tokenBalances[index]))\n  }\n\n  // calculates the output amount usingn the input for the swableSwap\n  // requires the view on a contract as manual calculation on the frontend would\n  // be inefficient\n  public async calculateSwapViaPing(\n    inToken: Token,\n    outToken: Token,\n    inAmount: BigNumber | BigintIsh,\n    provider: ethers.Signer | ethers.providers.Provider): Promise<BigintIsh> {\n\n    const outAmount: BigintIsh = await new Contract(this.address, new ethers.utils.Interface(StableSwap), provider).calculateSwap(inToken.address, outToken.address, inAmount)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenIn(\n    tokenIn: Token,\n    tokenOut: Token,\n    inAmount: BigNumber): BigNumber {\n\n    // if (this.getBalances()[inIndex].lte(inAmount)) // || inAmount.eq(ZERO))\n    //   return ZERO\n\n    const outAmount: BigNumber = calculateSwapGivenIn(\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      inAmount,\n      this.tokenBalances,\n      this.blockTimestamp,\n      this.swapStorage)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenOut(\n    tokenIn: Token,\n    tokenOut: Token,\n    outAmount: BigNumber): BigNumber {\n\n    // if (this.getBalances()[outIndex].lte(outAmount)) // || outAmount.eq(ZERO))\n    //   return ZERO\n\n    const inAmount: BigNumber = calculateSwapGivenOut(\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      outAmount,\n      this.tokenBalances,\n      this.blockTimestamp,\n      this.swapStorage)\n\n    return inAmount\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount, tokenOut: Token): TokenAmount {\n    const swap = this.calculateSwapGivenIn(inputAmount.token, tokenOut, inputAmount.toBigNumber())\n    return new TokenAmount(tokenOut, swap.toBigInt())\n  }\n\n  public getInputAmount(outputAmount: TokenAmount, tokenIn: Token): TokenAmount {\n    const swap = this.calculateSwapGivenOut(tokenIn, outputAmount.token, outputAmount.toBigNumber())\n    return new TokenAmount(tokenIn, swap)\n  }\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): number {\n    return this.tokens[0].chainId\n  }\n\n  public token(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public reserveOf(token: Token): BigNumber {\n    invariant(this.involvesToken(token), 'TOKEN')\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      if (token.equals(this.tokens[i]))\n        return this.tokenBalances[i]\n    }\n    return BigNumber.from(0)\n  }\n\n  public calculateRemoveLiquidity(amountLp: BigNumber): BigNumber[] {\n    return _calculateRemoveLiquidity(\n      amountLp,\n      this.swapStorage,\n      this.lpTotalSupply,\n      this.currentWithdrawFee,\n      this.getBalances()\n    )\n  }\n\n  public calculateRemoveLiquidityOneToken(amount: BigNumber, index: number): { [returnVal: string]: BigNumber } {\n    return _calculateRemoveLiquidityOneToken(\n      this.swapStorage,\n      amount,\n      index,\n      this.blockTimestamp,\n      this.getBalances(),\n      this.lpTotalSupply,\n      this.currentWithdrawFee\n    )\n  }\n\n  public getLiquidityAmount(amounts: BigNumber[], deposit: boolean) {\n    return _calculateTokenAmount(\n      this.swapStorage,\n      amounts,\n      deposit,\n      this.getBalances(),\n      this.blockTimestamp,\n      this.lpTotalSupply\n    )\n  }\n\n  public getLiquidityValue(outIndex: number, userBalances: BigNumber[]): TokenAmount {\n    let amount = BigNumber.from(0)\n    for (let i = 0; i < userBalances.length; i++) {\n      if (i !== outIndex)\n        amount = amount.add(this.calculateSwapGivenIn(this.tokens[i], this.tokens[outIndex], userBalances[i]))\n    }\n    amount = amount.add(userBalances[outIndex])\n    return new TokenAmount(this.tokens[outIndex], amount.toBigInt())\n  }\n\n  public setSwapStorage(swapStorage: StableSwapStorage) {\n    this.swapStorage = swapStorage\n  }\n\n  public setTokenBalances(tokenBalances: BigNumber[]) {\n    this.tokenBalances = tokenBalances\n  }\n\n  public setBlockTimestamp(blockTimestamp: BigNumber) {\n    this.blockTimestamp = blockTimestamp\n  }\n\n  public setLpTotalSupply(totalSupply: BigNumber) {\n    this.lpTotalSupply = totalSupply\n  }\n\n  public setBalanceValueByIndex(index: number, newBalance: BigNumber) {\n    this.tokenBalances[index] = newBalance\n  }\n\n  public setBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? tokenAmount.toBigNumber() : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public addBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].add(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public subtractBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].sub(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public clone(): StablePool {\n    return new StablePool(\n      this.tokens, this.tokenBalances, this._A, this.swapStorage, this.blockTimestamp.toNumber(), this.lpTotalSupply, this.currentWithdrawFee, this.address\n    )\n  }\n\n  public poolPrice(tokenIn: Token, tokenOut: Token): Price {\n    const virtualIn = BigNumber.from(this.tokenBalances[this.indexFromToken(tokenIn)]).div(10000)\n    return new Price(tokenIn, tokenOut, virtualIn, this.calculateSwapGivenIn(tokenIn, tokenOut, virtualIn))\n  }\n\n\n  public poolPriceBases(tokenIn: Token, tokenOut: Token): { priceBaseIn: BigNumber; priceBaseOut: BigNumber; } {\n    const virtualIn = this.tokenBalances[this.indexFromToken(tokenIn)].div(10000)\n    return {\n      priceBaseIn: virtualIn,\n      priceBaseOut: this.calculateSwapGivenIn(tokenIn, tokenOut, virtualIn)\n    }\n  }\n} \n","import { BigNumber } from \"ethers\";\nimport invariant from \"tiny-invariant\";\nimport { ChainId } from \"../currency\";\nimport { TokenAmount } from \"../fractions\";\nimport { Token } from \"../token\";\nimport { Pool, PoolDictionary } from \"./pool\";\n\n\n// class that stores data for a Pair to swap through\n// does not store any pricing or calculation functions - these are used through the poolId which is taken from a pool dictionary\n// these pools are then used for pricing\nexport class SwapData {\n\n    public readonly tokenIn: Token\n    public readonly tokenOut: Token\n    public readonly poolRef: string\n\n    // these are for saving the pool price with not using the price class as it would store the token object twice\n    public priceBaseIn: BigNumber | undefined\n    public priceBaseOut: BigNumber | undefined\n\n    constructor(tokenIn: Token, tokenOut: Token, poolRef: string) {\n        // invariant(!tokenIn.equals(tokenOut), 'TOKEN')\n        this.tokenIn = tokenIn\n        this.tokenOut = tokenOut\n        this.poolRef = poolRef\n\n    }\n\n    public calculateSwapGivenOut(\n        tokenOutAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        return new TokenAmount(this.tokenIn, poolDict[this.poolRef].calculateSwapGivenOut(this.tokenIn, tokenOutAmount.token, tokenOutAmount.raw))\n    }\n\n    public calculateSwapGivenIn(\n        tokenInAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        return new TokenAmount(this.tokenOut, poolDict[this.poolRef].calculateSwapGivenIn(tokenInAmount.token, this.tokenOut, tokenInAmount.raw))\n    }\n\n    public get chainId(): ChainId { return this.tokenIn.chainId }\n\n    public involvesToken(token: Token) {\n        return this.tokenIn.address === token.address || this.tokenOut.address === token.address\n    }\n\n    /**\n     *  Calculate the mid price for a pool - if possible\n     * @param tokenIn in token for price\n     * @param tokenOut out/ quote token for price\n     * @param poolDict pool dictionary to fetch the underlying pool from\n     * @returns price object\n     */\n    public poolPrice(poolDict: { [id: string]: Pool }) {\n        return poolDict[this.poolRef].poolPrice(this.tokenIn, this.tokenOut)\n    }\n\n\n    /**\n * @param pool input pool to generate pair from\n * @returns pair route\n */\n    public static singleDataFromPool(tokenIn: Token, tokenOut: Token, pool: Pool): SwapData {\n        invariant(pool.tokens.includes(tokenIn) && pool.tokens.includes(tokenOut))\n        return new SwapData(tokenIn, tokenOut, pool.address)\n    }\n\n    public fetchPoolPrice(poolDict: PoolDictionary) {\n        const { priceBaseIn, priceBaseOut } = poolDict[this.poolRef].poolPriceBases(this.tokenIn, this.tokenOut)\n        this.priceBaseIn = priceBaseIn\n        this.priceBaseOut = priceBaseOut\n    }\n\n}","import { ChainId } from \"../currency\";\nimport { TokenAmount } from \"../fractions\";\nimport { Token } from \"../token\";\nimport { Pool } from \"./pool\";\nimport { SwapData } from \"./swapData\";\n\n\n// class that stores data for a Pair to swap through\n// does not store any pricing or calculation functions - these are used through the poolId which is taken from a pool dictionary\n// these pools are then used for pricing\nexport class PairData {\n\n    public readonly token0: Token\n    public readonly token1: Token\n    public readonly poolRef: string\n    constructor(token0: Token, token1: Token, poolRef: string) {\n        this.token0 = token0\n        this.token1 = token1\n        this.poolRef = poolRef\n\n    }\n\n    public calculateSwapGivenOut(\n        tokenOutAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        const tokenIn = tokenOutAmount.token.equals(this.token0) ? this.token1 : this.token0\n        return new TokenAmount(tokenIn, poolDict[this.poolRef].calculateSwapGivenOut(tokenIn, tokenOutAmount.token, tokenOutAmount.raw))\n    }\n\n    public calculateSwapGivenIn(\n        tokenInAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        const tokenOut = tokenInAmount.token.equals(this.token0) ? this.token1 : this.token0\n        return new TokenAmount(tokenOut, poolDict[this.poolRef].calculateSwapGivenIn(tokenInAmount.token, tokenOut, tokenInAmount.raw))\n    }\n\n    public get chainId(): ChainId { return this.token0.chainId }\n\n    public involvesToken(token: Token) {\n        return this.token0.address === token.address || this.token1.address === token.address\n    }\n\n    /**\n     *  Calculate the mid price for a pool - if possible\n     * @param tokenIn in token for price\n     * @param tokenOut out/ quote token for price\n     * @param poolDict pool dictionary to fetch the underlying pool from\n     * @returns price object\n     */\n    public poolPrice(tokenIn: Token, tokenOut: Token, poolDict: { [id: string]: Pool }) {\n        return poolDict[this.poolRef].poolPrice(tokenIn, tokenOut)\n    }\n\n    /**\n     * Pools with n > 2 tokens generate (n^2-n)/2 possible pair routes to trade\n     * The fubnction creates these pair routes\n     * @param pool input pool to generate pairs from\n     * @returns pair routes\n     */\n    public static dataFromPool(pool: Pool): PairData[] {\n        let pairData = []\n\n        for (let i = 0; i < pool.tokenBalances.length; i++) {\n            for (let j = 0; j < i; j++) {\n                pairData.push(new PairData(pool.tokens[i], pool.tokens[j], pool.address))\n            }\n        }\n        return pairData\n    }\n\n    /**\n     * @param pool input pool to generate pair from\n     * @returns pair route\n     */\n    public static singleDataFromPool(index0: number, index1: number, pool: Pool): PairData {\n        return new PairData(pool.tokens[index0], pool.tokens[index1], pool.address)\n    }\n\n    /**\n     * Pools with n > 2 tokens generate (n^2-n)/2 possible pair routes to trade\n     * The fubnction creates these pair routes\n     * @param pool input pool to generate pairs from\n     * @returns pair routes\n     */\n    public static dataFromPools(pools: Pool[]): PairData[] {\n        let pairData = []\n        for (let k = 0; k < pools.length; k++) {\n            const pool = pools[k]\n            for (let i = 0; i < pool.tokenBalances.length; i++) {\n                for (let j = 0; j < i; j++) {\n                    pairData.push(new PairData(pool.tokens[i], pool.tokens[j], pool.address))\n                }\n            }\n        }\n        return pairData\n    }\n\n    /**\n     * Converts unordered pair to directioned swap pair\n     * @param tokenIn in token, the other will be tokenOut\n     * @returns SwapData object\n     */\n    public toSwapDataFrom(tokenIn: Token): SwapData {\n        return new SwapData(tokenIn, this.token0.equals(tokenIn) ? this.token1 : this.token0, this.poolRef)\n    }\n\n    /**\n    * Converts unordered pair to directioned swap pair\n    * @param tokenIn in token, the other will be tokenOut\n    * @returns SwapData object\n    */\n    public toSwapDataTo(tokenOut: Token): SwapData {\n        return new SwapData(this.token0.equals(tokenOut) ? this.token1 : this.token0, tokenOut, this.poolRef)\n    }\n\n    /**\n     * Converts unordered swap pairs to swap route\n     * @param pairData input pair array - has to be a route to make sense\n     * @param tokenIn \n     * @returns \n     */\n    public static toSwapArrayFrom(pairData: PairData[], tokenIn: Token): SwapData[] {\n        let swaps = []\n        let currentIn = tokenIn\n        for (let i = 0; i < pairData.length; i++) {\n            const swap = pairData[i].toSwapDataFrom(currentIn)\n            swaps.push(swap)\n            currentIn = swap.tokenOut\n        }\n        return swaps\n    }\n\n    /**\n * Converts unordered swap pairs to swap route\n * @param pairData input pair array - has to be a route to make sense\n * @param tokenIn \n * @returns \n */\n    public static toSwapArrayTo(pairData: PairData[], tokenOut: Token): SwapData[] {\n        let swaps = new Array(pairData.length)\n        let currentOut = tokenOut\n        for (let i = pairData.length - 1; i >= 0; i--) {\n            const swap = pairData[i].toSwapDataTo(currentOut)\n            swaps[i] = swap\n            currentOut = swap.tokenIn\n        }\n        return swaps\n    }\n\n\n}","import { BigNumber } from 'ethers'\nimport { Token } from '../token';\nimport {  AmplifiedWeightedPair } from '../pools/weightedPair';\n\nconst ONE = BigNumber.from(1)\nconst TEN = BigNumber.from(10)\nconst TWO = BigNumber.from(2)\nconst SQRT2x100 = BigNumber.from('141421356237309504880');\nconst ONE_E18 = BigNumber.from('1000000000000000000')\n\n\nexport function sqrrt(a: BigNumber): BigNumber {\n    let c = ONE\n    if (a.gt(3)) {\n        c = a;\n        let b = a.div(TWO).add(ONE);\n        while (b < c) {\n            c = b;\n            b = (a.div(b).add(b)).div(TWO);\n        }\n    } else if (!a.eq(0)) {\n        c = ONE;\n    }\n    return c\n}\n\nexport function getTotalValue(pair: AmplifiedWeightedPair, payoutToken: Token): BigNumber {\n    const reserve0 = pair.reserve0\n    const reserve1 = pair.reserve1\n\n    const [reservesOther, weightPayoutToken, weightOther] = payoutToken.equals(pair.token0)\n        ? [reserve1, pair.weight0, pair.weight1]\n        : [reserve0, pair.weight1, pair.weight0]\n\n    return SQRT2x100.mul(reservesOther.toBigNumber()).div(\n        sqrrt(weightOther.mul(weightOther).add(weightPayoutToken.add(weightPayoutToken))\n        )).div(ONE_E18)\n}\n\n/**\n* - calculates the value in payoutToken of the input LP amount provided\n* @param _pair general pair that has the RequiemSwap interface implemented\n* @param amount_ the amount of LP to price in REQT\n*  - is consistent with the uniswapV2-type case \n*/\nexport function valuation(pair: AmplifiedWeightedPair, totalSupply: BigNumber, amount: BigNumber, payoutToken: Token) {\n    const totalValue = getTotalValue(pair, payoutToken);\n    return totalValue.mul(amount).div(totalSupply);\n}\n\n\n\n// markdown function for bond valuation\nexport function markdown(pair: AmplifiedWeightedPair, payoutToken: Token): BigNumber {\n    const [reservesOther, weightOther, weightPayoutToken] = payoutToken.equals(pair.token0)\n        ? [pair.reserve1.toBigNumber(), BigNumber.from(pair.weight1.toString()), BigNumber.from(pair.weight0.toString())]\n        : [pair.reserve0.toBigNumber(), BigNumber.from(pair.weight0.toString()), BigNumber.from(pair.weight1.toString())];\n\n    // adjusted markdown scaling up the reserve as the trading mechnism allows\n    // higher or lower valuation for payoutToken reserve\n    return reservesOther.add(\n        weightOther.mul(reservesOther).div(weightPayoutToken)).mul(\n            TEN.pow(BigNumber.from((payoutToken.decimals))).div(\n                getTotalValue(pair, payoutToken)\n            )\n        )\n}","\n\nimport { BigNumber } from 'ethers'\nimport invariant from 'tiny-invariant';\n\nconst RESOLUTION = BigNumber.from(112);\nconst resPrec = BigNumber.from(2).pow(RESOLUTION)\nconst ZERO = BigNumber.from(0)\n// const Q112 = BigNumber.from('0x10000000000000000000000000000');\n// const Q224 = BigNumber.from('0x100000000000000000000000000000000000000000000000000000000');\n// const LOWER_MASK = BigNumber.from('0xffffffffffffffffffffffffffff'); // decimal of UQ*x112 (lower 112 bits)\n\nexport function decode(x: BigNumber) {\n    return x.div(RESOLUTION);\n}\n\nexport function decode112with18(x: BigNumber) {\n    return x.div(BigNumber.from('5192296858534827'))\n}\n\nexport function fraction(numerator: BigNumber, denominator: BigNumber) {\n\n    invariant(denominator.gt(ZERO), \"FixedPoint::fraction: division by zero\");\n    if (numerator.isZero()) return ZERO;\n\n    // if (numerator.lte(BigNumber.) <= type(uint144).max) {\n    const result = (numerator.mul(resPrec)).div(denominator)\n    //   require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n    return result;\n    // } else {\n    //    return numerator.mul(Q112).div(denominator);\n    // }\n}","import { BigNumber } from 'ethers'\nimport { Token } from '../token';\nimport {  AmplifiedWeightedPair } from '../pools/weightedPair';\nimport { valuation } from './bondCalculator';\n// import JSBI from 'jsbi';\nimport { fraction, decode112with18 } from './fixedPoint';\n\nconst ONE_E16 = BigNumber.from('10000000000000000')\nconst ONE_E18 = BigNumber.from('10000000000000000')\nconst ONE_E9 = BigNumber.from('1000000000')\n\nexport interface BondTerms {\n    controlVariable: BigNumber; // scaling variable for price\n    vesting: BigNumber; // in blocks\n    maxPayout: BigNumber; // in thousandths of a %. i.e. 500 = 0.5%\n    maxDebt: BigNumber;\n}\n\nexport function payoutFor(value: BigNumber, bondPrice: BigNumber): BigNumber {\n    return value.mul(ONE_E18.mul(ONE_E18)).div(bondPrice).div(ONE_E18)\n}\n\n\nexport function fullPayoutFor(\n    pair: AmplifiedWeightedPair,\n    currentDebt: BigNumber,\n    totalSupply: BigNumber,\n    amount: BigNumber,\n    payoutToken: Token,\n    terms: BondTerms\n): BigNumber {\n    const value = valuation(pair, totalSupply, amount, payoutToken)\n    const bondPrice_ = bondPrice(terms.controlVariable, totalSupply, currentDebt)\n    return payoutFor(value, bondPrice_)\n}\n\n\n/**\n *  @notice calculate current ratio of debt to REQT supply\n *  @return debtRatio_ uint\n */\nexport function debtRatio(totalSupply: BigNumber, currentDebt: BigNumber): BigNumber {\n\n    return decode112with18(fraction(currentDebt.mul(ONE_E9), totalSupply)).div(\n        ONE_E18);\n}\n\n\n/**\n *  @notice calculate current bond premium\n *  @return price_ uint\n */\nexport function bondPrice(controlVariable: BigNumber, totalSupply: BigNumber, currentDebt: BigNumber): BigNumber {\n    let price_ = (controlVariable.mul(debtRatio(totalSupply, currentDebt)).add(ONE_E18)).div(ONE_E16);\n    return price_\n}\n\n\n/**\n *  @notice calculate current bond premium\n *  @return price_ uint\n */\nexport function bondPriceUsingDebtRatio(controlVariable: BigNumber, debtRatio: BigNumber): BigNumber {\n    return controlVariable.mul(debtRatio).div(ONE_E18);\n\n}\n\nexport function fullPayoutForUsingDebtRatio(\n    pair: AmplifiedWeightedPair,\n    debtRatio: BigNumber,\n    totalSupply: BigNumber,\n    amount: BigNumber,\n    payoutToken: Token,\n    terms: BondTerms\n): BigNumber {\n    const value = valuation(pair, totalSupply, amount, payoutToken)\n    const bondPrice_ = bondPriceUsingDebtRatio(terms.controlVariable, debtRatio)\n    return payoutFor(value, bondPrice_)\n}","import invariant from 'tiny-invariant'\nimport { Pool, PoolDictionary } from './pools/pool'\nimport { ChainId, Currency, NETWORK_CCY } from './currency'\nimport { Token, WRAPPED_NETWORK_TOKENS } from './token'\nimport { Price } from './fractions/price'\nimport { PairData } from './pools/pairData'\n\n\n/**\n * \n * @param pools pools to generate pairData with, i.e. a 3-Pool generating the respective 6 pairs\n * @returns an array of the pairData\n */\nexport function pairDataFromPools(pools: Pool[]): PairData[] {\n  let pairData = PairData.dataFromPool(pools[0])\n  for (let i = 1; i < pools.length; i++) {\n    pairData = pairData.concat(PairData.dataFromPool(pools[i]))\n  }\n\n  return pairData\n}\n\n// new version of the route \n// the first verion to include the stable pool for less friction\nexport class Route {\n  public readonly pairData: PairData[]\n  public readonly path: Token[]\n  public readonly input: Currency\n  public readonly output: Currency\n  public readonly midPrice: Price\n\n  public constructor(poolDict: PoolDictionary, pairData: PairData[], input: Currency, output?: Currency) {\n    invariant(pairData.length > 0, 'pairData')\n\n    invariant(\n      (input instanceof Token && pairData[0].involvesToken(input)) ||\n      (input === NETWORK_CCY[pairData[0].chainId] && pairData[0].involvesToken(WRAPPED_NETWORK_TOKENS[pairData[0].chainId])),\n      'INPUT'\n    )\n    invariant(\n      typeof output === 'undefined' ||\n      (output instanceof Token && pairData[pairData.length - 1].involvesToken(output)) ||\n      (output === NETWORK_CCY[pairData[0].chainId] && pairData[pairData.length - 1].involvesToken(WRAPPED_NETWORK_TOKENS[pairData[0].chainId])),\n      'OUTPUT'\n    )\n    const path: Token[] = [input instanceof Token ? input : WRAPPED_NETWORK_TOKENS[pairData[0].chainId]]\n    for (const [i, pool] of pairData.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pool.token0) || currentInput.equals(pool.token1), 'PATH')\n      const output = currentInput.equals(pool.token0) ? pool.token1 : pool.token0\n      path.push(output)\n    }\n\n    this.pairData = pairData\n    this.path = path\n    this.midPrice = Price.fromRoute(this, poolDict)\n    this.input = input\n    this.output = output ?? path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.pairData[0].chainId\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { ONE, ZERO } from '../constants'\n// import { sortedInsert } from '../helperUtils'\nimport { ChainId, NETWORK_CCY } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount, InputOutput } from './fractions/tokenAmount'\nimport { currencyEquals, WRAPPED_NETWORK_TOKENS } from './token'\nimport {\n  Pool\n  , PoolDictionary\n} from './pools/pool'\nimport { SwapRoute } from './swapRoute'\n// import { SwapRoute } from './swapRoute'\n// import { SwapData } from './pools/swapData'\n\nexport enum SwapType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\n// function computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n//   const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n//   // calculate slippage := (exactQuote - outputAmount) / exactQuote\n//   const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n//   return new Percent(slippage.numerator, slippage.denominator)\n// }\n\n// function computePriceImpactWeightedPair(pair: WeightedPair, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n//   const artificialMidPrice = new Price(\n//     inputAmount.currency,\n//     outputAmount.currency,\n//     pair.reserveOf(wrappedCurrency(inputAmount.currency, pair.chainId)).raw,\n//     pair.reserveOf(wrappedCurrency(outputAmount.currency, pair.chainId)).raw)\n//   const exactQuote = artificialMidPrice.raw.multiply(inputAmount.raw)\n//   // calculate slippage := (exactQuote - outputAmount) / exactQuote\n//   const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n//   return new Percent(slippage.numerator, slippage.denominator)\n// }\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Swap, b: Swap) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // // consider lowest slippage next, since these are less likely to fail\n  // if (a.priceImpact.lessThan(b.priceImpact)) {\n  //   return -1\n  // } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n  //   return 1\n  // }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === NETWORK_CCY[chainId]) return new TokenAmount(WRAPPED_NETWORK_TOKENS[chainId], currencyAmount.raw)\n  invariant(false, 'CURRENCY')\n}\n\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Swap {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: SwapRoute\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: SwapType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly swapAmounts: TokenAmount[]\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: TokenAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: TokenAmount\n\n  public readonly isValid: boolean\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  // public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: SwapRoute, amountIn: TokenAmount, poolDict: { [id: string]: Pool }): Swap {\n    return new Swap(route, amountIn, SwapType.EXACT_INPUT, poolDict)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: SwapRoute, amountOut: TokenAmount, poolDict: { [id: string]: Pool }): Swap {\n    return new Swap(route, amountOut, SwapType.EXACT_OUTPUT, poolDict)\n  }\n\n  public constructor(route: SwapRoute, amount: TokenAmount, tradeType: SwapType, poolDict: { [id: string]: Pool }) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    let _isValid = true\n    if (tradeType === SwapType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.swapData[i]\n        try {\n          const outputAmount = pair.calculateSwapGivenIn(amounts[i], poolDict)\n          amounts[i + 1] = outputAmount\n        } catch {\n          _isValid = false\n          break;\n        }\n\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.swapData[i - 1]\n        try {\n          const inputAmount = pair.calculateSwapGivenOut(amounts[i], poolDict)\n          amounts[i - 1] = inputAmount\n        } catch {\n          _isValid = false\n          break;\n        }\n      }\n    }\n    this.isValid = _isValid\n    this.route = route\n    this.tradeType = tradeType\n    this.swapAmounts = amounts\n    if (this.isValid) {\n      this.inputAmount = tradeType === SwapType.EXACT_INPUT ? amount : amounts[0]\n      this.outputAmount = tradeType === SwapType.EXACT_OUTPUT ? amount : amounts[amounts.length - 1]\n    } else { // default\n      this.inputAmount = tradeType === SwapType.EXACT_INPUT ? amount : new TokenAmount(this.route.swapData[0].tokenIn, '0')\n      this.outputAmount = tradeType === SwapType.EXACT_OUTPUT ? amount : new TokenAmount(this.route.swapData[this.route.swapData.length - 1].tokenIn, '0')\n    }\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    // this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): TokenAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === SwapType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): TokenAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === SwapType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n    }\n  }\n  /**\n   * \n   * @param swapRoutes input routes - should already not include duplicates\n   * @param swapType determines in which direction the swap will be calculated\n   * @param poolDict dictionary used to price the trade routes\n   * @returns trades in an array\n   */\n  public static PriceRoutes(swapRoutes: SwapRoute[], amount: TokenAmount, swapType: SwapType, poolDict: PoolDictionary): Swap[] {\n    const swaps: Swap[] = []\n    for (let i = 0; i < swapRoutes.length; i++) {\n      const swap = new Swap(swapRoutes[i], amount, swapType, poolDict)\n      if (swap.isValid)\n        swaps.push(swap)\n    }\n    if (swapType === SwapType.EXACT_INPUT)\n      return swaps.sort((a, b) => (a.outputAmount.raw.lt(b.outputAmount.raw) ? 1 : -1))\n    else\n      return swaps.sort((a, b) => (a.outputAmount.raw.gt(b.outputAmount.raw)) ? 1 : -1)\n  }\n\n}\n\n\n\n\n\n\n\n","import { ChainId } from './currency'\nimport { Token } from './token'\nimport { SwapData } from './pools/swapData'\n\n\n\n// new version of the route \n// the first verion to include the stable pool for less friction\nexport class SwapRoute {\n  public readonly swapData: SwapData[]\n  public readonly path: Token[]\n  public readonly input: Token\n  public readonly output: Token\n  public readonly identifier: string\n  // public readonly midPrice: Price\n\n  public constructor(swapData: SwapData[]) {\n\n    const path: Token[] = [swapData[0].tokenIn]\n\n    // it can happen that the pool is traded through consecutively, we wnat to remove this case \n    const swapDataAggregated = []\n    for (let i = 0; i < swapData.length; i++) {\n      let currentSwap = swapData[i]\n      const tokenIn = currentSwap.tokenIn\n      let relevantOut = currentSwap.tokenOut\n      for (let j = i + 1; j < swapData.length; j++) {\n        if (swapData[j].poolRef === currentSwap.poolRef) {\n          currentSwap = swapData[j]\n          relevantOut = currentSwap.tokenOut\n          i++\n        } else {\n          break;\n        }\n      }\n      const swap = new SwapData(tokenIn, relevantOut, currentSwap.poolRef)\n      swapDataAggregated.push(swap)\n      // const currentInput = path[i]\n      // invariant(currentInput.equals(currentSwap.tokenIn), 'PATH')\n      const output = currentSwap.tokenOut\n      path.push(output)\n    }\n\n\n    this.swapData = swapDataAggregated\n\n    this.identifier = swapDataAggregated.map(x => x.poolRef).join('-') + path.map(p => p.address.charAt(5)).join('-')\n    this.path = path\n    // this.midPrice = Price.fromRoute(this, poolDict)\n    this.input = path[0]\n    this.output = path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.swapData[0].chainId\n  }\n\n  public equals(otherRoute: SwapRoute): boolean {\n    for (let i = 0; i < this.swapData.length; i++) {\n      if (!this.swapData[i].tokenIn.equals(otherRoute.swapData[i].tokenIn) && !this.swapData[i].tokenOut.equals(otherRoute.swapData[i].tokenOut) && !(this.swapData[i].poolRef === otherRoute.swapData[i].poolRef))\n        return false\n    }\n    return true\n  }\n\n  public static cleanRoutes(swapRoutes: SwapRoute[]): SwapRoute[] {\n    var routeIds: string[] = []\n    var routes: SwapRoute[] = []\n    for (var i = 0; i < swapRoutes.length; i++) {\n      if (!routeIds.includes(swapRoutes[i].identifier)) {\n        routeIds.push(swapRoutes[i].identifier)\n        routes.push(swapRoutes[i])\n      }\n    }\n    return routes\n  }\n\n}\n","\n\n// import { SwapData } from \"entities/pools/SwapData\";\n// import { BigNumber } from \"ethers\";\n// import { Pool, PoolDictionary, PoolHops, Token, ZERO } from \".\";\n\nimport { PairData } from \"./entities/pools/pairData\"\nimport { SwapData } from \"./entities/pools/swapData\"\nimport { SwapRoute } from \"./entities/swapRoute\"\nimport invariant from \"tiny-invariant\"\nimport { ChainId, Currency, NETWORK_CCY, Token, WRAPPED_NETWORK_TOKENS } from \"./entities\"\n\n\nexport function wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n    if (currency instanceof Token) return currency\n    if (currency === NETWORK_CCY[chainId]) return WRAPPED_NETWORK_TOKENS[chainId]\n    invariant(false, 'CURRENCY')\n  }\n\nexport class RouteProvider {\n\n  /**\n  * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n  * amount to an output token, making at most `maxHops` hops.\n  * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n  * the amount in among multiple routes.\n  * @param pairs the pairs to consider in finding the best trade\n  * @param currencyAmountIn exact amount of input currency to spend\n  * @param currencyOut the desired currency out\n  * @param maxNumResults maximum number of results to return\n  * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n  * @param currentPairs used in recursion; the current list of pairs\n  * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n  * @param bestTrades used in recursion; the current list of best trades\n  */\n   public static getRouteIteration(\n    pairData: PairData[],\n    tokenIn: Token,\n    tokenOut: Token,\n    maxHops = 3,\n    // used in recursion.\n    lastPool:string='',\n    currentpools: SwapData[] = [],\n    originalCurrencyIn: Token = tokenIn,\n    bestRoutes: SwapRoute[] = []\n  ): SwapRoute[] {\n    invariant(pairData.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalCurrencyIn === tokenIn || currentpools.length > 0, 'INVALID_RECURSION')\nconst relevantPairs = pairData.filter(p=>p.poolRef !== lastPool)\n    for (let i = 0; i < relevantPairs.length; i++) {\n      let pair = relevantPairs[i]\n      // filters for valid connection\n      const inIs0 = pair.token0.equals(tokenIn)\n      if (!inIs0 && !pair.token1.equals(tokenIn)) continue;\n      \n      const tokenOutNew: Token = inIs0 ? pair.token1 : pair.token0\n      \n      let swap:SwapData\n      // const lastSwap:SwapData = currentpools[currentpools.length -1]\n\n      // if(lastSwap?.poolRef === pair.poolRef)\n      // {\n        // swap =  new SwapData(lastSwap.tokenIn, tokenOutNew, pair.poolRef)\n      //   currentpools.splice(currentpools.length -1,1)\n      // } else\n      // {\n        swap = new SwapData(tokenIn, tokenOutNew, pair.poolRef)\n      // }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (tokenOutNew.equals(tokenOut)) {\n        bestRoutes.push(new SwapRoute([...currentpools, swap]))\n      } else if (maxHops > 1 && relevantPairs.length > 1) {\n        // const poolsExcludingThispool = pairData.slice(0, i).concat(pairData.slice(i + 1, pairData.length)) // pairData.filter(data => data.poolRef !== pair.poolRef)\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        RouteProvider.getRouteIteration(\n          // poolsExcludingThispool,\n          pairData,\n          tokenOutNew,\n          tokenOut,\n          maxHops - 1,\n          pair.poolRef,\n          [...currentpools, swap],\n          originalCurrencyIn,\n          bestRoutes\n        )\n      }\n\n    }\n    return bestRoutes\n  }\n\n  public static getRoutes(\n    pairData: PairData[],\n    currencyIn: Token,\n    currencyOut: Token,\n    maxHops = 3\n  ): SwapRoute[] {\n    return this.getRouteIteration(\n      pairData,\n      currencyIn,\n      currencyOut,\n      maxHops,\n      '',\n      [],\n      currencyIn,\n      []\n    )\n  }\n}\n\n\n// export enum SwapTypes {\n//     SwapExactIn,\n//     SwapExactOut,\n// }\n\n// export interface SwapOptions {\n//     gasPrice: BigNumber;\n//     swapGas: BigNumber;\n//     timestamp: number;\n//     maxPools: number;\n//     poolTypeFilter: PoolFilter;\n//     forceRefresh: boolean;\n// }\n\n\n// export enum PoolFilter {\n//     All = 'All',\n//     Weighted = 'Weighted',\n//     Stable = 'Stable',\n//     MetaStable = 'MetaStable',\n//     LBP = 'LiquidityBootstrapping',\n//     Investment = 'Investment',\n//     Element = 'Element',\n//     AaveLinear = 'AaveLinear',\n//     StablePhantom = 'StablePhantom',\n//     ERC4626Linear = 'ERC4626Linear',\n// }\n\n\n// /*\n// The purpose of this function is to build dictionaries of direct pools \n// and plausible hop pools.\n// */\n// export function filterPoolsOfInterest(\n//     allPools: PoolDictionary,\n//     tokenIn: Token,\n//     tokenOut: Token,\n//     maxPools: number\n// ): [PoolDictionary, PoolHops, PoolHops] {\n//     const directPools: PoolDictionary = {};\n//     const hopsIn: PoolHops = {};\n//     const hopsOut: PoolHops = {};\n\n//     Object.keys(allPools).forEach((id) => {\n//         const pool = allPools[id];\n//         const tokenListSet = new Set(pool.tokens);\n//         const containsTokenIn = tokenListSet.has(tokenIn);\n//         const containsTokenOut = tokenListSet.has(tokenOut);\n\n//         // This is a direct pool as has both tokenIn and tokenOut\n//         if (containsTokenIn && containsTokenOut) {\n//             directPools[pool.address] = pool;\n//             return;\n//         }\n\n//         if (maxPools > 1) {\n//             if (containsTokenIn && !containsTokenOut) {\n//                 for (const hopToken of tokenListSet) {\n//                     if (!hopsIn[hopToken.address]) hopsIn[hopToken.address] = new Set([]);\n//                     hopsIn[hopToken.address].add(pool.address);\n//                 }\n//             } else if (!containsTokenIn && containsTokenOut) {\n//                 for (const hopToken of [...tokenListSet]) {\n//                     if (!hopsOut[hopToken.address]) hopsOut[hopToken.address] = new Set([]);\n//                     hopsOut[hopToken.address].add(pool.address);\n//                 }\n//             }\n//         }\n//     });\n//     return [directPools, hopsIn, hopsOut];\n// }\n\n\n\n// export function searchConnectionsTo(\n//     token: Token,\n//     poolsDict: { [id: string]: Pool },\n//     toToken: Token\n//   ): Path[] {\n//     // this assumes that every pool in poolsDict contains toToken\n//     const connections: Path[] = [];\n//     for (const id in poolsDict) {\n//       const pool = poolsDict[id];\n//       if (pool.involvesToken(token)) {\n//         const connection = createPath([token, toToken], [pool]);\n//         connections.push(connection);\n//       }\n//     }\n//     return connections;\n//   }\n  \n//   export interface Path {\n//     id: string; // pool address if direct path, contactenation of pool addresses if multihop\n//     swaps: Swap[];\n//   }\n  \n//   export interface Swap {\n//     pool: string;\n//     tokenIn: Token;\n//     tokenOut: Token;\n//     swapAmount?: BigNumber;\n//   }\n  \n//   // Creates a path with pools.length hops\n//   // i.e. tokens[0]>[Pool0]>tokens[1]>[Pool1]>tokens[2]>[Pool2]>tokens[3]\n//   export function createPath(tokens: Token[], pools: Pool[]): Path {\n//     let tI: Token, tO: Token;\n//     const swaps: Swap[] = [];\n//     // const poolPairData: PairData[] = [];\n//     let id = '';\n  \n//     for (let i = 0; i < pools.length; i++) {\n//       tI = tokens[i];\n//       tO = tokens[i + 1];\n//       // const poolPair = pools[i].parsePoolPairData(tI, tO);\n//       // poolPairData.push(poolPair);\n  \n//       const swap: Swap = {\n//         pool: pools[i].address,\n//         tokenIn: tI,\n//         tokenOut: tO,\n//       };\n  \n//       swaps.push(swap);\n//     }\n  \n//     const path: Path = {\n//       id,\n//       swaps,\n//     };\n  \n//     return path;\n//   }\n  \n  \n  \n\n\n// export function producePaths(\n//     tokenIn: Token,\n//     tokenOut: Token,\n//     directPools: PoolDictionary,\n//     hopsIn: PoolHops,\n//     hopsOut: PoolHops,\n//     pools: PoolDictionary\n// ): Path[] {\n//     const paths: Path[] = [];\n\n//     // Create direct paths\n//     for (const id in directPools) {\n//         const path = createPath([tokenIn, tokenOut], [pools[id]]);\n//         paths.push(path);\n//     }\n\n//     for (const hopToken in hopsIn) {\n//         if (hopsOut[hopToken]) {\n//             let highestNormalizedLiquidityFirst = ZERO; // Aux variable to find pool with most liquidity for pair (tokenIn -> hopToken)\n//             let highestNormalizedLiquidityFirstPoolId: string | undefined; // Aux variable to find pool with most liquidity for pair (tokenIn -> hopToken)\n//             let highestNormalizedLiquiditySecond = ZERO; // Aux variable to find pool with most liquidity for pair (hopToken -> tokenOut)\n//             let highestNormalizedLiquiditySecondPoolId: string | undefined; // Aux variable to find pool with most liquidity for pair (hopToken -> tokenOut)\n//             for (const poolInId of [...hopsIn[hopToken]]) {\n//                 const poolIn = pools[poolInId.address];\n//                 const poolPairData = SwapData.singleDataFromPool(\n//                     tokenIn,\n//                     hopToken,\n//                     poolIn\n//                 );\n     \n//                 // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n//                 if (\n//                     normalizedLiquidity.isGreaterThanOrEqualTo(\n//                         highestNormalizedLiquidityFirst\n//                     )\n//                 ) {\n//                     highestNormalizedLiquidityFirst = normalizedLiquidity;\n//                     highestNormalizedLiquidityFirstPoolId = poolIn.id;\n//                 }\n//             }\n//             for (const poolOutId of [...hopsOut[hopToken]]) {\n//                 const poolOut = pools[poolOutId.address];\n//                 const poolPairData = poolOut.parsePoolPairData(\n//                     hopToken,\n//                     tokenOut\n//                 );\n//                 const normalizedLiquidity =\n//                     poolOut.getNormalizedLiquidity(poolPairData);\n//                 // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n//                 if (\n//                     normalizedLiquidity.isGreaterThanOrEqualTo(\n//                         highestNormalizedLiquiditySecond\n//                     )\n//                 ) {\n//                     highestNormalizedLiquiditySecond = normalizedLiquidity;\n//                     highestNormalizedLiquiditySecondPoolId = poolOut.address;\n//                 }\n//             }\n//             if (\n//                 highestNormalizedLiquidityFirstPoolId &&\n//                 highestNormalizedLiquiditySecondPoolId\n//             ) {\n//                 const path = createPath(\n//                     [tokenIn, hopToken, tokenOut],\n//                     [\n//                         pools[highestNormalizedLiquidityFirstPoolId],\n//                         pools[highestNormalizedLiquiditySecondPoolId],\n//                     ]\n//                 );\n//                 paths.push(path);\n//             }\n//         }\n//     }\n//     return paths;\n// }\n\n\n// export class RouteProvider {\n//     cache: Record<string, { paths: Path[] }> = {};\n\n//     // constructor(private readonly config: SorConfig) {}\n\n//     /**\n//      * Given a list of pools and a desired input/output, returns a set of possible paths to route through\n//      */\n//     getCandidatePaths(\n//         tokenIn: Token,\n//         tokenOut: Token,\n//         swapType: SwapTypes,\n//         poolsAllDict: PoolDictionary,\n//         swapOptions: SwapOptions\n//     ): Path[] {\n//         if (!poolsAllDict) return [];\n\n//         // If token pair has been processed before that info can be reused to speed up execution\n//         const cache =\n//             this.cache[\n//             `${tokenIn.address}${tokenOut.address}${swapType}${swapOptions.timestamp}`\n//             ];\n\n//         // forceRefresh can be set to force fresh processing of paths/prices\n//         if (!swapOptions.forceRefresh && !!cache) {\n//             // Using pre-processed data from cache\n//             return cache.paths;\n//         }\n\n//         const [directPools, hopsIn, hopsOut] = filterPoolsOfInterest(\n//             poolsAllDict,\n//             tokenIn,\n//             tokenOut,\n//             swapOptions.maxPools\n//         );\n\n//         const pathData = producePaths(\n//             tokenIn,\n//             tokenOut,\n//             directPools,\n//             hopsIn,\n//             hopsOut,\n//             poolsAllDict\n//         );\n\n//         const boostedPaths = getBoostedPaths(\n//             tokenIn,\n//             tokenOut,\n//             poolsAllDict,\n//             this.config\n//         );\n\n//         const pathsUsingStaBal = getPathsUsingStaBalPool(\n//             tokenIn,\n//             tokenOut,\n//             poolsAllDict,\n//             poolsAllDict,\n//             this.config\n//         );\n\n//         const combinedPathData = pathData\n//             .concat(...boostedPaths)\n//             .concat(...pathsUsingStaBal);\n//         const [paths] = calculatePathLimits(combinedPathData, swapType);\n\n//         this.cache[`${tokenIn}${tokenOut}${swapType}${swapOptions.timestamp}`] =\n//         {\n//             paths: paths,\n//         };\n\n//         return paths;\n//     }\n\n//     /**\n//      * Given a pool dictionary and a desired input/output, returns a set of possible paths to route through.\n//      * @param {string} tokenIn - Address of tokenIn\n//      * @param {string} tokenOut - Address of tokenOut\n//      * @param {SwapTypes} swapType - SwapExactIn where the amount of tokens in (sent to the Pool) is known or SwapExactOut where the amount of tokens out (received from the Pool) is known.\n//      * @param {PoolDictionary} poolsAllDict - Dictionary of pools.\n//      * @param {number }maxPools - Maximum number of pools to hop through.\n//      * @returns {NewPath[]} Array of possible paths sorted by liquidity.\n//      */\n//     getCandidatePathsFromDict(\n//         tokenIn: string,\n//         tokenOut: string,\n//         swapType: SwapTypes,\n//         poolsAllDict: PoolDictionary,\n//         maxPools: number\n//     ): NewPath[] {\n//         if (Object.keys(poolsAllDict).length === 0) return [];\n\n//         const [directPools, hopsIn, hopsOut] = filterPoolsOfInterest(\n//             poolsAllDict,\n//             tokenIn,\n//             tokenOut,\n//             maxPools\n//         );\n\n//         const pathData = producePaths(\n//             tokenIn,\n//             tokenOut,\n//             directPools,\n//             hopsIn,\n//             hopsOut,\n//             poolsAllDict\n//         );\n\n//         const boostedPaths = getBoostedPaths(\n//             tokenIn,\n//             tokenOut,\n//             poolsAllDict,\n//             this.config\n//         );\n\n//         const combinedPathData = pathData.concat(...boostedPaths);\n//         const [paths] = calculatePathLimits(combinedPathData, swapType);\n//         return paths;\n//     }\n// }\n","\nimport invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from './helperUtils'\nimport { CurrencyAmount, Percent, Swap, SwapType } from './entities'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n\n  /**\n   * Whether we swap through multiple routers / pair types\n   */\n  multiSwap?: boolean\n\n  /**\n   * Checks whether the networkccy is used in in- or output: helps us to avoid checks in route calculations\n   */\n  etherIn: boolean\n  etherOut: boolean\n}\n\nexport interface SwapOptionsDeadline extends Omit<SwapOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[] | string[][])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount) {\n  return currencyAmount.raw.toHexString()\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Router, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() { }\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(trade: Swap, options: SwapOptions | SwapOptionsDeadline): SwapParameters {\n    const etherIn = options.etherIn\n    const etherOut = options.etherOut\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n\n\n    let methodName: string\n\n    let args: (string | string[] | string[][])[] = []\n    let value: string\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    if (!options.multiSwap) {\n      const path: string[] = trade.route.path.map((token) => token.address)\n      const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n      switch (trade.tradeType) {\n        case SwapType.EXACT_INPUT:\n          if (etherIn) {\n            methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n            // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n            args = [amountOut, path, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n            // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n            args = [amountIn, amountOut, path, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = useFeeOnTransfer\n              ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n              : 'swapExactTokensForTokens'\n            // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n            args = [amountIn, amountOut, path, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n        case SwapType.EXACT_OUTPUT:\n          invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n          if (etherIn) {\n            methodName = 'swapETHForExactTokens'\n            // (uint amountOut, address[] calldata path, address to, uint deadline)\n            args = [amountOut, path, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = 'swapTokensForExactETH'\n            // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n            args = [amountOut, amountIn, path, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = 'swapTokensForExactTokens'\n            // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n            args = [amountOut, amountIn, path, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n      }\n    } else {\n      const path = trade.route.path.map(token => token.address)\n      const pairData = trade.route.swapData.map(p => p.poolRef)\n\n      switch (trade.tradeType) {\n        case SwapType.EXACT_INPUT:\n          if (etherIn) {\n            methodName = 'onSwapExactETHForTokens'\n            // function multiSwapExactETHForTokens( address[][] calldata path, uint256[] memory routerId,\n            // uint256 amountOutMin, uint256 deadline )\n            args = [pairData, path, amountOut, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = 'onSwapExactTokensForETH'\n            // multiSwapExactTokensForETH( address[][] calldata path, uint256[] memory pools, uint256 amountIn,\n            // uint256 amountOutMin, uint256 deadline )\n            args = [pairData, path, amountIn, amountOut, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = 'onSwapExactTokensForTokens'\n            // function onSwapExactTokensForTokens(\n            //   address[] memory pools,\n            //   address[] memory tokens,\n            //   uint256 amountIn,\n            //   uint256 amountOutMin,\n            //   address to,\n            //   uint256 deadline\n            args = [pairData, path, amountIn, amountOut, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n        case SwapType.EXACT_OUTPUT:\n          if (etherIn) {\n            methodName = 'onSwapETHForExactTokens'\n            // multiSwapETHForExactTokens( address[][] calldata path, uint256[] memory pools, uint256 amountOut, uint256 deadline )\n            args = [pairData, path, amountOut, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = 'onSwapTokensForExactETH'\n            // multiSwapTokensForExactETH( address[][] calldata path, uint256[] memory pools,\n            // uint256 amountOut, uint256 amountInMax, uint256 deadline )\n            args = [pairData, path, amountOut, amountIn, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = 'onSwapTokensForExactTokens'\n            // multiSwapTokensForExactTokens( address[][] calldata path, uint256[] memory pools, \n            // uint256 amountOut, uint256 amountInMax,  uint256 deadline )\n            args = [pairData, path, amountOut, amountIn, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n      }\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n"],"names":["TradeType","SolidityType","FACTORY_ADDRESS","STABLE_POOL_ADDRESS","STABLE_POOL_LP_ADDRESS","MINIMUM_LIQUIDITY","BigNumber","from","ZERO","ONE","TWO","THREE","FIVE","TEN","_100","SOLIDITY_TYPE_MAXIMA","uint8","uint256","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","name","_this","constructor","setPrototypeOf","prototype","Error","InsufficientInputAmountError","_this2","validateSolidityTypeInstance","value","solidityType","gte","invariant","lte","validateAndParseAddress","address","getAddress","error","parseBigintIsh","bigintIsh","toString","sqrt","y","x","z","gt","div","add","lt","eq","ChainId","Currency","chainId","decimals","symbol","NETWORK_CCY","BSC_MAINNET","BSC_TESTNET","ARBITRUM_MAINNET","ARBITRUM_TETSNET_RINKEBY","AVAX_MAINNET","AVAX_TESTNET","MATIC_MAINNET","MATIC_TESTNET","OASIS_MAINNET","OASIS_TESTNET","QUARKCHAIN_DEV_S0","Token","projectLink","equals","other","this","sortsBefore","toLowerCase","currencyEquals","currencyA","currencyB","Rounding","WETH","WRAPPED_NETWORK_TOKENS","STABLECOINS","STABLES_INDEX_MAP","STABLES_LP_TOKEN","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","numerator","denominator","invert","otherParsed","mul","subtract","sub","lessThan","equalTo","greaterThan","multiply","divide","toSignificant","significantDigits","format","rounding","groupSeparator","Number","isInteger","set","precision","quotient","toSignificantDigits","decimalPlaces","toFixed","DP","RM","mod","_100_PERCENT","Percent","CurrencyAmount","currency","amount","parsedAmount","pow","networkCCYAmount","raw","toExact","toBigNumber","TokenAmount","token","Price","baseCurrency","quoteCurrency","scalar","fromRoute","route","poolDict","prices","pairData","entries","i","price","poolPrice","path","push","slice","reduce","accumulator","currentValue","fraction","quote","currencyAmount","_Fraction","adjusted","ONE_18","ONE_20","ONE_36","LN_36_LOWER_BOUND","LN_36_UPPER_BOUND","x0","a0","x1","a1","x2","a2","x3","a3","x4","a4","x5","a5","x6","a6","x7","a7","x8","a8","x9","a9","x10","a10","x11","a11","logx_times_y","x_int256","y_int256","ln_36_x","_ln_36","_ln","exp","firstAN","product","term","seriesSum","a","sum","z_squared","num","MAX_POW_RELATIVE_ERROR","MIN_POW_BASE_FREE_EXPONENT","mulDown","b","mulUp","divDown","divUp","powDown","maxError","powUp","complement","max","_MAX_IN_RATIO","_MAX_OUT_RATIO","_MAX_INVARIANT_RATIO","_MIN_INVARIANT_RATIO","_calcOutGivenIn","balanceIn","weightIn","balanceOut","weightOut","amountIn","_calcInGivenOut","amountOut","_calcLpOutGivenExactTokensIn","balances","normalizedWeights","amountsIn","lpTotalSupply","swapFeePercentage","balanceRatiosWithFee","invariantRatioWithFees","length","_computeJoinExactTokensInInvariantRatio","invariantRatio","swapFees","lpOut","amountInWithoutFee","nonTaxableAmount","taxableAmount","swapFee","_calcAllTokensInGivenExactLpOut","lpAmountOut","totalBPT","lpRatio","_calcLpInGivenExactTokensOut","amountsOut","balanceRatiosWithoutFee","Array","invariantRatioWithoutFees","_computeExitExactTokensOutInvariantRatio","lpIn","amountOutWithFee","taxableAmountPlusFees","_calcTokenOutGivenExactLpIn","balance","normalizedWeight","lpAmountIn","amountOutWithoutFee","FEE_DENOMINATOR","calculateRemoveLiquidityOneTokenExactIn","self","outIndex","lpAmount","lpSupply","tokenBalances","tokenMultipliers","fee","calculateRemoveLiquidityExactIn","_xp","calculateTokenAmount","amounts","deposit","calculateSwapGivenIn","inIndex","amountInWithFee","calculateSwapGivenOut","rates","result","TENK","_256","_128","FIXED_1","FIXED_2","MAX_NUM","LN2_NUMERATOR","LN2_DENOMINATOR","OPT_LOG_MAX_VAL","OPT_EXP_MAX_VAL","maxExpArray","leftShift","shift","signedRightShift","power","_baseN","_baseD","_expN","_expD","base","baseLogTimesExp","optimalLog","generalLog","optimalExp","findPositionInMaxExpArray","generalExp","res","count","_n","s","or","floorLog2","w","and","isZero","_x","_precision","xi","lo","hi","mid","getAmountOut","reserveIn","reserveOut","tokenWeightIn","tokenWeightOut","temp1","temp2","getAmountIn","baseD","baseReserveIn","PoolType","WeightedSwapStorage","adminFee","mock","StableSwapStorage","initialA","futureA","initialATime","futureATime","lpAddress","dummy","Pool","involvesToken","keys","tokens","tokenFromIndex","index","indexFromToken","getBalances","map","_","reserveOf","setBalanceValueByIndex","newBalance","getTokenAmounts","t","setTokenBalances","subtractBalanceValue","tokenAmount","newBalances","_name","PAIR_ADDRESS_CACHE","PAIR_HASH","AmplifiedWeightedPair","virtualReserves","weightA","amp","ampBPS","weights","liquidityToken","ethers","utils","type","token0","token1","weight0","join","tokenA","tokenB","undefined","_PAIR_ADDRESS_CACHE2","_PAIR_ADDRESS_CACHE3","_PAIR_ADDRESS_CACHE3$","getCreate2Address","keccak256","pack","fromBigIntish","getAddressForRouter","tokenIn","token0Price","token1Price","poolPriceBases","priceBaseIn","priceBaseOut","priceOf","reserve0","reserve1","virtualReserveOf","virtualReserve0","virtualReserve1","weightOf","weight1","getLiquidityMinted","totalSupply","tokenAmountA","tokenAmountB","liquidity","tokenAmounts","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","clone","priceRatioOf","token0PriceRaw","token1PriceRaw","tokenOut","inAmount","outAmount","outputReserve","inputReserve","outputWeight","getOutputAmount","inputAmount","inputWeight","outputAmount","getInputAmount","console","log","WeightedPool","poolAddress","swapStorage","values","constants","AddressZero","calculateSwapViaPing","inToken","outToken","provider","Contract","Interface","weightedPoolABI","swap","toBigInt","calculateRemoveLiquidity","amountLp","calculateRemoveLiquidityOneToken","getLiquidityAmount","userBalances","setSwapStorage","setLpTotalSupply","setBalanceValue","addBalanceValue","A_PRECISION","_getAPrecise","blockTimestamp","_distance","_getD","xp","nCoins","_sumOf","Dprev","D","Ann","D_P","j","_getY","inBalance","normalizedBalances","c","_getYD","A","StablePool","_A","currentWithdrawFee","StableSwap","calculateSwap","outBalance","_fee","_amountOutInclFee","feeAdjustedAmount","_calculateRemoveLiquidity","D0","D1","newY","reducedXP","_feePerToken","expectedDx","dy","_calculateRemoveLiquidityOneToken","_calculateTokenAmount","setBlockTimestamp","toNumber","virtualIn","feeToSet","SwapData","poolRef","tokenOutAmount","tokenInAmount","singleDataFromPool","pool","includes","fetchPoolPrice","PairData","dataFromPool","index0","index1","dataFromPools","pools","k","toSwapDataFrom","toSwapDataTo","toSwapArrayFrom","swaps","currentIn","toSwapArrayTo","currentOut","SQRT2x100","ONE_E18","sqrrt","getTotalValue","pair","payoutToken","weightPayoutToken","weightOther","valuation","RESOLUTION","resPrec","decode112with18","ONE_E16","ONE_E9","payoutFor","bondPrice","debtRatio","currentDebt","controlVariable","bondPriceUsingDebtRatio","SwapType","Route","input","output","currentInput","midPrice","inputOutputComparator","wrappedAmount","Swap","tradeType","_isValid","EXACT_INPUT","swapData","isValid","swapAmounts","EXACT_OUTPUT","executionPrice","exactIn","exactOut","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","PriceRoutes","swapRoutes","swapType","sort","SwapRoute","swapDataAggregated","currentSwap","relevantOut","identifier","p","charAt","otherRoute","cleanRoutes","routeIds","routes","RouteProvider","getRouteIteration","maxHops","lastPool","currentpools","originalCurrencyIn","bestRoutes","relevantPairs","filter","inIs0","tokenOutNew","getRoutes","currencyIn","currencyOut","toHex","toHexString","SwapRouter","swapCallParameters","trade","options","etherIn","etherOut","ttl","methodName","to","recipient","allowedSlippage","args","deadline","Math","floor","Date","getTime","multiSwap","useFeeOnTransfer","Boolean","feeOnTransfer","previousInvariant","currentInvariant","protocolSwapFeePercentage","exponent","tokenAccruedFees","_invariant","terms","arg","logBase","reservesOther","concat","ioComp"],"mappings":"gJAKYA,yTAAAA,EAAAA,oBAAAA,sDAEVA,uCA0DUC,EAvDCC,EAAiD,IACxD,gDACA,mDACG,mDACA,8CAyBIC,EAAqD,OACzD,mDACA,oDACC,8CAGGC,EAAwD,OAC5D,mDACA,oDACC,8CAGGC,EAAoBC,YAAUC,KAAK,KAGnCC,EAAOF,YAAUC,KAAK,GACtBE,EAAMH,YAAUC,KAAK,GACrBG,EAAMJ,YAAUC,KAAK,GACrBI,EAAQL,YAAUC,KAAK,GACvBK,EAAON,YAAUC,KAAK,GACtBM,EAAMP,YAAUC,KAAK,IAErBO,EAAOR,YAAUC,KAAK,MAInC,SAAYN,GACVA,gBACAA,oBAFF,CAAYA,IAAAA,OAKL,IAAMc,UACVd,EAAae,OAAQV,YAAUC,KAAK,UACpCN,EAAagB,SAAUX,YAAUC,KAAK,uoFCvEzC,MAAMW,EAAoB,mBAAoBC,OAMjCC,2FACyC,IAI7CC,KAAOC,EAAKC,YAAYF,KACzBH,GAAmBC,OAAOK,gEAAgCC,gCANnBC,QAclCC,8FAC4C,IAIhDN,KAAOO,EAAKL,YAAYF,KACzBH,GAAmBC,OAAOK,gEAAgCC,gCANhBC,iBCdlCG,EAA6BC,EAAkBC,GACnDD,EAAME,IAAIxB,IAApByB,MACUH,EAAMI,IAAInB,EAAqBgB,KAAzCE,eAIcE,EAAwBC,cAETC,aAAWD,GAGtC,MAAOE,GACPL,gBAIYM,EAAeC,UACtBA,aAAqBlC,YACxBkC,EAEAlC,YAAUC,KADW,iBAAdiC,EACQA,EAAUC,WACVD,YAILE,EAAKC,GACnBd,EAA6Bc,EAAG1C,EAAagB,aAEzC2B,EADAC,EAAerC,KAEfmC,EAAEG,GAAGnC,OACPkC,EAAIF,EACJC,EAAID,EAAEI,IAAIrC,GAAKsC,IAAIvC,GACZmC,EAAEK,GAAGJ,IACVA,EAAID,EACJA,EAAID,EAAEI,IAAIH,GAAGI,IAAKJ,GAAGG,IAAIrC,QAEjBiC,EAAEO,GAAG1C,KACfqC,EAAIpC,UAECoC,MCpBGM,EArBCC,EAYX,SAAYC,EAAiBC,EAAkBC,EAAiBlC,QACzDiC,SAAWA,OACXC,OAASA,OACTlC,KAAOA,OACPgC,QAAUA,IAKPF,EAAAA,kBAAAA,qDAEVA,kCACAA,uCACAA,uCACAA,+CACAA,gEACAA,uCACAA,yCACAA,yCACAA,yCACAA,kDAGF,QAAaK,UACVL,gBAAQM,aAAc,IAAIL,EAASD,gBAAQM,YAAa,GAAI,MAAO,SACnEN,gBAAQO,aAAc,IAAIN,EAASD,gBAAQO,YAAa,GAAI,MAAO,SACnEP,gBAAQQ,kBAAmB,IAAIP,EAASD,gBAAQQ,iBAAkB,GAAI,MAAO,SAC7ER,gBAAQS,0BAA2B,IAAIR,EAASD,gBAAQS,yBAA0B,GAAI,MAAO,SAC7FT,gBAAQU,cAAe,IAAIT,EAASD,gBAAQU,aAAc,GAAI,OAAQ,UACtEV,gBAAQW,cAAe,IAAIV,EAASD,gBAAQW,aAAc,GAAI,OAAQ,UACtEX,gBAAQY,eAAgB,IAAIX,EAASD,gBAAQY,cAAe,GAAI,QAAS,WACzEZ,gBAAQa,eAAgB,IAAIZ,EAASD,gBAAQa,cAAe,GAAI,QAAS,WACzEb,gBAAQc,eAAgB,IAAIb,EAASD,gBAAQc,cAAe,GAAI,OAAQ,UACxEd,gBAAQe,eAAgB,IAAId,EAASD,gBAAQe,cAAe,GAAI,OAAQ,UACxEf,gBAAQgB,mBAAoB,IAAIf,EAASD,gBAAQgB,kBAAmB,GAAI,MAAO,UC5CrEC,yBAKTf,EACAjB,EACAkB,EACAC,EACAlC,EACAgD,8BAEMhB,EAASC,EAAUC,EAAQlC,UAC5Be,QAAUD,EAAwBC,KAClCiC,YAAcA,sCAOdC,OAAA,SAAOC,UAERC,OAASD,GAGNC,KAAKnB,UAAYkB,EAAMlB,SAAWmB,KAAKpC,UAAYmC,EAAMnC,WAS3DqC,YAAA,SAAYF,UACPC,KAAKnB,UAAYkB,EAAMlB,SAAjCpB,MACUuC,KAAKpC,UAAYmC,EAAMnC,SAAjCH,MACOuC,KAAKpC,QAAQsC,cAAgBH,EAAMnC,QAAQsC,kBAtC3BtB,YA6CXuB,EAAeC,EAAqBC,UAC9CD,aAAqBR,GAASS,aAAqBT,EAC9CQ,EAAUN,OAAOO,KACfD,aAAqBR,GAErBS,aAAqBT,GAGvBQ,IAAcC,GAIzB,QCtDYC,GDsDCC,WACV5B,gBAAQM,aAAc,IAAIW,EACzBjB,gBAAQM,YACR,6CACA,GACA,OACA,cACA,6BAEDN,gBAAQO,aAAc,IAAIU,EACzBjB,gBAAQO,YACR,6CACA,GACA,OACA,cACA,6BAEDP,gBAAQQ,kBAAmB,IAAIS,EAC9BjB,gBAAQQ,iBACR,6CACA,GACA,OACA,cACA,6BAEDR,gBAAQS,0BAA2B,IAAIQ,EACtCjB,gBAAQS,yBACR,6CACA,GACA,OACA,cACA,6BAEDT,gBAAQU,cAAe,IAAIO,EAC1BjB,gBAAQU,aACR,6CACA,GACA,QACA,eACA,6BAEDV,gBAAQW,cAAe,IAAIM,EAC1BjB,gBAAQW,aACR,6CACA,GACA,QACA,eACA,6BAEDX,gBAAQY,eAAgB,IAAIK,EAC3BjB,gBAAQY,cACR,6CACA,GACA,SACA,gBACA,6BAEDZ,gBAAQa,eAAgB,IAAII,EAC3BjB,gBAAQa,cACR,6CACA,GACA,SACA,gBACA,8BAOSgB,WACV7B,gBAAQM,aAAc,IAAIW,EACzBjB,gBAAQM,YACR,6CACA,GACA,OACA,cACA,6BAEDN,gBAAQO,aAAc,IAAIU,EACzBjB,gBAAQO,YACR,6CACA,GACA,OACA,cACA,6BAEDP,gBAAQQ,kBAAmB,IAAIS,EAC9BjB,gBAAQQ,iBACR,6CACA,GACA,OACA,cACA,6BAEDR,gBAAQS,0BAA2B,IAAIQ,EACtCjB,gBAAQS,yBACR,6CACA,GACA,OACA,cACA,6BAEDT,gBAAQU,cAAe,IAAIO,EAC1BjB,gBAAQU,aACR,6CACA,GACA,QACA,eACA,6BAEDV,gBAAQW,cAAe,IAAIM,EAC1BjB,gBAAQW,aACR,6CACA,GACA,QACA,eACA,6BAEDX,gBAAQY,eAAgB,IAAIK,EAC3BjB,gBAAQY,cACR,6CACA,GACA,SACA,gBACA,6BAEDZ,gBAAQa,eAAgB,IAAII,EAC3BjB,gBAAQa,cACR,6CACA,GACA,SACA,gBACA,6BAEDb,gBAAQe,eACT,IAAIE,EAAOjB,gBAAQe,cACjB,6CACA,GACA,QACA,eACA,6BAEDf,gBAAQc,eACT,IAAIG,EAAOjB,gBAAQc,cACjB,6CACA,GACA,QACA,eACA,6BAEDd,gBAAQgB,mBACT,IAAIC,EAAOjB,gBAAQc,cACjB,6CACA,GACA,OACA,cACA,8BAOSgB,GAA8C,OAClD,CACL,IAAIb,EAAMjB,gBAAQW,aAAc,6CAA8C,EAAG,OAAQ,YACzF,IAAIM,EAAMjB,gBAAQW,aAAc,6CAA8C,EAAG,OAAQ,cACzF,IAAIM,EAAMjB,gBAAQW,aAAc,6CAA8C,GAAI,MAAO,kBACzF,IAAIM,EAAMjB,gBAAQW,aAAc,6CAA8C,GAAI,OAAQ,mBAErF,CACL,IAAIM,EAAMjB,gBAAQe,cAAe,6CAA8C,EAAG,OAAQ,YAC1F,IAAIE,EAAMjB,gBAAQe,cAAe,6CAA8C,EAAG,OAAQ,cAC1F,IAAIE,EAAMjB,gBAAQe,cAAe,6CAA8C,GAAI,MAAO,kBAC1F,IAAIE,EAAMjB,gBAAQe,cAAe,6CAA8C,GAAI,OAAQ,oBAErF,CACN,IAAIE,EAAMjB,gBAAQgB,kBAAmB,6CAA8C,EAAG,OAAQ,YAC9F,IAAIC,EAAMjB,gBAAQgB,kBAAmB,6CAA8C,EAAG,OAAQ,cAC9F,IAAIC,EAAMjB,gBAAQgB,kBAAmB,6CAA8C,GAAI,MAAO,kBAC9F,IAAIC,EAAMjB,gBAAQgB,kBAAmB,6CAA8C,GAAI,OAAQ,eAE9F,CACD,IAAIC,GAAO,EAAG,6CAA8C,EAAG,OAAQ,cAI9Dc,GAAuE,OAC3E,GACFD,GAAY,OAAO,KACnBA,GAAY,OAAO,KACnBA,GAAY,OAAO,KACnBA,GAAY,OAAO,UAEjB,GACFA,GAAY,OAAO,KACnBA,GAAY,OAAO,KACnBA,GAAY,OAAO,KACnBA,GAAY,OAAO,WAEhB,GACHA,GAAY,QAAQ,KACpBA,GAAY,QAAQ,KACpBA,GAAY,QAAQ,KACpBA,GAAY,QAAQ,KAIdE,GAAsE,OAC1E,GACFF,GAAY,OAAO,KACnBA,GAAY,OAAO,KACnBA,GAAY,OAAO,KACnBA,GAAY,OAAO,MC5QdH,GAAAA,mBAAAA,oDAEVA,uCACAA,6BAGF,IAAMM,GAAUC,EAASC,GACnBC,GAAMF,EAASG,GAEfC,WACHX,iBAASY,YAAaN,GAAQM,aAC9BZ,iBAASa,eAAgBP,GAAQO,gBACjCb,iBAASc,UAAWR,GAAQQ,YAGzBC,WACHf,iBAASY,gBACTZ,iBAASa,mBACTb,iBAASc,eAGCE,yBAIQC,EAAsBC,YAAAA,IAAAA,EAAyBvF,QAC3DsF,UAAYxD,EAAewD,QAC3BC,YAAczD,EAAeyD,8BAa7BC,OAAA,kBACE,IAAIH,EAAStB,KAAKwB,YAAaxB,KAAKuB,cAGtC/C,IAAA,SAAIuB,OACH2B,EAAc3B,aAAiBuB,EAAWvB,EAAQ,IAAIuB,EAASvD,EAAegC,WAChFC,KAAKwB,YAAY9C,GAAGgD,EAAYF,aAC3B,IAAIF,EAAStB,KAAKuB,UAAU/C,IAAIkD,EAAYH,WAAYvB,KAAKwB,aAE/D,IAAIF,EACTtB,KAAKuB,UAAUI,IAAID,EAAYF,aAAahD,IAC1CkD,EAAYH,UAAUI,IAAI3B,KAAKwB,cAEjCxB,KAAKwB,YAAYG,IAAID,EAAYF,iBAI9BI,SAAA,SAAS7B,OACR2B,EAAc3B,aAAiBuB,EAAWvB,EAAQ,IAAIuB,EAASvD,EAAegC,WAChFC,KAAKwB,YAAY9C,GAAGgD,EAAYF,aAC3B,IAAIF,EAAStB,KAAKuB,UAAUM,IAAIH,EAAYH,WAAYvB,KAAKwB,aAE/D,IAAIF,EACTtB,KAAKuB,UAAUI,IAAID,EAAYF,aAAaK,IAC3CH,EAAYH,UAAUI,IAAI3B,KAAKwB,cAEhCxB,KAAKwB,YAAYG,IAAID,EAAYF,iBAI9BM,SAAA,SAAS/B,OACR2B,EAAc3B,aAAiBuB,EAAWvB,EAAQ,IAAIuB,EAASvD,EAAegC,WAC7EC,KAAKuB,UAAUI,IAAID,EAAYF,aAAa/C,GACjDiD,EAAYH,UAAUI,IAAI3B,KAAKwB,iBAI5BO,QAAA,SAAQhC,OACP2B,EAAc3B,aAAiBuB,EAAWvB,EAAQ,IAAIuB,EAASvD,EAAegC,WAC7EC,KAAKuB,UAAUI,IAAID,EAAYF,aAAa9C,GACjDgD,EAAYH,UAAUI,IAAI3B,KAAKwB,iBAI5BQ,YAAA,SAAYjC,OACX2B,EAAc3B,aAAiBuB,EAAWvB,EAAQ,IAAIuB,EAASvD,EAAegC,WAC7EC,KAAKuB,UAAUI,IAAID,EAAYF,aAAalD,GAAGoD,EAAYH,UAAUI,IAAI3B,KAAKwB,iBAGhFS,SAAA,SAASlC,OACR2B,EAAc3B,aAAiBuB,EAAWvB,EAAQ,IAAIuB,EAASvD,EAAegC,WAC7E,IAAIuB,EACVtB,KAAKuB,UAAUI,IAAID,EAAYH,WAC9BvB,KAAKwB,YAAYG,IAAID,EAAYF,iBAI9BU,OAAA,SAAOnC,OACN2B,EAAc3B,aAAiBuB,EAAWvB,EAAQ,IAAIuB,EAASvD,EAAegC,WAC7E,IAAIuB,EACTtB,KAAKuB,UAAUI,IAAID,EAAYF,aAC/BxB,KAAKwB,YAAYG,IAAID,EAAYH,eAI9BY,cAAA,SACLC,EACAC,EACAC,YADAD,IAAAA,EAAiB,CAAEE,eAAgB,cACnCD,IAAAA,EAAqBhC,iBAASa,eAEpBqB,OAAOC,UAAUL,IAA3B3E,MACU2E,EAAoB,GAA9B3E,MAEAmD,GAAQ8B,IAAI,CAAEC,UAAWP,EAAoB,EAAGE,SAAUrB,GAAsBqB,SAC1EM,EAAW,IAAIhC,GAAQZ,KAAKuB,UAAUtD,YACzCM,IAAIyB,KAAKwB,YAAYvD,YACrB4E,oBAAoBT,UAChBQ,EAAS/B,SAAS+B,EAASE,gBAAiBT,MAG9CU,QAAA,SACLD,EACAT,EACAC,mBADAD,IAAAA,EAAiB,CAAEE,eAAgB,cACnCD,IAAAA,EAAqBhC,iBAASa,eAEpBqB,OAAOC,UAAUK,IAA3BrF,MACUqF,GAAiB,GAA3BrF,MAEAsD,GAAIiC,GAAKF,EACT/B,GAAIkC,GAAK5B,GAAgBiB,GAClB,IAAIvB,GAAIf,KAAKuB,UAAUtD,YAAYM,IAAIyB,KAAKwB,YAAYvD,YAAY4C,SAASiC,EAAeT,6BAnGrG,kBACSrC,KAAKuB,UAAUhD,IAAIyB,KAAKwB,oCAIjC,kBACS,IAAIF,EAAStB,KAAKuB,UAAU2B,IAAIlD,KAAKwB,aAAcxB,KAAKwB,sBC5C7D2B,GAAe,IAAI7B,GAAShF,GAErB8G,mGACJjB,cAAA,SAAcC,EAA+BC,EAAiBC,mBAAhDF,IAAAA,EAA4B,GACxCpC,KAAKiC,SAASkB,IAAchB,cAAcC,EAAmBC,EAAQC,MAGvES,QAAA,SAAQD,EAA2BT,EAAiBC,mBAA5CQ,IAAAA,EAAwB,GAC9B9C,KAAKiC,SAASkB,IAAcJ,QAAQD,EAAeT,EAAQC,OANzChB,ICKvBP,GAAMF,EAASG,GAERqC,0BAaWC,EAAoBC,SAClCC,EAAezF,EAAewF,UACpClG,EAA6BmG,EAAc/H,EAAagB,wBAElD+G,EAAcnH,EAAIoH,IAAIH,EAASxE,kBAChCwE,SAAWA,aAVJI,iBAAP,SAAwB7E,EAAkB0E,UACxC,IAAIF,EAAerE,EAAYH,GAAU0E,+BAgB3C/E,IAAA,SAAIuB,UACCI,EAAeH,KAAKsD,SAAUvD,EAAMuD,WAA9C7F,MACO,IAAI4F,EAAerD,KAAKsD,SAAUtD,KAAK2D,IAAInF,IAAIuB,EAAM4D,SAGvD/B,SAAA,SAAS7B,UACJI,EAAeH,KAAKsD,SAAUvD,EAAMuD,WAA9C7F,MACO,IAAI4F,EAAerD,KAAKsD,SAAUtD,KAAK2D,IAAI9B,IAAI9B,EAAM4D,SAGvDxB,cAAA,SACLC,EACAC,EACAC,mBAFAF,IAAAA,EAA4B,YAE5BE,IAAAA,EAAqBhC,iBAASY,wBAEjBiB,wBAAcC,EAAmBC,EAAQC,MAGjDS,QAAA,SACLD,EACAT,EACAC,mBAFAQ,IAAAA,EAAwB9C,KAAKsD,SAASxE,mBAEtCwD,IAAAA,EAAqBhC,iBAASY,YAEpB4B,GAAiB9C,KAAKsD,SAASxE,UAAzCrB,kBACasF,kBAAQD,EAAeT,EAAQC,MAGvCsB,QAAA,SAAQvB,mBAAAA,IAAAA,EAAiB,CAAEE,eAAgB,KAChDxB,GAAIiC,GAAKhD,KAAKsD,SAASxE,SAChB,IAAIiC,GAAIf,KAAKuB,UAAUtD,YAAYM,IAAIyB,KAAKwB,YAAYvD,YAAY4C,SAASwB,MAG/EwB,YAAA,kBAAkC/H,YAAUC,KAAKiE,KAAKuB,UAAUtD,iCApCvE,kBACS+B,KAAKuB,iBAtBoBD,ICAvBwC,0BAIQC,EAAcR,8BACzBQ,EAAOR,UACRQ,MAAQA,sCAGRvF,IAAA,SAAIuB,UACCC,KAAK+D,MAAMjE,OAAOC,EAAMgE,QAAlCtG,MACO,IAAIqG,EAAY9D,KAAK+D,MAAO/D,KAAK2D,IAAInF,IAAIuB,EAAM4D,SAGjD/B,SAAA,SAAS7B,UACJC,KAAK+D,MAAMjE,OAAOC,EAAMgE,QAAlCtG,MACO,IAAIqG,EAAY9D,KAAK+D,MAAO/D,KAAK2D,IAAI9B,IAAI9B,EAAM4D,UAhBzBN,ICEpBW,0BAqBQC,EAAwBC,EAAyB1C,EAAwBD,8BACpFA,EAAWC,UAEZyC,aAAeA,IACfC,cAAgBA,IAChBC,OAAS,IAAI7C,GAChBjF,EAAIoH,IAAIQ,EAAanF,UACrBzC,EAAIoH,IAAIS,EAAcpF,sBApBZsF,UAAP,SAAiBC,EAAcC,aAC9BC,EAAkB,OAGAF,EAAMG,SAASC,0BAAW,eAAtCC,OACJC,OAAaC,UAAUP,EAAMQ,KAAKH,GAAIL,EAAMQ,KAAKH,EAAI,GAAIJ,GAC/DC,EAAOO,KAAKH,UAGPJ,EAAOQ,MAAM,GAAGC,QAAO,SAACC,EAAaC,UAAiBD,EAAYhD,SAASiD,KAAeX,EAAO,gCAuBnG9C,OAAA,kBACE,IAAIuC,EAAMhE,KAAKkE,cAAelE,KAAKiE,aAAcjE,KAAKuB,UAAWvB,KAAKwB,gBAGxES,SAAA,SAASlC,GACJI,EAAeH,KAAKkE,cAAenE,EAAMkE,eAAnDxG,UACM0H,cAAiBlD,mBAASlC,UACzB,IAAIiE,EAAMhE,KAAKiE,aAAclE,EAAMmE,cAAeiB,EAAS3D,YAAa2D,EAAS5D,cAInF6D,MAAA,SAAMvG,EAAiBwG,UAClBlF,EAAekF,EAAe/B,SAAUtD,KAAKiE,eAAvDxG,MACIuC,KAAKkE,yBAAyBtE,EACzB,IAAIkE,GAAY9D,KAAKkE,cAAeoB,YAAMrD,mBAASoD,EAAe1B,KAAKf,UAEzES,GAAeK,iBAAiB7E,EAASyG,YAAMrD,mBAASoD,EAAe1B,KAAKf,aAG9ET,cAAA,SAAcC,EAA+BC,EAAiBC,mBAAhDF,IAAAA,EAA4B,GACxCpC,KAAKuF,SAASpD,cAAcC,EAAmBC,EAAQC,MAGzDS,QAAA,SAAQD,EAA2BT,EAAiBC,mBAA5CQ,IAAAA,EAAwB,GAC9B9C,KAAKuF,SAASxC,QAAQD,EAAeT,EAAQC,wBAhCtD,kBACS,IAAIhB,GAAStB,KAAKuB,UAAWvB,KAAKwB,mCAG3C,8BACeS,mBAASjC,KAAKmE,eArCJ7C,ICkBdtF,GAAOF,YAAUC,KAAK,GAEtByJ,GAAS1J,YAAUC,KAAK,uBAI/B0J,GAAS3J,YAAUC,KAAK,yBACxB2J,GAAS5J,YAAUC,KAAK,yCAcxB4J,GAAoBH,GAAO3D,IAAI/F,YAAUC,KAAK,uBAC9C6J,GAAoBJ,GAAOhH,IAAI1C,YAAUC,KAAK,uBAK9C8J,GAAK/J,YAAUC,KAAK,yBACpB+J,GAAKhK,YAAUC,KAAK,4DACpBgK,GAAKjK,YAAUC,KAAK,wBACpBiK,GAAKlK,YAAUC,KAAK,gCAGpBkK,GAAKnK,YAAUC,KAAK,0BACpBmK,GAAKpK,YAAUC,KAAK,sCACpBoK,GAAKrK,YAAUC,KAAK,0BACpBqK,GAAKtK,YAAUC,KAAK,+BACpBsK,GAAKvK,YAAUC,KAAK,yBACpBuK,GAAKxK,YAAUC,KAAK,4BACpBwK,GAAKzK,YAAUC,KAAK,yBACpByK,GAAK1K,YAAUC,KAAK,0BACpB0K,GAAK3K,YAAUC,KAAK,yBACpB2K,GAAK5K,YAAUC,KAAK,yBACpB4K,GAAK7K,YAAUC,KAAK,yBACpB6K,GAAK9K,YAAUC,KAAK,yBACpB8K,GAAK/K,YAAUC,KAAK,wBACpB+K,GAAKhL,YAAUC,KAAK,yBACpBgL,GAAKjL,YAAUC,KAAK,wBACpBiL,GAAKlL,YAAUC,KAAK,yBACpBkL,GAAMnL,YAAUC,KAAK,wBACrBmL,GAAMpL,YAAUC,KAAK,yBACrBoL,GAAMrL,YAAUC,KAAK,uBACrBqL,GAAMtL,YAAUC,KAAK,kCAOX0H,GAAIrF,EAAcD,MAC1BA,EAAEO,GAAG,UAEE8G,MAGPpH,EAAEM,GAAG,UACE1C,OAIPqL,EAFAC,EAAWlJ,EACXmJ,EAAWpJ,KAEXwH,GAAkBlH,GAAG6I,IAAaA,EAAS7I,GAAGmH,IAAoB,KAC9D4B,EAAUC,GAAOH,GAMrBD,EAAgBG,EAAQjJ,IAAIiH,IAAQ7D,IAAI4F,GAAW/I,IAAIgJ,EAAQtE,IAAIsC,IAAQ7D,IAAI4F,GAAUhJ,IAAIiH,UAE7F6B,EAAeK,GAAIJ,GAAU3F,IAAI4F,UAK9BI,GAHPN,EAAeA,EAAa9I,IAAIiH,cAWpBmC,GAAIvJ,MAEZA,EAAEK,GAAGzC,WAIGwJ,GAAO7D,IAAI6D,IAASjH,IAAIoJ,GAAIvJ,EAAEuD,KAAK,SAmB3CiG,EACAxJ,EAAEZ,IAAIqI,KACNzH,EAAIA,EAAEyD,IAAIgE,IACV+B,EAAU9B,IACH1H,EAAEZ,IAAIuI,KACb3H,EAAIA,EAAEyD,IAAIkE,IACV6B,EAAU5B,IAEV4B,EAAU9L,YAAUC,KAAK,GAK7BqC,EAAIA,EAAEuD,IAAI,SAINkG,EAAUpC,GAEVrH,EAAEZ,IAAIyI,MACN7H,EAAIA,EAAEyD,IAAIoE,IACV4B,EAAUA,EAAQlG,IAAIuE,IAAI3H,IAAIkH,KAE9BrH,EAAEZ,IAAI2I,MACN/H,EAAIA,EAAEyD,IAAIsE,IACV0B,EAAUA,EAAQlG,IAAIyE,IAAI7H,IAAIkH,KAE9BrH,EAAEZ,IAAI6I,MACNjI,EAAIA,EAAEyD,IAAIwE,IACVwB,EAAUA,EAAQlG,IAAI2E,IAAI/H,IAAIkH,KAE9BrH,EAAEZ,IAAI+I,MACNnI,EAAIA,EAAEyD,IAAI0E,IACVsB,EAAUA,EAAQlG,IAAI6E,IAAIjI,IAAIkH,KAE9BrH,EAAEZ,IAAIiJ,MACNrI,EAAIA,EAAEyD,IAAI4E,IACVoB,EAAUA,EAAQlG,IAAI+E,IAAInI,IAAIkH,KAE9BrH,EAAEZ,IAAImJ,MACNvI,EAAIA,EAAEyD,IAAI8E,IACVkB,EAAUA,EAAQlG,IAAIiF,IAAIrI,IAAIkH,KAE9BrH,EAAEZ,IAAIqJ,MACNzI,EAAIA,EAAEyD,IAAIgF,IACVgB,EAAUA,EAAQlG,IAAImF,IAAIvI,IAAIkH,KAE9BrH,EAAEZ,IAAIuJ,MACN3I,EAAIA,EAAEyD,IAAIkF,IACVc,EAAUA,EAAQlG,IAAIqF,IAAIzI,IAAIkH,SAS9BqC,EADAC,EAAYtC,UAKhBsC,EAAYA,EAAUvJ,IADtBsJ,EAAO1J,GAMP0J,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,GACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GAE1BA,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,GACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GAE1BA,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,GACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GAE1BA,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,GACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GAE1BA,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,GACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GAE1BA,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,GACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GAE1BA,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,GACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GAE1BA,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,GACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GAE1BA,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,IACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GAE1BA,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,IACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GAE1BA,EAAOA,EAAKnG,IAAIvD,GAAGG,IAAIkH,IAAQlH,IAAI,IACnCwJ,EAAYA,EAAUvJ,IAAIsJ,GASjBD,EAAQlG,IAAIoG,GAAYxJ,IAAIkH,IAAQ9D,IAAIiG,GAAUrJ,IAAI,cA8CnDmJ,GAAIM,MACZA,EAAEvJ,GAAG+G,WAIGkC,GAAKlC,GAAO7D,IAAI6D,IAASjH,IAAIyJ,IAAKrG,KAAK,OAkB/CsG,EAAMjM,GACNgM,EAAExK,IAAIsI,GAAGnE,IAAI6D,OACbwC,EAAIA,EAAEzJ,IAAIuH,IACVmC,EAAMA,EAAIzJ,IAAIqH,KAGdmC,EAAExK,IAAIwI,GAAGrE,IAAI6D,OACbwC,EAAIA,EAAEzJ,IAAIyH,IACViC,EAAMA,EAAIzJ,IAAIuH,KAIlBkC,EAAMA,EAAItG,IAAI,MACdqG,EAAIA,EAAErG,IAAI,MAIJnE,IAAI0I,MACN8B,EAAIA,EAAErG,IAAI8D,IAAQlH,IAAI2H,IACtB+B,EAAMA,EAAIzJ,IAAIyH,KAGd+B,EAAExK,IAAI4I,MACN4B,EAAIA,EAAErG,IAAI8D,IAAQlH,IAAI6H,IACtB6B,EAAMA,EAAIzJ,IAAI2H,KAGd6B,EAAExK,IAAI8I,MACN0B,EAAIA,EAAErG,IAAI8D,IAAQlH,IAAI+H,IACtB2B,EAAMA,EAAIzJ,IAAI6H,KAGd2B,EAAExK,IAAIgJ,MACNwB,EAAIA,EAAErG,IAAI8D,IAAQlH,IAAIiI,IACtByB,EAAMA,EAAIzJ,IAAI+H,KAGdyB,EAAExK,IAAIkJ,MACNsB,EAAIA,EAAErG,IAAI8D,IAAQlH,IAAImI,IACtBuB,EAAMA,EAAIzJ,IAAIiI,KAGduB,EAAExK,IAAIoJ,MACNoB,EAAIA,EAAErG,IAAI8D,IAAQlH,IAAIqI,IACtBqB,EAAMA,EAAIzJ,IAAImI,KAGdqB,EAAExK,IAAIsJ,MACNkB,EAAIA,EAAErG,IAAI8D,IAAQlH,IAAIuI,IACtBmB,EAAMA,EAAIzJ,IAAIqI,KAGdmB,EAAExK,IAAIwJ,MACNgB,EAAIA,EAAErG,IAAI8D,IAAQlH,IAAIyI,IACtBiB,EAAMA,EAAIzJ,IAAIuI,KAGdiB,EAAExK,IAAI0J,MACNc,EAAIA,EAAErG,IAAI8D,IAAQlH,IAAI2I,IACtBe,EAAMA,EAAIzJ,IAAIyI,KAGde,EAAExK,IAAI4J,MACNY,EAAIA,EAAErG,IAAI8D,IAAQlH,IAAI6I,IACtBa,EAAMA,EAAIzJ,IAAI2I,SAUd9I,EAAM2J,EAAEnG,IAAI4D,IAAS9D,IAAI8D,IAASlH,IAAIyJ,EAAExJ,IAAIiH,KAC5CyC,EAAa7J,EAAEsD,IAAItD,GAAIE,IAAIkH,IAG3B0C,EAAM9J,EAGN0J,EAAYI,SAGhBA,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAIkH,IAC7BsC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,IAElC4J,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAIkH,IAC7BsC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,IAElC4J,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAIkH,IAC7BsC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,IAElC4J,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAIkH,IAC7BsC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,IAElC4J,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAIkH,IAM7BsC,GALAA,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,MAKZoD,IAAI,GAMnBsG,EAAIzJ,IAAIuJ,GAAWxJ,IAAI,cASlBkJ,GAAOrJ,OAYfC,GAPJD,EAAIA,EAAEuD,IAAI6D,KAOA3D,IAAI6D,IAAQ/D,IAAI+D,IAAQnH,IAAIH,EAAEI,IAAIkH,KACxCwC,EAAY7J,EAAEsD,IAAItD,GAAGE,IAAImH,IAGzByC,EAAM9J,EAGN0J,EAAYI,SAGhBA,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAImH,IAC7BqC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,IAElC4J,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAImH,IAC7BqC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,IAElC4J,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAImH,IAC7BqC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,IAElC4J,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAImH,IAC7BqC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,IAElC4J,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAImH,IAC7BqC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,KAElC4J,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAImH,IAC7BqC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,KAElC4J,EAAMA,EAAIxG,IAAIuG,GAAW3J,IAAImH,KAC7BqC,EAAYA,EAAUvJ,IAAI2J,EAAI5J,IAAI,MAKjBoD,IAAI,OCleZ1F,GAAMuJ,GAIb4C,GAAyBtM,YAAUC,KAAK,KAGjCsM,GAA6BvM,YAAUC,KAAK,+BAGzCuM,GAAQN,EAAcO,UAClBP,EAAErG,IAAI4G,GAEPhK,IAAItC,aAGPuM,GAAMR,EAAcO,OAC1BV,EAAUG,EAAErG,IAAI4G,UAElBV,EAAQnJ,GAAG,GACJ5C,YAAUC,KAAK,GAQd8L,EAAQhG,IAAI,GAAGtD,IAAItC,IAAMuC,IAAI,YAI7BiK,GAAQT,EAAcO,UAE9BP,EAAEtJ,GAAG1C,IACEA,GAESgM,EAAErG,IAAI1F,IACLsC,IAAIgK,YAIbG,GAAMV,EAAcO,UAE5BP,EAAEtJ,GAAG1C,IACEA,GAESgM,EAAErG,IAAI1F,IAQL4F,IAAI,GAAGtD,IAAIgK,GAAG/J,IAAI,YAQ3BmK,GAAQvK,EAAcD,OAC9BwF,EAAMF,GAAIrF,EAAGD,GACbyK,EAAWJ,GAAM7E,EAAKyE,IAAwB5J,IAAI,UAElDmF,EAAIlF,GAAGmK,GACA5M,GAEA2H,EAAI9B,IAAI+G,YAQPC,GAAMzK,EAAcD,OAC1BwF,EAAMF,GAAIrF,EAAGD,GACbyK,EAAWJ,GAAM7E,EAAKyE,IAAwB5J,IAAI,UAEjDmF,EAAInF,IAAIoK,YASHE,GAAW1K,UAChBA,EAAEK,GAAGxC,IAAOA,GAAI4F,IAAIzD,GAAKpC,YAOpB+M,GAAIf,EAAcO,UACvBP,EAAExK,IAAI+K,GAAKP,EAAIO,EC5E1B,IAAMS,GAAgBlN,YAAUC,KAAK,sBAC/BkN,GAAiBnN,YAAUC,KAAK,sBAGhCmN,GAAuBpN,YAAUC,KAAK,uBAEtCoN,GAAuBrN,YAAUC,KAAK,+BAkC5BqN,GACZC,EACAC,EACAC,EACAC,EACAC,GAkBUA,EAAS/L,IAAI4K,GAAQe,EAAWL,MAA1CvL,UAEM+D,EAAc6H,EAAU7K,IAAIiL,UAK3BnB,GAAQiB,EAAYT,GAFbD,GAFDH,GAAMW,EAAW7H,GACbiH,GAAQa,EAAUE,eAQvBE,GACZL,EACAC,EACAC,EACAC,EACAG,UAkBUA,EAAUjM,IAAI4K,GAAQiB,EAAYN,MAA5CxL,MAUO+K,GAAMa,EANCR,GAFDH,GAAMa,EAAYA,EAAW1H,IAAI8H,IAC7BjB,GAAMc,EAAWF,IAKdzH,IAAI5F,cAKZ2N,GACZC,EACAC,EACAC,EACAC,EACAC,WAIIC,EAAuB,GAEvBC,EAAyBnO,GACpB0I,EAAI,EAAGA,EAAImF,EAASO,OAAQ1F,IACjCwF,EAAqBpF,KAAK2D,GAAQoB,EAASnF,GAAGlG,IAAIuL,EAAUrF,IAAKmF,EAASnF,KAC1EyF,EAAyBA,EAAuB3L,IAAI8J,GAAQ4B,EAAqBxF,GAAIoF,EAAkBpF,WAGtE2F,GACjCR,EACAC,EACAC,EACAG,EACAC,EACAF,GANIK,IAAAA,eAAgBC,IAAAA,eAUjB,CAAEC,MADKF,EAAehM,GAAGrC,IAAOqM,GAAQ0B,EAAeM,EAAezI,IAAI5F,KAAQD,GACzEuO,SAAAA,YAMJF,GACZR,EACAC,EACAC,EACAG,EACAC,EACAF,WAIIM,EAAW,GACXD,EAAiBrO,GAEZyI,EAAI,EAAGA,EAAImF,EAASO,OAAQ1F,IAAK,KAClC+F,YAEAP,EAAqBxF,GAAGpG,GAAG6L,GAAyB,KAC9CO,EAAmBpC,GAAQuB,EAASnF,GAAIyF,EAAuBtI,IAAI5F,KACnE0O,EAAgBZ,EAAUrF,GAAG7C,IAAI6I,GACjCE,EAAUpC,GAAMmC,EAAeV,GAErCQ,EAAqBC,EAAiBlM,IAAImM,EAAc9I,IAAI+I,IAC5DL,EAAS7F,GAAKkG,OAEdH,EAAqBV,EAAUrF,GAKnC4F,EAAiBhC,GAAQgC,EAAgB3B,GAFpBF,GAAQoB,EAASnF,GAAGlG,IAAIiM,GAAqBZ,EAASnF,IAEZoF,EAAkBpF,WAG9E,CAAE4F,eAAAA,EAAgBC,SAAAA,GA4C7B,SAAgBM,GACZhB,EACAiB,EACAC,WAYMC,EAAUtC,GAAMoC,EAAaC,GAE/BhB,EAAY,GACPrF,EAAI,EAAGA,EAAImF,EAASO,OAAQ1F,IACjCqF,EAAUjF,KAAK0D,GAAMqB,EAASnF,GAAIsG,WAG/BjB,WAGKkB,GACZpB,EACAC,EACAoB,EACAlB,EACAC,WAIIkB,EAA0BC,MAAMvB,EAASO,QACzCiB,EAA4BrP,GACvB0I,EAAI,EAAGA,EAAImF,EAASO,OAAQ1F,IACjCyG,EAAwBzG,GAAKgE,GAAMmB,EAASnF,GAAG7C,IAAIqJ,EAAWxG,IAAKmF,EAASnF,IAC5E2G,EAA4BA,EAA0B7M,IAAIgK,GAAM2C,EAAwBzG,GAAIoF,EAAkBpF,WAG7E4G,GACjCzB,EACAC,EACAoB,EACAC,EACAE,EACApB,GANoBM,IAAAA,eAUjB,CAAEgB,KADI/C,GAAMwB,EAAelB,KAT1BwB,iBAUOC,SAAAA,YAMHe,GACZzB,EACAC,EACAoB,EACAC,EACAE,EACApB,WAEIM,EAAWa,MAAMvB,EAASO,QAC1BE,EAAiBrO,GAEZyI,EAAI,EAAGA,EAAImF,EAASO,OAAQ1F,IAAK,KAIlC8G,YACAH,EAA0B/M,GAAG6M,EAAwBzG,IAAK,KACpDgG,EAAmBpC,GAAQuB,EAASnF,GAAIoE,GAAWuC,IACnDV,EAAgBO,EAAWxG,GAAG7C,IAAI6I,GAClCe,EAAwB/C,GAAMiC,EAAe1O,GAAI4F,IAAIoI,IAE3DM,EAAS7F,GAAK+G,EAAsB5J,IAAI8I,GACxCa,EAAmBd,EAAiBlM,IAAIiN,QAExCD,EAAmBN,EAAWxG,GAKlC4F,EAAiBhC,GAAQgC,EAAgB3B,GAFpBF,GAAQoB,EAASnF,GAAG7C,IAAI2J,GAAmB3B,EAASnF,IAEVoF,EAAkBpF,WAG9E,CAAE4F,eAAAA,EAAgBC,SAAAA,YAGbmB,GACZC,EACAC,EACAC,EACA7B,EACAC,OAeMK,EAAiB5B,GAAMsB,EAAcnI,IAAIgK,GAAa7B,GAClDM,GAAkBnB,IAA5B1L,UAMMqO,EAAsBxD,GAAQqD,EAAS7C,GAHxBD,GAAMyB,EAAgB7B,GAAQxM,GAAK2P,MAWlDjB,EAAgBnC,GAAMsD,EAJFhD,GAAW8C,IAK/BlB,EAAmBoB,EAAoBjK,IAAI8I,GAE3CC,EAAUpC,GAAMmC,EAAeV,SAC9B,CACHW,QAAAA,EACAjB,UAAWe,EAAiBlM,IAAImM,EAAc9I,IAAI+I,KCxX1D,IAAMmB,GAAkBvG,YAERwG,GACZC,EACAC,EACAC,EACAC,EACAC,UAEOX,GACHW,EAAcH,GAAUvK,IAAIsK,EAAKK,iBAAiBJ,IAClDD,EAAKnC,kBAAkBoC,GACvBC,EACAC,EACAH,EAAKM,KAIb,SAAgBC,GACZP,EACAE,EACAC,EACCC,UAGMxB,GACH4B,GAAIJ,EAAeJ,EAAKK,kBACxBH,EACAC,YAOQM,GACZT,EACAU,EACAP,EACAQ,EACAP,UAGIO,EACkBhD,GACd6C,GAAIJ,EAAeJ,EAAKK,kBACxBL,EAAKnC,kBACL2C,GAAIE,EAASV,EAAKK,kBAClBF,EACAH,EAAKM,KALD/B,MASSS,GACbwB,GAAIJ,EAAeJ,EAAKK,kBACxBL,EAAKnC,kBACL2C,GAAIE,EAASV,EAAKK,kBAClBF,EACAH,EAAKM,KALDhB,cAaAsB,GAAqBZ,EAA2Ba,EAAiBZ,EAAkBzC,EAAqB4C,OAE9GU,EAAkBtD,EAAS9H,IAAIsK,EAAKK,iBAAiBQ,IAAUnL,IAAIoK,GAAgBlK,IAAIoK,EAAKM,aAGlFnD,GACZiD,EAAcS,GAASnL,IAAIsK,EAAKK,iBAAiBQ,IAAUnL,IAAIoK,IAC/DE,EAAKnC,kBAAkBgD,GACvBT,EAAcH,GAAUvK,IAAIsK,EAAKK,iBAAiBJ,IAAWvK,IAAIoK,IACjEE,EAAKnC,kBAAkBoC,GACvBa,GAIaxO,IAAIwN,IAAiBxN,IAAI0N,EAAKK,iBAAiBJ,aAKpDc,GAAsBf,EAA2Ba,EAAiBZ,EAAkBvC,EAAqB0C,UAEpG3C,GACb2C,EAAcS,GAASnL,IAAIsK,EAAKK,iBAAiBQ,IAAUnL,IAAIoK,IAC/DE,EAAKnC,kBAAkBgD,GACvBT,EAAcH,GAAUvK,IAAIsK,EAAKK,iBAAiBJ,IAAWvK,IAAIoK,IACjEE,EAAKnC,kBAAkBoC,GACvBvC,EAAUhI,IAAIsK,EAAKK,iBAAiBJ,IAAWvK,IAAIoK,KAGvCxN,IAAIwN,GAAgBlK,IAAIoK,EAAKM,MAAMhO,IAAI0N,EAAKK,iBAAiBQ,IAAUtO,IAAI,YAI/EiO,GAAI5C,EAAuBoD,WACnCC,EAAS,GACJxI,EAAI,EAAGA,EAAImF,EAASO,OAAQ1F,IACjCwI,EAAOpI,KAAKmI,EAAMvI,GAAG/C,IAAIkI,EAASnF,YAE/BwI,MC7GLlR,GAAOF,YAAUC,KAAK,GACtBE,GAAMH,YAAUC,KAAK,GACrBG,GAAMJ,YAAUC,KAAK,GACrBoR,GAAOrR,YAAUC,KAAK,KACtBqR,GAAOtR,YAAUC,KAAK,OACtBsR,GAAOvR,YAAUC,KAAK,OAItBuR,GAAUxR,YAAUC,KAAK,uCACzBwR,GAAUzR,YAAUC,KAAK,uCACzByR,GAAU1R,YAAUC,KAAK,uCAEzB0R,GAAgB3R,YAAUC,KAAK,qCAC/B2R,GAAkB5R,YAAUC,KAAK,qCAEjC4R,GAAkB7R,YAAUC,KAAK,uCACjC6R,GAAkB9R,YAAUC,KAAK,uCASjC8R,GAAc,IAAIzC,MAAiB,KAkGzC,SAAS0C,GAAU3F,EAAgB4F,UACxB5F,EAAIxG,IAAIzF,GAAIuH,IAAIsK,IAG3B,SAASC,GAAiB7F,EAAgB4F,UAC/B5F,EAAI5J,IAAIrC,GAAIuH,IAAIsK,IAqB3B,SAAgBE,GACZC,EACAC,EACAC,EACAC,GAEUH,EAAO5P,GAAG6P,IAApB1Q,MACUyQ,EAAOzP,GAAG+O,KAApB/P,UAGI6Q,EAAQJ,EAAOvM,IAAI2L,IAAU/O,IAAI4P,GAOjCI,GANAD,EAAK7P,GAAGkP,IACEa,GAAWF,GAEXG,GAAWH,IAGM3M,IAAIyM,GAAQ7P,IAAI8P,MAC3CE,EAAgB9P,GAAGmP,UACZ,CAACc,GAAWH,GAlKL,SAoKV5L,EAAYgM,GAA0BJ,SACnC,CAACK,GAAWZ,GAAiBO,EAAiBzS,YAAUC,KArKjD,IAqKsE4G,IAAa7G,YAAUC,KAAK4G,IAAaA,YAgCrH8L,GAAWrQ,OACnByQ,EAAM7S,MAENoC,EAAEZ,IAAI+P,IAAU,KACVuB,EA7Bd,SAAmBC,OACXF,EAAM7S,MACN+S,EAAGtQ,GAAG2O,SAEC2B,EAAGzQ,GAAGrC,KACT8S,EAAKf,GAAiBe,EAAI9S,IAC1B4S,EAAMA,EAAIrQ,IAAIvC,aAIb,IAAI+S,EAAI3B,GAAM2B,EAAE1Q,GAAGtC,IAAOgT,EAAIhB,GAAiBgB,EAAG/S,IAC/C8S,EAAGzQ,GAAGwP,GAAU7R,GAAK+S,MACrBD,EAAKf,GAAiBe,EAAIC,GAC1BH,EAAMA,EAAII,GAAGD,WAKlBH,EAWWK,CAAU9Q,EAAEG,IAAI+O,KAC9BlP,EAAI4P,GAAiB5P,EAAG0Q,GAExBD,EAAMC,EAAMnN,IAAI2L,OAIhBlP,EAAEE,GAAGgP,QACA,IAAI5I,EAjNK,IAiNcA,EAAI,IAAKA,GACjCtG,EAAKA,EAAEuD,IAAIvD,GAAIG,IAAI+O,KAEb9P,IAAI+P,MACNnP,EAAI4P,GAAiB5P,EAAGnC,IAExB4S,EAAMA,EAAIrQ,IAAIsP,GAAU7R,GAAKH,YAAUC,KAAK2I,EAAI,aAKpDmK,EAAIlN,IAAI8L,IAAgBlP,IAAImP,aAcxBc,GAAWpQ,OAGnBD,EACAE,EACA8Q,EAJAN,EAAM7S,UAMNoC,EAAEZ,IAAI,wCACNqR,EAAMA,EAAIrQ,IAAI1C,YAAUC,KAAK,uCAC7BqC,EAAKA,EAAEuD,IAAI2L,IAAU/O,IAAIzC,YAAUC,KAAK,wCAGxCqC,EAAEZ,IAAI,wCACNqR,EAAMA,EAAIrQ,IAAI1C,YAAUC,KAAK,uCAC7BqC,EAAKA,EAAEuD,IAAI2L,IAAU/O,IAAIzC,YAAUC,KAAK,wCAGxCqC,EAAEZ,IAAI,wCACNqR,EAAMA,EAAIrQ,IAAI1C,YAAUC,KAAK,uCAC7BqC,EAAKA,EAAEuD,IAAI2L,IAAU/O,IAAIzC,YAAUC,KAAK,wCAGxCqC,EAAEZ,IAAI,wCACNqR,EAAMA,EAAIrQ,IAAI1C,YAAUC,KAAK,uCAC7BqC,EAAKA,EAAEuD,IAAI2L,IAAU/O,IAAIzC,YAAUC,KAAK,wCAGxCqC,EAAEZ,IAAI,wCACNqR,EAAMA,EAAIrQ,IAAI1C,YAAUC,KAAK,uCAC7BqC,EAAKA,EAAEuD,IAAI2L,IAAU/O,IAAIzC,YAAUC,KAAK,wCAGxCqC,EAAEZ,IAAI,wCACNqR,EAAMA,EAAIrQ,IAAI1C,YAAUC,KAAK,uCAC7BqC,EAAKA,EAAEuD,IAAI2L,IAAU/O,IAAIzC,YAAUC,KAAK,wCAGxCqC,EAAEZ,IAAI,wCACNqR,EAAMA,EAAIrQ,IAAI1C,YAAUC,KAAK,uCAC7BqC,EAAKA,EAAEuD,IAAI2L,IAAU/O,IAAIzC,YAAUC,KAAK,wCAGxCqC,EAAEZ,IAAI,wCACNqR,EAAMA,EAAIrQ,IAAI1C,YAAUC,KAAK,uCAC7BqC,EAAKA,EAAEuD,IAAI2L,IAAU/O,IAAIzC,YAAUC,KAAK,wCAI5CsC,EAAIF,EAAIC,EAAEyD,IAAIyL,IACd6B,EAAKhR,EAAEwD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,uCAAuC8F,IAAI1D,IAAII,IAAIzC,YAAUC,KAAK,yCACrGsC,EAAKA,EAAEsD,IAAIwN,GAAI5Q,IAAI+O,IAEnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,uCAAuC8F,IAAI1D,IAAII,IAAIzC,YAAUC,KAAK,yCACrGsC,EAAKA,EAAEsD,IAAIwN,GAAI5Q,IAAI+O,IAEnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,uCAAuC8F,IAAI1D,IAAII,IAAIzC,YAAUC,KAAK,yCACrGsC,EAAKA,EAAEsD,IAAIwN,GAAI5Q,IAAI+O,IAEnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,uCAAuC8F,IAAI1D,IAAII,IAAIzC,YAAUC,KAAK,yCACrGsC,EAAKA,EAAEsD,IAAIwN,GAAI5Q,IAAI+O,IAEnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,uCAAuC8F,IAAI1D,IAAII,IAAIzC,YAAUC,KAAK,yCACrGsC,EAAKA,EAAEsD,IAAIwN,GAAI5Q,IAAI+O,IAEnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,uCAAuC8F,IAAI1D,IAAII,IAAIzC,YAAUC,KAAK,yCACrGsC,EAAKA,EAAEsD,IAAIwN,GAAI5Q,IAAI+O,IAEnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,uCAAuC8F,IAAI1D,IAAII,IAAIzC,YAAUC,KAAK,yCACrGsC,EAAKA,EAAEsD,IAAIwN,GAAI5Q,IAAI+O,IAEbuB,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,uCAAuC8F,IAAI1D,IAAII,IAAIzC,YAAUC,KAAK,kDAMzF2S,GAAWtQ,OAGnBD,EACAE,EAHAwQ,EAAM7S,UAOVqC,GAFAA,EAAIF,EAAIC,EAAE8E,IAAIpH,YAAUC,KAAK,wCAEtB4F,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IACnBuB,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,wBAEnCsC,EAAKA,EAAEsD,IAAIxD,GAAII,IAAI+O,IAGnBuB,GAFAA,EAAMA,EAAIrQ,IAAIH,EAAEsD,IAAI7F,YAAUC,KAAK,yBAEzBwC,IAAIzC,YAAUC,KAAK,uBAAuByC,IAAIL,GAAGK,IAAI8O,IAGzDlP,EAAEgR,IAAItT,YAAUC,KAAK,wCAAwCsT,WAAWR,EAAOA,EAAIlN,IAAI7F,YAAUC,KAAK,wCAAyCwC,IAAIzC,YAAUC,KAAK,yCAElKqC,EAAEgR,IAAItT,YAAUC,KAAK,wCAAwCsT,WAAWR,EAAOA,EAAIlN,IAAI7F,YAAUC,KAAK,wCAAyCwC,IAAIzC,YAAUC,KAAK,yCAElKqC,EAAEgR,IAAItT,YAAUC,KAAK,wCAAwCsT,WAAWR,EAAOA,EAAIlN,IAAI7F,YAAUC,KAAK,wCAAyCwC,IAAIzC,YAAUC,KAAK,yCAElKqC,EAAEgR,IAAItT,YAAUC,KAAK,wCAAwCsT,WAAWR,EAAOA,EAAIlN,IAAI7F,YAAUC,KAAK,wCAAyCwC,IAAIzC,YAAUC,KAAK,yCAElKqC,EAAEgR,IAAItT,YAAUC,KAAK,wCAAwCsT,WAAWR,EAAOA,EAAIlN,IAAI7F,YAAUC,KAAK,wCAAyCwC,IAAIzC,YAAUC,KAAK,yCAElKqC,EAAEgR,IAAItT,YAAUC,KAAK,wCAAwCsT,WAAWR,EAAOA,EAAIlN,IAAI7F,YAAUC,KAAK,wCAAyCwC,IAAIzC,YAAUC,KAAK,yCAElKqC,EAAEgR,IAAItT,YAAUC,KAAK,wCAAwCsT,WAAWR,EAAOA,EAAIlN,IAAI7F,YAAUC,KAAK,wCAAyCwC,IAAIzC,YAAUC,KAAK,yCAGjK8S,WAUKD,GAAWU,EAAeC,OAClCC,EAAKF,EACLT,EAAM7S,UAEVwT,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,GAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,sCAErB6N,EAAKxB,GAAiBwB,EAAG7N,IAAI2N,GAAKC,IAClCV,EAAMA,EAAIrQ,IAAIgR,EAAG7N,IAAI,uCAITpD,IAAIzC,YAAUC,KAAK,sCAAuCyC,IAAI8Q,GAAI9Q,IAAIsP,GAAU7R,GAAKsT,aASrFZ,GAA0BW,WAClCG,EArgBc,GAsgBdC,EArgBc,IAugBXD,EAAK,EAAIC,GAAI,KACZC,GAAOF,EAAKC,GAAM,EAClB7B,GAAY8B,GAAKnS,IAAI8R,GAAKG,EAAKE,EAC9BD,EAAKC,SAGV9B,GAAY6B,GAAIlS,IAAI8R,GAAYI,EAChC7B,GAAY4B,GAAIjS,IAAI8R,GAAYG,OAEpChS,eAkBYmS,GACZnG,EACAoG,EACAC,EACAC,EACAC,EACApF,GAGUnB,EAASnL,GAAGtC,KAAtByB,MAIUoS,EAAUvR,GAAGtC,KAAS8T,EAAWxR,GAAGtC,KAA9CyB,UACMsP,EAAkBtD,EAAS9H,IAAIwL,GAAKtL,IAAI+I,OAE1CmF,EAAcrR,GAAGsR,UACTF,EAAWnO,IAAIoL,GAAkBxO,IAAIsR,EAAUlO,IAAIwL,IAAM3O,IAAIuO,UAM7CkB,GADb4B,EAAUlO,IAAIwL,IAAO3O,IAAIuO,GACC8C,EAAUlO,IAAIwL,IAAO4C,EAAeC,GAAtE9C,OAAQvK,OAETsN,EAAQH,EAAWnO,IAAIuL,GACvBgD,EAAQpC,GAAUgC,EAAYhU,YAAUC,KAAK4G,WAE3CsN,EAAMpO,IAAIqO,GAAQ3R,IAAI2O,YAkBlBiD,GACZxG,EACAkG,EACAC,EACAC,EACAC,EACApF,MAGUjB,EAAUrL,GAAGtC,KAAvByB,MAKUoS,EAAUvR,GAAGtC,KAAS8T,EAAWxR,GAAGtC,KAA9CyB,MAEIsS,EAAcrR,GAAGsR,GAAiB,KAC5BzO,EAAYsO,EAAUlO,IAAIgI,GAAWhI,IAAIwL,IACzC3L,EAAcsO,EAAWjO,IAAI8H,GAAWhI,IAAIwL,GAAKtL,IAAI+I,WACnDrJ,EAAUhD,IAAIiD,GAAchD,IAAI,OAGtC4R,EAAQN,EAAWjO,IAAI8H,KACDsE,GAAM6B,EAAYM,EAAOJ,EAAgBD,GAA9D7C,OAAQvK,OACT0N,EAAgBR,EAAUlO,IAAIwL,IAC9B8C,EAAQI,EAAc1O,IAAIuL,GAC1BgD,EAAQpC,GAAUuC,EAAevU,YAAUC,KAAK4G,WAC9CqL,GAAiBiC,EAAMpO,IAAIqO,GAAQpU,YAAUC,KAAK4G,IAAYpE,IAAI4O,GAAKtL,IAAI+I,IAAWpM,IAAI,GAvlBtGqP,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,IAAM/R,YAAUC,KAAK,wCACjC8R,GAAY,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"}