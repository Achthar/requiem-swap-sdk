{"version":3,"file":"sdk.cjs.production.min.js","sources":["../src/constants.ts","../src/errors.ts","../src/helperUtils.ts","../src/entities/currency.ts","../src/entities/token.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/percent.ts","../src/entities/fractions/currencyAmount.ts","../src/entities/fractions/tokenAmount.ts","../src/entities/fractions/price.ts","../src/entities/calculators/LogExpMath.ts","../src/entities/calculators/FixedPoint.ts","../src/entities/calculators/WeightedMath.ts","../src/entities/calculators/WeightedPoolLib.ts","../src/entities/calculators/weightedPairCalc.ts","../src/entities/pools/pool.ts","../src/entities/calculators/weightedSwapStorage.ts","../src/entities/calculators/stableSwapStorage.ts","../src/entities/pools/weightedPair/amplifiedWeightedPair.ts","../src/entities/pools/weightedPool/weightedPool.ts","../src/entities/calculators/stableCalc.ts","../src/entities/pools/stable/stablePool.ts","../src/entities/pools/swapData.ts","../src/entities/pools/pairData.ts","../src/entities/bonds/bondCalculator.ts","../src/entities/bonds/fixedPoint.ts","../src/entities/bonds/bondDepository.ts","../src/entities/route.ts","../src/entities/swap.ts","../src/entities/swapRoute.ts","../src/routeProvider.ts","../src/swapRouter.ts"],"sourcesContent":["import { BigNumber } from 'ethers'\n\n// exports for external consumption\nexport type BigintIsh = BigNumber | bigint | string | number\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport const FACTORY_ADDRESS: { [chainId: number]: string } = {\n  56: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n  97: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n  80001: '0xf10Bd0dA1f0e69c3334D7F8116C9082746EBC1B4',\n  43113: '0xFb94c4CeA93f8369Fe18C3078060605eE2B14eC3',\n}\n\nexport const WEIGHTED_FACTORY_ADDRESS: { [chainId: number]: string } = {\n  43113: '0xacd3602152763C3AAFA705D8a90C36661ecD7d46',\n  42261: '0x0459e858F17ef5D927625f34602432f4fac6941e',\n  110001: '0xe092CB3124aF36a0B851839D8EC51CaaD9a3DCD0'\n}\n\n// export const INIT_CODE_HASH = '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5'\n\n\nexport const INIT_CODE_HASH: { [chainId: number]: string } = {\n  56: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',\n  97: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',\n  80001: '0xc2b3644608b464a0df0eb711ce9c6ce7535d1bd4d0154b8389738a3e7fbb1a61',\n  43113: '0x98fcd7ed545dc443aa0c7e57e5f54affba6cf755a7eadfd269143f9bf62024d8',\n}\n\nexport const INIT_CODE_HASH_WEIGHTED: { [chainId: number]: string } = {\n  43113: '0xbeec252b6527ff023d9f20fa336f9f131a002be662ce64ef7f9ed17b5ea8b591',\n  42261: '0x98fcd7ed545dc443aa0c7e57e5f54affba6cf755a7eadfd269143f9bf62024d8',\n  110001: '0x98fcd7ed545dc443aa0c7e57e5f54affba6cf755a7eadfd269143f9bf62024d8'\n}\n\nexport const STABLE_POOL_ADDRESS: { [chainId: number]: string } = {\n  43113: '0x0Be60C571BdA7841D8F6eE68afDBa648EC710fD7',\n  42261: '0x2a90276992ddC21C3585FE50f5B43D0Cf62aDe03',\n  110001: '0x211F00f4071A4af8f0cC289d9853d778047DB8Ba',\n}\n\nexport const STABLE_POOL_LP_ADDRESS: { [chainId: number]: string } = {\n  43113: '0x3372de341a07418765ae12f77aee9029eaa4442a',\n  42261: '0x9364E91ca784ca51f88dE2a76a35Ba2665bdad04',\n  110001: '0x029f9f8e2c27627341824120ee814F31a1551256'\n}\n\nexport const MINIMUM_LIQUIDITY = BigNumber.from(1000)\n\n// exports for internal consumption\nexport const ZERO = BigNumber.from(0)\nexport const ONE = BigNumber.from(1)\nexport const TWO = BigNumber.from(2)\nexport const THREE = BigNumber.from(3)\nexport const FIVE = BigNumber.from(5)\nexport const TEN = BigNumber.from(10)\nexport const TENK = BigNumber.from(10000)\nexport const _100 = BigNumber.from(100)\nexport const FEES_NUMERATOR = BigNumber.from(9975)\nexport const FEES_DENOMINATOR = BigNumber.from(10000)\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: BigNumber.from('0xff'),\n  [SolidityType.uint256]: BigNumber.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\nimport { BigNumber } from 'ethers'\n\nexport function validateSolidityTypeInstance(value: BigNumber, solidityType: SolidityType): void {\n  invariant(value.gte(ZERO), `${value} is not a ${solidityType}.`)\n  invariant(value.lte(SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): BigNumber {\n  return bigintIsh instanceof BigNumber\n    ? bigintIsh\n    : typeof bigintIsh === 'bigint'\n    ? BigNumber.from(bigintIsh.toString())\n    : BigNumber.from(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: BigNumber): BigNumber {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: BigNumber = ZERO\n  let x: BigNumber\n  if (y.gt(THREE)) {\n    z = y\n    x = y.div(TWO).add(ONE)\n    while (x.lt(z)) {\n      z = x\n      x = y.div(x).add( x).div(TWO)\n    }\n  } else if (!y.eq(ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n","/**\n * A currency is any fungible financial instrument on Ethereum, including Ether and all ERC20 tokens.\n *\n * The only instance of the base class `Currency` is Ether.\n */\nexport class Currency {\n  public readonly decimals: number\n  public readonly chainId: number\n  public readonly symbol?: string\n  public readonly name?: string\n\n  /**\n   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.ETHER`.\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  constructor(chainId: number, decimals: number, symbol?: string, name?: string) {\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n    this.chainId = chainId\n  }\n}\n\n\nexport enum ChainId {\n  TT_MAINNET = 108,\n  TT_TESTNET = 18,\n  BSC_MAINNET = 56,\n  BSC_TESTNET = 97,\n  AVAX_MAINNET = 43114,\n  AVAX_TESTNET = 43113,\n  ARBITRUM_MAINNET = 42161,\n  ARBITRUM_TETSNET_RINKEBY = 421611,\n  MATIC_MAINNET = 137,\n  MATIC_TESTNET = 80001,\n  OASIS_TESTNET = 42261,\n  OASIS_MAINNET = 42262,\n  QUARKCHAIN_DEV_S0 = 110001,\n}\n\nexport const NETWORK_CCY: { [chainId: number]: Currency } = {\n  [ChainId.TT_MAINNET]: new Currency(ChainId.TT_MAINNET, 18, 'TT', 'TT'),\n  [ChainId.TT_TESTNET]: new Currency(ChainId.TT_TESTNET, 18, 'TT', 'TT'),\n  [ChainId.BSC_MAINNET]: new Currency(ChainId.BSC_MAINNET, 18, 'BNB', 'BNB'),\n  [ChainId.BSC_TESTNET]: new Currency(ChainId.BSC_TESTNET, 18, 'BNB', 'BNB'),\n  [ChainId.ARBITRUM_MAINNET]: new Currency(ChainId.ARBITRUM_MAINNET, 18, 'ETH', 'ETH'),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Currency(ChainId.ARBITRUM_TETSNET_RINKEBY, 18, 'ETH', 'ETH'),\n  [ChainId.AVAX_MAINNET]: new Currency(ChainId.AVAX_MAINNET, 18, 'AVAX', 'AVAX'),\n  [ChainId.AVAX_TESTNET]: new Currency(ChainId.AVAX_TESTNET, 18, 'AVAX', 'AVAX'),\n  [ChainId.MATIC_MAINNET]: new Currency(ChainId.MATIC_MAINNET, 18, 'MATIC', 'MATIC'),\n  [ChainId.MATIC_TESTNET]: new Currency(ChainId.MATIC_TESTNET, 18, 'MATIC', 'MATIC'),\n  [ChainId.OASIS_MAINNET]: new Currency(ChainId.OASIS_MAINNET, 18, 'ROSE', 'ROSE'),\n  [ChainId.OASIS_TESTNET]: new Currency(ChainId.OASIS_TESTNET, 18, 'ROSE', 'ROSE'),\n  [ChainId.QUARKCHAIN_DEV_S0]: new Currency(ChainId.QUARKCHAIN_DEV_S0, 18, 'QKC', 'QKC')\n}\n","import invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from '../helperUtils'\nimport { Currency, ChainId } from './currency'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token extends Currency {\n  public readonly address: string\n  public readonly projectLink?: string\n\n  public constructor(\n    chainId: ChainId,\n    address: string,\n    decimals: number,\n    symbol?: string,\n    name?: string,\n    projectLink?: string\n  ) {\n    super(chainId, decimals, symbol, name)\n    this.address = validateAndParseAddress(address)\n    this.projectLink = projectLink\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Token): boolean {\n    // short circuit on reference equality\n    if (this === other) {\n      return true\n    }\n    return this.chainId === other.chainId && this.address === other.address\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n}\n\n/**\n * Compares two currencies for equality\n */\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB)\n  } else if (currencyA instanceof Token) {\n    return false\n  } else if (currencyB instanceof Token) {\n    return false\n  } else {\n    return currencyA === currencyB\n  }\n}\n\nexport const WETH = {\n  [ChainId.BSC_MAINNET]: new Token(\n    ChainId.BSC_MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.BSC_TESTNET]: new Token(\n    ChainId.BSC_TESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_MAINNET]: new Token(\n    ChainId.ARBITRUM_MAINNET,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped ETH',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Token(\n    ChainId.ARBITRUM_TETSNET_RINKEBY,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_MAINNET]: new Token(\n    ChainId.AVAX_MAINNET,\n    '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_TESTNET]: new Token(\n    ChainId.AVAX_TESTNET,\n    '0xd00ae08403B9bbb9124bB305C09058E32C39A48c',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_MAINNET]: new Token(\n    ChainId.MATIC_MAINNET,\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_TESTNET]: new Token(\n    ChainId.MATIC_TESTNET,\n    '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n\n}\n// this has not to be mixed up with the ERC20 token WETH on BSC or MATIC\n// these are the respective wrapped network tokens, e.g. WBNB for Binance\n// or WMATIC for Polygon\nexport const WRAPPED_NETWORK_TOKENS:{[chainId:number]:Token} = {\n  [ChainId.BSC_MAINNET]: new Token(\n    ChainId.BSC_MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.BSC_TESTNET]: new Token(\n    ChainId.BSC_TESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_MAINNET]: new Token(\n    ChainId.ARBITRUM_MAINNET,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped ETH',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Token(\n    ChainId.ARBITRUM_TETSNET_RINKEBY,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_MAINNET]: new Token(\n    ChainId.AVAX_MAINNET,\n    '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_TESTNET]: new Token(\n    ChainId.AVAX_TESTNET,\n    '0xd00ae08403B9bbb9124bB305C09058E32C39A48c',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_MAINNET]: new Token(\n    ChainId.MATIC_MAINNET,\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_TESTNET]: new Token(\n    ChainId.MATIC_TESTNET,\n    '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.OASIS_TESTNET]:\n  new Token( ChainId.OASIS_TESTNET,\n    '0x792296e2a15e6Ceb5f5039DecaE7A1f25b00B0B0',\n    18,\n    'wROSE',\n    'Wrapped ROSE',\n    'https://docs.oasis.dev/'\n  ),\n  [ChainId.OASIS_MAINNET]:\n  new Token( ChainId.OASIS_MAINNET,\n    '0xfb40cd35C0cF322fA3cfB8D67b533Bd9ad7df056',\n    18,\n    'wROSE',\n    'Wrapped ROSE',\n    'https://docs.oasis.dev/'\n  ),\n  [ChainId.QUARKCHAIN_DEV_S0]:\n  new Token( ChainId.OASIS_MAINNET,\n    '0x56fB4da0E246003DEc7dD108e47f5d8e8F4cC493',\n    18,\n    'wQKC',\n    'Wrapped QKC',\n    'https://docs.oasis.dev/'\n  ),\n  [ChainId.TT_TESTNET]:\n  new Token( ChainId.TT_TESTNET,\n    '0x0ed2776E65984933f1066f4904FC34D4c083952B',\n    18,\n    'wTT',\n    'Wrapped Thunder',\n    'https://docs.oasis.dev/'\n  ),\n  [ChainId.TT_MAINNET]:\n  new Token( ChainId.TT_MAINNET,\n    '0x0ed2776E65984933f1066f4904FC34D4c083952B',\n    18,\n    'wTT',\n    'Wrapped Thunder',\n    'https://docs.oasis.dev/'\n  ),\n}\n\n\n\nexport const STABLECOINS: { [chainId: number]: Token[] } = {\n  43113: [\n    new Token(ChainId.AVAX_TESTNET, '0xca9ec7085ed564154a9233e1e7d8fef460438eea', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.AVAX_TESTNET, '0xffb3ed4960cac85372e6838fbc9ce47bcf2d073e', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.AVAX_TESTNET, '0xaea51e4fee50a980928b4353e852797b54deacd8', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.AVAX_TESTNET, '0xccf7ed44c5a0f3cb5c9a9b9f765f8d836fb93ba1', 18, 'TUSD', 'True USD'),\n  ],\n  42261 :[\n    new Token(ChainId.OASIS_TESTNET, '0x9aEeeD65aE87e3b28793aefAeED59c3f10ef956b', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.OASIS_TESTNET, '0xfA0D8065755Fb3b6520149e86Ac5A3Dc3ee5Dc92', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.OASIS_TESTNET, '0xf10Bd0dA1f0e69c3334D7F8116C9082746EBC1B4', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.OASIS_TESTNET, '0x4e8848da06E40E866b82f6b52417494936c9509b', 18, 'TUSD', 'True USD'),\n  ],\n  110001 :[\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0xE59c1Ddf4fAAC4Fa7C8c93d9392d4bBa55383268', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0x1a69a6e206c680A8559c59b951527437CBCe6Ed7', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0x51b90a5Bc99B7c76EDf3863E1d61ca6197a6e542', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0xD71C821a373E16D607277DB6C1356c1209C7d866', 18, 'TUSD', 'True USD'),\n  ],\n  0: [// dummy value\n    new Token(-1, '0xCa9eC7085Ed564154a9233e1e7D8fEF460438EEA', 6, 'USDC', 'USD Coin')]\n}\n\n\nexport const STABLES_INDEX_MAP: { [chainId: number]: { [index: number]: Token } } = {\n  43113: {\n    0: STABLECOINS[43113][0],\n    1: STABLECOINS[43113][1],\n    2: STABLECOINS[43113][2],\n    3: STABLECOINS[43113][3]\n  },\n  42261: {\n    0: STABLECOINS[42261][0],\n    1: STABLECOINS[42261][1],\n    2: STABLECOINS[42261][2],\n    3: STABLECOINS[42261][3]\n  },\n  110001: {\n    0: STABLECOINS[110001][0],\n    1: STABLECOINS[110001][1],\n    2: STABLECOINS[110001][2],\n    3: STABLECOINS[110001][3]\n  }\n}\n\nexport const STABLES_LP_TOKEN: { [chainId: number]: { [index: number]: Token } } = {\n  43113: {\n    0: STABLECOINS[43113][0],\n    1: STABLECOINS[43113][1],\n    2: STABLECOINS[43113][2],\n    3: STABLECOINS[43113][3]\n  }\n}","import invariant from 'tiny-invariant'\nimport _Decimal from 'decimal.js-light'\nimport _Big, { RoundingMode } from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh } from '../../constants'\nimport { ONE } from '../../constants'\nimport { parseBigintIsh } from '../../helperUtils'\nimport { BigNumber } from 'ethers'\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp\n}\n\nexport class Fraction {\n  public readonly numerator: BigNumber\n  public readonly denominator: BigNumber\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = ONE) {\n    this.numerator = parseBigintIsh(numerator)\n    this.denominator = parseBigintIsh(denominator)\n  }\n\n  // performs floor division\n  public get quotient(): BigNumber {\n    return this.numerator.div(this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(this.numerator.mod(this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (this.denominator.eq(otherParsed.denominator)) {\n      return new Fraction(this.numerator.add(otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator).add(\n        otherParsed.numerator.mul(this.denominator)\n      ),\n      this.denominator.mul(otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (this.denominator.eq(otherParsed.denominator)) {\n      return new Fraction(this.numerator.sub(otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator).sub(\n       otherParsed.numerator.mul(this.denominator)\n      ),\n      this.denominator.mul(otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return this.numerator.mul(otherParsed.denominator).lt(\n      otherParsed.numerator.mul(this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return this.numerator.mul(otherParsed.denominator).eq(\n      otherParsed.numerator.mul(this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return this.numerator.mul(otherParsed.denominator).gt(otherParsed.numerator.mul(this.denominator))\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n     this.numerator.mul(otherParsed.numerator),\n      this.denominator.mul(otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator),\n      this.denominator.mul(otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n}\n","import { _100 } from '../../constants'\nimport { Fraction, Rounding } from './fraction'\n\nconst _100_PERCENT = new Fraction(_100)\n\nexport class Percent extends Fraction {\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { currencyEquals } from '../token'\nimport { Currency, ChainId, NETWORK_CCY } from '../currency'\nimport invariant from 'tiny-invariant'\nimport _Big from 'big.js'\nimport toFormat from 'toformat'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { BigintIsh, TEN, SolidityType } from '../../constants'\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../helperUtils'\nimport { Fraction, Rounding } from './fraction'\n\nconst Big = toFormat(_Big)\n\nexport class CurrencyAmount extends Fraction {\n  public readonly currency: Currency\n\n  /**\n   * Helper that calls the constructor with the more flexible network currency\n   * dependent on the selected chainId\n   * @param amount ether amount in wei\n   */\n  public static networkCCYAmount(chainId: ChainId, amount: BigintIsh): CurrencyAmount {\n    return new CurrencyAmount(NETWORK_CCY[chainId], amount)\n  }\n\n  // amount _must_ be raw, i.e. in the native representation\n  protected constructor(currency: Currency, amount: BigintIsh) {\n    const parsedAmount = parseBigintIsh(amount)\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\n\n    super(parsedAmount, TEN.pow(currency.decimals))\n    this.currency = currency\n  }\n\n  public get raw(): BigNumber {\n    return this.numerator\n  }\n\n  public add(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, this.raw.add(other.raw))\n  }\n\n  public subtract(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, this.raw.sub(other.raw))\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\n  }\n\n  public toBigNumber(): BigNumber { return BigNumber.from(this.numerator.toString()) }\n}\n","import { CurrencyAmount } from './currencyAmount'\nimport { Token } from '../token'\nimport invariant from 'tiny-invariant'\nimport { BigintIsh } from '../../constants'\n\n\n// minimal interface so the input output comparator may be shared across types\nexport interface InputOutput {\n  readonly inputAmount: CurrencyAmount\n  readonly outputAmount: CurrencyAmount\n}\n\nexport class TokenAmount extends CurrencyAmount {\n  public readonly token: Token\n\n  // amount _must_ be raw, i.e. in the native representation\n  public constructor(token: Token, amount: BigintIsh) {\n    super(token, amount)\n    this.token = token\n  }\n\n  public add(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, this.raw.add(other.raw))\n  }\n\n  public subtract(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, this.raw.sub(other.raw))\n  }\n}\n","import { Token } from '../token'\nimport { TokenAmount } from './tokenAmount'\nimport { currencyEquals } from '../token'\nimport invariant from 'tiny-invariant'\n\nimport { BigintIsh, TEN } from '../../constants'\nimport { Currency } from '../currency'\n\nimport { Fraction, Rounding } from './fraction'\nimport { CurrencyAmount } from './currencyAmount'\n\nimport { Pool } from '../pools/pool'\nimport { Route } from '../route'\n\nexport class Price extends Fraction {\n  public readonly baseCurrency: Currency // input i.e. denominator\n  public readonly quoteCurrency: Currency // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n\n  // upgraded version to include StablePairWrappers in a Route\n  // as well as weighted pairs\n  public static fromRoute(route: Route, poolDict: { [id: string]: Pool }): Price {\n    const prices: Price[] = []\n    // console.log(\"=========PATH\", route.path.map(x=>x.symbol))\n    // console.log(\"=========PATH PAIRs\", route.pairData.map(x=>[x.token0.symbol, x.token1.symbol]))\n    for (const [i, pool] of route.pairData.entries()) {\n      const price = pool.poolPrice(route.path[i], route.path[i + 1], poolDict)\n      prices.push(price)\n    }\n    // console.log(\"=========PRICE\", prices.map(p=>[p.baseCurrency.symbol, p.quoteCurrency.symbol]))\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n  }\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  public constructor(baseCurrency: Currency, quoteCurrency: Currency, denominator: BigintIsh, numerator: BigintIsh) {\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      TEN.pow(baseCurrency.decimals),\n      TEN.pow(quoteCurrency.decimals)\n    )\n  }\n\n  public get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n\n  public get adjusted(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public invert(): Price {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  public multiply(other: Price): Price {\n    invariant(currencyEquals(this.quoteCurrency, other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  // performs floor division on overflow\n  public quote(chainId: number, currencyAmount: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(currencyAmount.currency, this.baseCurrency), 'TOKEN')\n    if (this.quoteCurrency instanceof Token) {\n      return new TokenAmount(this.quoteCurrency, super.multiply(currencyAmount.raw).quotient)\n    }\n    return CurrencyAmount.networkCCYAmount(chainId, super.multiply(currencyAmount.raw).quotient)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the “Software”), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport { BigNumber } from '@ethersproject/bignumber'\n// import { ethers } from 'ethers'\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\n\n// All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n// two numbers, and multiply by ONE when dividing them.\nexport const ZERO = BigNumber.from(0)\n// All arguments and return values are 18 decimal fixed point numbers.\nexport const ONE_18 = BigNumber.from('1000000000000000000');\n\n// Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n// case of ln36, 36 decimals.\nconst ONE_20 = BigNumber.from('100000000000000000000');\nconst ONE_36 = BigNumber.from('1000000000000000000000000000000000000');\n\n// The domain of natural exponentiation is bound by the word size and number of decimals used.\n//\n// Because internally the result will be stored using 20 decimals, the largest possible result is\n// (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n// The smallest possible result is 10^(-18), which makes largest negative argument\n// ln(10^(-18)) = -41.446531673892822312.\n// We use 130.0 and -41.0 to have some safety margin.\n// const MAX_NATURAL_EXPONENT = BigNumber.from('130000000000000000000');\n// const MIN_NATURAL_EXPONENT = BigNumber.from(-'41000000000000000000');\n\n// Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n// 256 bit integer.\nconst LN_36_LOWER_BOUND = ONE_18.sub(BigNumber.from('100000000000000000'));\nconst LN_36_UPPER_BOUND = ONE_18.add(BigNumber.from('100000000000000000'));\n\n// const MILD_EXPONENT_BOUND = ethers.constants.MaxUint256.div(ONE_20);\n\n// 18 decimal constants\nconst x0 = BigNumber.from('128000000000000000000'); // 2ˆ7\nconst a0 = BigNumber.from('38877084059945950922200000000000000000000000000000000000'); // eˆ(x0) (no decimals)\nconst x1 = BigNumber.from('64000000000000000000'); // 2ˆ6\nconst a1 = BigNumber.from('6235149080811616882910000000'); // eˆ(x1) (no decimals)\n\n// 20 decimal constants\nconst x2 = BigNumber.from('3200000000000000000000'); // 2ˆ5\nconst a2 = BigNumber.from('7896296018268069516100000000000000'); // eˆ(x2)\nconst x3 = BigNumber.from('1600000000000000000000'); // 2ˆ4\nconst a3 = BigNumber.from('888611052050787263676000000'); // eˆ(x3)\nconst x4 = BigNumber.from('800000000000000000000'); // 2ˆ3\nconst a4 = BigNumber.from('298095798704172827474000'); // eˆ(x4)\nconst x5 = BigNumber.from('400000000000000000000'); // 2ˆ2\nconst a5 = BigNumber.from('5459815003314423907810'); // eˆ(x5)\nconst x6 = BigNumber.from('200000000000000000000'); // 2ˆ1\nconst a6 = BigNumber.from('738905609893065022723'); // eˆ(x6)\nconst x7 = BigNumber.from('100000000000000000000'); // 2ˆ0\nconst a7 = BigNumber.from('271828182845904523536'); // eˆ(x7)\nconst x8 = BigNumber.from('50000000000000000000'); // 2ˆ-1\nconst a8 = BigNumber.from('164872127070012814685'); // eˆ(x8)\nconst x9 = BigNumber.from('25000000000000000000'); // 2ˆ-2\nconst a9 = BigNumber.from('128402541668774148407'); // eˆ(x9)\nconst x10 = BigNumber.from('12500000000000000000'); // 2ˆ-3\nconst a10 = BigNumber.from('113314845306682631683'); // eˆ(x10)\nconst x11 = BigNumber.from('6250000000000000000'); // 2ˆ-4\nconst a11 = BigNumber.from('106449445891785942956'); // eˆ(x11)\n\n/**\n * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n *\n * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n */\nexport function pow(x: BigNumber, y: BigNumber): BigNumber {\n    if (y.eq(0)) {\n        // We solve the 0^0 indetermination by making it equal one.\n        return ONE_18;\n    }\n\n    if (x.eq(0)) {\n        return ZERO;\n    }\n    let x_int256 = x;\n    let y_int256 = y\n    let logx_times_y\n    if (LN_36_LOWER_BOUND.lt(x_int256) && x_int256.lt(LN_36_UPPER_BOUND)) {\n        let ln_36_x = _ln_36(x_int256);\n\n        // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n        // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n        // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n        // (downscaled) last 18 decimals.\n        logx_times_y = (ln_36_x.div(ONE_18).mul(y_int256)).add(ln_36_x.mod(ONE_18).mul(y_int256).div(ONE_18))\n    } else {\n        logx_times_y = _ln(x_int256).mul(y_int256);\n    }\n    logx_times_y = logx_times_y.div(ONE_18);\n\n\n    return exp(logx_times_y); // that +1 differs from the original variant\n}\n\n/**\n * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n *\n * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n */\nexport function exp(x: BigNumber): BigNumber {\n\n    if (x.lt(ZERO)) {\n        // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n        // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n        // Fixed point division requires multiplying by ONE_18.\n        return (ONE_18.mul(ONE_18)).div(exp(x.mul(-1)));\n    }\n    // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n    // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n    // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n    // decomposition.\n    // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n    // decomposition, which will be lower than the smallest x_n.\n    // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n    // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n    // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n    // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n    // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n    // decomposition.\n\n    // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n    // it and compute the accumulated product.\n\n    let firstAN;\n    if (x.gte(x0)) {\n        x = x.sub(x0);\n        firstAN = a0;\n    } else if (x.gte(x1)) {\n        x = x.sub(x1);\n        firstAN = a1;\n    } else {\n        firstAN = BigNumber.from(1); // One with no decimal places\n    }\n\n    // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n    // smaller terms.\n    x = x.mul(100);\n\n    // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n    // one. Recall that fixed point multiplication requires dividing by ONE_20.\n    let product = ONE_20;\n\n    if (x.gte(x2)) {\n        x = x.sub(x2);\n        product = product.mul(a2).div(ONE_20);\n    }\n    if (x.gte(x3)) {\n        x = x.sub(x3);\n        product = product.mul(a3).div(ONE_20);\n    }\n    if (x.gte(x4)) {\n        x = x.sub(x4);\n        product = product.mul(a4).div(ONE_20);\n    }\n    if (x.gte(x5)) {\n        x = x.sub(x5);\n        product = product.mul(a5).div(ONE_20);\n    }\n    if (x.gte(x6)) {\n        x = x.sub(x6);\n        product = product.mul(a6).div(ONE_20);\n    }\n    if (x.gte(x7)) {\n        x = x.sub(x7);\n        product = product.mul(a7).div(ONE_20);\n    }\n    if (x.gte(x8)) {\n        x = x.sub(x8);\n        product = product.mul(a8).div(ONE_20);\n    }\n    if (x.gte(x9)) {\n        x = x.sub(x9);\n        product = product.mul(a9).div(ONE_20);\n    }\n\n    // x10 and x11 are unnecessary here since we have high enough precision already.\n\n    // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n    // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n    let seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n    let term; // Each term in the sum, where the nth term is (x^n / n!).\n\n    // The first term is simply x.\n    term = x;\n    seriesSum = seriesSum.add(term);\n\n    // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n    // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n    term = term.mul(x).div(ONE_20).div(2);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(3);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(4);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(5);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(6);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(7);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(8);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(9);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(10);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(11);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(12);\n    seriesSum = seriesSum.add(term);\n\n    // 12 Taylor terms are sufficient for 18 decimal precision.\n\n    // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n    // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n    // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n    // and then drop two digits to return an 18 decimal value.\n\n    return ((product.mul(seriesSum)).div(ONE_20).mul(firstAN)).div(100);\n}\n\n/**\n * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n */\nexport function log(arg: BigNumber, base: BigNumber): BigNumber {\n    // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n    // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n    // upscaling.\n\n    let logBase;\n    if (LN_36_LOWER_BOUND.lt(base) && base.lt(LN_36_UPPER_BOUND)) {\n        logBase = _ln_36(base);\n    } else {\n        logBase = _ln(base).mul(ONE_18);\n    }\n\n    let logArg;\n    if (LN_36_LOWER_BOUND.lt(arg) && arg.lt(LN_36_UPPER_BOUND)) {\n        logArg = _ln_36(arg);\n    } else {\n        logArg = _ln(arg).mul(ONE_18);\n    }\n\n    // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n    return logArg.mul(ONE_18).div(logBase);\n}\n\n/**\n * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n */\nexport function ln(a: BigNumber): BigNumber {\n    // The real natural logarithm is not defined for negative numbers or zero.\n\n    if (LN_36_LOWER_BOUND.lt(a) && a.lt(LN_36_UPPER_BOUND)) {\n        return _ln_36(a).div(ONE_18);\n    } else {\n        return _ln(a);\n    }\n}\n\n/**\n * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n */\nexport function _ln(a: BigNumber): BigNumber {\n    if (a.lt(ONE_18)) {\n        // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n        // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n        // Fixed point division requires multiplying by ONE_18.\n        return (_ln((ONE_18.mul(ONE_18)).div(a))).mul(-1);\n    }\n\n    // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n    // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n    // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n    // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n    // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n    // decomposition, which will be lower than the smallest a_n.\n    // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n    // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n    // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n    // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n    // ONE_18 to convert them to fixed point.\n    // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n    // by it and compute the accumulated sum.\n\n    let sum = ZERO;\n    if (a.gte(a0.mul(ONE_18))) {\n        a = a.div(a0); // Integer, not fixed point division\n        sum = sum.add(x0);\n    }\n\n    if (a.gte(a1.mul(ONE_18))) {\n        a = a.div(a1); // Integer, not fixed point division\n        sum = sum.add(x1);\n    }\n\n    // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n    sum = sum.mul(100);\n    a = a.mul(100);\n\n    // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n    if (a.gte(a2)) {\n        a = a.mul(ONE_20).div(a2);\n        sum = sum.add(x2);\n    }\n\n    if (a.gte(a3)) {\n        a = a.mul(ONE_20).div(a3);\n        sum = sum.add(x3);\n    }\n\n    if (a.gte(a4)) {\n        a = a.mul(ONE_20).div(a4);\n        sum = sum.add(x4);\n    }\n\n    if (a.gte(a5)) {\n        a = a.mul(ONE_20).div(a5);\n        sum = sum.add(x5);\n    }\n\n    if (a.gte(a6)) {\n        a = a.mul(ONE_20).div(a6);\n        sum = sum.add(x6);\n    }\n\n    if (a.gte(a7)) {\n        a = a.mul(ONE_20).div(a7);\n        sum = sum.add(x7);\n    }\n\n    if (a.gte(a8)) {\n        a = a.mul(ONE_20).div(a8);\n        sum = sum.add(x8);\n    }\n\n    if (a.gte(a9)) {\n        a = a.mul(ONE_20).div(a9);\n        sum = sum.add(x9);\n    }\n\n    if (a.gte(a10)) {\n        a = a.mul(ONE_20).div(a10);\n        sum = sum.add(x10);\n    }\n\n    if (a.gte(a11)) {\n        a = a.mul(ONE_20).div(a11);\n        sum = sum.add(x11);\n    }\n\n    // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n    // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n    // Let z = (a - 1) / (a + 1).\n    // ln(a) =2.mul((z + z^.div( 3) + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n    // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n    // division by ONE_20.\n    let z = ((a.sub(ONE_20)).mul(ONE_20)).div(a.add(ONE_20));\n    let z_squared = (z.mul(z)).div(ONE_20);\n\n    // num is the numerator of the series: the z^(2 * n + 1) term\n    let num = z;\n\n    // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n    let seriesSum = num;\n\n    // In each step, the numerator is multiplied by z^2\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(3));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(5));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(7));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(9));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(11));\n\n    // 6 Taylor terms are sufficient for 36 decimal precision.\n\n    // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n    seriesSum = seriesSum.mul(2);\n\n    // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n    // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n    // value.\n\n    return sum.add(seriesSum).div(100);\n}\n\n/**\n * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n * for x close to one.\n *\n * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n */\nexport function _ln_36(x: BigNumber): BigNumber {\n    // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n    // worthwhile.\n\n    // First, we transform x to a 36 digit fixed point value.\n    x = x.mul(ONE_18);\n\n    // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n    // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n    // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n    // division by ONE_36.\n    let z = x.sub(ONE_36).mul(ONE_36).div(x.add(ONE_36));\n    let z_squared = z.mul(z).div(ONE_36);\n\n    // num is the numerator of the series: the z^(2 * n + 1) term\n    let num = z;\n\n    // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n    let seriesSum = num;\n\n    // In each step, the numerator is multiplied by z^2\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(3));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(5));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(7));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(9));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(11));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(13));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(15));\n\n    // 8 Taylor terms are sufficient for 36 decimal precision.\n\n    // All that remains is multiplying by 2 (non fixed point).\n    return seriesSum.mul(2);\n}\n\n","\n// import invariant from 'tiny-invariant'\nimport { BigNumber } from '@ethersproject/bignumber'\n\n\nimport { pow, ZERO, ONE_18 } from \"./LogExpMath\";\n\nexport const ONE = ONE_18\n/* solhint-disable private-vars-leading-underscore */\n\n// const ONE = BigNumber.from(1e18); // 18 decimal places\nconst MAX_POW_RELATIVE_ERROR = BigNumber.from(10000); // 10^(-14)\n\n// Minimum base for the power function when the exponent is 'free' (larger than ONE).\nexport const MIN_POW_BASE_FREE_EXPONENT = BigNumber.from('700000000000000000');\n\n\nexport function mulDown(a: BigNumber, b: BigNumber): BigNumber {\n    const product = a.mul(b);\n\n    return product.div(ONE);\n}\n\nexport function mulUp(a: BigNumber, b: BigNumber): BigNumber {\n    const product = a.mul(b);\n\n    if (product.eq(0)) {\n        return BigNumber.from(0);\n    } else {\n        // The traditional divUp formula is:\n        // divUp(x, y) := (x + y - 1) / y\n        // To avoid intermediate overflow in the addition, we distribute the division and get:\n        // divUp(x, y) := (x - 1) / y + 1\n        // Note that this requires x != 0, which we already tested for.\n\n        return (product.sub(1).div(ONE)).add(1);\n    }\n}\n\nexport function divDown(a: BigNumber, b: BigNumber): BigNumber {\n\n    if (a.eq(ZERO)) {\n        return ZERO;\n    } else {\n        let aInflated = a.mul(ONE);\n        return aInflated.div(b);\n    }\n}\n\nexport function divUp(a: BigNumber, b: BigNumber): BigNumber {\n\n    if (a.eq(ZERO)) {\n        return ZERO;\n    } else {\n        let aInflated = a.mul(ONE);\n\n        // The traditional divUp formula is:\n        // divUp(x, y) := (x + y - 1) / y\n        // To avoid intermediate overflow in the addition, we distribute the division and get:\n        // divUp(x, y) := (x - 1) / y + 1\n        // Note that this requires x != 0, which we already tested for.\n\n        return aInflated.sub(1).div(b).add(1);\n    }\n}\n\n/**\n * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n * the true value (that is, the error function expected - actual is always positive).\n */\nexport function powDown(x: BigNumber, y: BigNumber): BigNumber {\n    let raw = pow(x, y);\n    let maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR).add(1);\n\n    if (raw.lt(maxError)) {\n        return ZERO;\n    } else {\n        return raw.sub(maxError);\n    }\n}\n\n/**\n * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n * the true value (that is, the error function expected - actual is always negative).\n */\nexport function powUp(x: BigNumber, y: BigNumber): BigNumber {\n    const raw = pow(x, y);\n    const maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR).add(1);\n\n    return raw.add(maxError);\n}\n\n/**\n * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\n *\n * Useful when computing the complement for values with some level of relative error, as it strips this error and\n * prevents intermediate negative values.\n */\nexport function complement(x: BigNumber): BigNumber {\n    return x.lt(ONE) ? ONE.sub(x) : ZERO;\n}\n\n\n/**\n * @dev Returns the largest of two numbers of 256 bits.\n */\nexport function max(a: BigNumber, b: BigNumber): BigNumber {\n    return a.gte(b) ? a : b;\n}\n\n/**\n * @dev Returns the smallest of two numbers of 256 bits.\n */\nexport function min(a: BigNumber, b: BigNumber): BigNumber {\n    return a.lt(b) ? a : b;\n}\n\n","\nimport { BigNumber } from '@ethersproject/bignumber'\nimport invariant from 'tiny-invariant'\nimport { mulDown, powUp, powDown, divUp, divDown, complement, ONE, mulUp, max, MIN_POW_BASE_FREE_EXPONENT } from './FixedPoint'\nimport { ZERO } from './LogExpMath';\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\n// should be fixed.\n// solhint-disable private-vars-leading-underscore\n\n\n\n// A minimum normalized weight imposes a maximum weight ratio. We need this due to limitations in the\n// implementation of the power function, as these ratios are often exponents.\n// const _MIN_WEIGHT = BigNumber.from(0.01e18);\n// Having a minimum normalized weight imposes a limit on the maximum number of tokens;\n// i.e., the largest possible pool is one where all tokens have exactly the minimum weight.\n// const _MAX_WEIGHTED_TOKENS = BigNumber.from(100);\n\n// Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\n// ratio).\n\n// Swap limits: amounts swapped may not be larger than this percentage of total balance.\nconst _MAX_IN_RATIO = BigNumber.from('300000000000000000'); //0.3e18\nconst _MAX_OUT_RATIO = BigNumber.from('300000000000000000'); //0.3e18\n\n// Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\nconst _MAX_INVARIANT_RATIO = BigNumber.from('3000000000000000000'); //3e18\n// Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\nconst _MIN_INVARIANT_RATIO = BigNumber.from('700000000000000000'); //0.7e18\n\n// About swap fees on joins and exits:\n// Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\n// equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\n// swap fees, it follows that (some) joins and exits should as well.\n// On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\n// is the one to which swap fees are applied.\n\n// Invariant is used to collect protocol swap fees by comparing its value between two times.\n// So we can round always to the same direction. It is also used to initiate the BPT amount\n// and, because there is a minimum BPT, we round down the invariant.\nexport function _calculateInvariant(normalizedWeights: BigNumber[], balances: BigNumber[]): BigNumber {\n    /**********************************************************************************************\n    // invariant               _____                                                             //\n    // wi = weight index i      | |      wi                                                      //\n    // bi = balance index i     | |  bi ^   = i                                                  //\n    // i = invariant                                                                             //\n    **********************************************************************************************/\n\n    let _invariant = ONE;\n    for (let i = 0; i < normalizedWeights.length; i++) {\n        _invariant = mulDown(_invariant, powUp(balances[i], normalizedWeights[i]));\n    }\n\n    invariant(_invariant.gt(0), \"ZERO_INVARIANT\");\n\n    return _invariant\n}\n\n\n\n// Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\n// current balances and weights.\nexport function _calcOutGivenIn(\n    balanceIn: BigNumber,\n    weightIn: BigNumber,\n    balanceOut: BigNumber,\n    weightOut: BigNumber,\n    amountIn: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n    // outGivenIn                                                                                //\n    // aO = amountOut                                                                            //\n    // bO = balanceOut                                                                           //\n    // bI = balanceIn              /      /            bI             \\    (wI / wO) \\           //\n    // aI = amountIn    aO = bO * |  1 - | --------------------------  | ^            |          //\n    // wI = weightIn               \\      \\       ( bI + aI )         /              /           //\n    // wO = weightOut                                                                            //\n    **********************************************************************************************/\n\n    // Amount out, so we round down overall.\n\n    // The multiplication rounds down, and the subtrahend (power) rounds up (so the base rounds up too).\n    // Because bI / (bI + aI) <= 1, the exponent rounds down.\n\n    // Cannot exceed maximum in ratio\n    invariant(amountIn.lte(mulDown(balanceIn, _MAX_IN_RATIO)), \"MAX_IN_RATIO\");\n\n    const denominator = balanceIn.add(amountIn);\n    const base = divUp(balanceIn, denominator);\n    const exponent = divDown(weightIn, weightOut);\n    const power = powUp(base, exponent);\n\n    return mulDown(balanceOut, complement(power));\n}\n\n// Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\n// current balances and weights.\nexport function _calcInGivenOut(\n    balanceIn: BigNumber,\n    weightIn: BigNumber,\n    balanceOut: BigNumber,\n    weightOut: BigNumber,\n    amountOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n    // inGivenOut                                                                                //\n    // aO = amountOut                                                                            //\n    // bO = balanceOut                                                                           //\n    // bI = balanceIn              /  /            bO             \\    (wO / wI)      \\          //\n    // aI = amountIn    aI = bI * |  | --------------------------  | ^            - 1  |         //\n    // wI = weightIn               \\  \\       ( bO - aO )         /                   /          //\n    // wO = weightOut                                                                            //\n    **********************************************************************************************/\n\n    // Amount in, so we round up overall.\n\n    // The multiplication rounds up, and the power rounds up (so the base rounds up too).\n    // Because b0 / (b0 - a0) >= 1, the exponent rounds up.\n\n    // Cannot exceed maximum out ratio\n    invariant(amountOut.lte(mulDown(balanceOut, _MAX_OUT_RATIO)), \"MAX_OUT_RATIO\");\n\n    const base = divUp(balanceOut, balanceOut.sub(amountOut));\n    const exponent = divUp(weightOut, weightIn);\n    const power = powUp(base, exponent);\n\n    // Because the base is larger than one (and the power rounds up), the power should always be larger than one, so\n    // the following subtraction should never revert.\n    const ratio = power.sub(ONE);\n\n    return mulUp(balanceIn, ratio);\n}\n\nexport function _calcLpOutGivenExactTokensIn(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsIn: BigNumber[],\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { lpOut: BigNumber, swapFees: BigNumber[] } {\n    // BPT out, so we round down overall.\n\n    let balanceRatiosWithFee = [];\n\n    let invariantRatioWithFees = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        balanceRatiosWithFee.push(divDown(balances[i].add(amountsIn[i]), balances[i]));\n        invariantRatioWithFees = invariantRatioWithFees.add(mulDown(balanceRatiosWithFee[i], normalizedWeights[i]));\n    }\n\n    const { invariantRatio, swapFees } = _computeJoinExactTokensInInvariantRatio(\n        balances,\n        normalizedWeights,\n        amountsIn,\n        balanceRatiosWithFee,\n        invariantRatioWithFees,\n        swapFeePercentage\n    );\n\n    const lpOut = invariantRatio.gt(ONE) ? mulDown(lpTotalSupply, invariantRatio.sub(ONE)) : ZERO;\n    return { lpOut, swapFees };\n}\n\n/**\n * @dev Intermediate function to avoid stack-too-deep \"\n */\nexport function _computeJoinExactTokensInInvariantRatio(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsIn: BigNumber[],\n    balanceRatiosWithFee: BigNumber[],\n    invariantRatioWithFees: BigNumber,\n    swapFeePercentage: BigNumber\n): { invariantRatio: BigNumber, swapFees: BigNumber[] } {\n    // Swap fees are charged on all tokens that are being added in a larger proportion than the overall invariant\n    // increase.\n    let swapFees = [];\n    let invariantRatio = ONE;\n\n    for (let i = 0; i < balances.length; i++) {\n        let amountInWithoutFee;\n\n        if (balanceRatiosWithFee[i].gt(invariantRatioWithFees)) {\n            const nonTaxableAmount = mulDown(balances[i], invariantRatioWithFees.sub(ONE));\n            const taxableAmount = amountsIn[i].sub(nonTaxableAmount);\n            const swapFee = mulUp(taxableAmount, swapFeePercentage);\n\n            amountInWithoutFee = nonTaxableAmount.add(taxableAmount.sub(swapFee));\n            swapFees[i] = swapFee;\n        } else {\n            amountInWithoutFee = amountsIn[i];\n        }\n\n        const balanceRatio = divDown(balances[i].add(amountInWithoutFee), balances[i]);\n\n        invariantRatio = mulDown(invariantRatio, powDown(balanceRatio, normalizedWeights[i]));\n    }\n\n    return { invariantRatio, swapFees }\n}\n\nexport function _calcTokenInGivenExactLpOut(\n    balance: BigNumber,\n    normalizedWeight: BigNumber,\n    lpAmountOut: BigNumber,\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { amountIn: BigNumber, swapFee: BigNumber } {\n    /******************************************************************************************\n    // tokenInForExactLpOut                                                                 //\n    // a = amountIn                                                                          //\n    // b = balance                      /  /    totalBPT + LpOut      \\    (1 / w)       \\  //\n    // LpOut = lpAmountOut   a = b * |  | --------------------------  | ^          - 1  |  //\n    // lp = totalBPT                   \\  \\       totalBPT            /                  /  //\n    // w = weight                                                                            //\n    ******************************************************************************************/\n\n    // Token in, so we round up overall.\n\n    // Calculate the factor by which the invariant will increase after minting BPTAmountOut\n    const invariantRatio = divUp(lpTotalSupply.add(lpAmountOut), lpTotalSupply);\n    invariant(invariantRatio.lte(_MAX_INVARIANT_RATIO), \"MAX_OUT_LP\");\n\n    // Calculate by how much the token balance has to increase to match the invariantRatio\n    const balanceRatio = powUp(invariantRatio, divUp(ONE, normalizedWeight));\n\n    const amountInWithoutFee = mulUp(balance, balanceRatio.sub(ONE));\n\n    // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\n    // accordingly.\n    const taxablePercentage = complement(normalizedWeight);\n    const taxableAmount = mulUp(amountInWithoutFee, taxablePercentage);\n    const nonTaxableAmount = amountInWithoutFee.sub(taxableAmount);\n\n    const taxableAmountPlusFees = divUp(taxableAmount, ONE.sub(swapFeePercentage));\n\n    return {\n        swapFee: taxableAmountPlusFees.sub(taxableAmount),\n        amountIn: nonTaxableAmount.add(taxableAmountPlusFees)\n    }\n}\n\nexport function _calcAllTokensInGivenExactLpOut(\n    balances: BigNumber[],\n    lpAmountOut: BigNumber,\n    totalBPT: BigNumber\n): BigNumber[] {\n    /************************************************************************************\n    // tokensInForExactLpOut                                                          //\n    // (per token)                                                                     //\n    // aI = amountIn                   /   LpOut   \\                                  //\n    // b = balance           aI = b * | ------------ |                                 //\n    // LpOut = lpAmountOut           \\  totalBPT  /                                  //\n    // lp = totalBPT                                                                  //\n    ************************************************************************************/\n\n    // Tokens in, so we round up overall.\n    const lpRatio = divUp(lpAmountOut, totalBPT);\n\n    let amountsIn = [];\n    for (let i = 0; i < balances.length; i++) {\n        amountsIn.push(mulUp(balances[i], lpRatio));\n    }\n\n    return amountsIn;\n}\n\nexport function _calcLpInGivenExactTokensOut(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsOut: BigNumber[],\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { lpIn: BigNumber, swapFees: BigNumber[] } {\n    // BPT in, so we round up overall.\n\n    let balanceRatiosWithoutFee = Array(balances.length);\n    let invariantRatioWithoutFees = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        balanceRatiosWithoutFee[i] = divUp(balances[i].sub(amountsOut[i]), balances[i]);\n        invariantRatioWithoutFees = invariantRatioWithoutFees.add(mulUp(balanceRatiosWithoutFee[i], normalizedWeights[i]));\n    }\n\n    const { invariantRatio, swapFees } = _computeExitExactTokensOutInvariantRatio(\n        balances,\n        normalizedWeights,\n        amountsOut,\n        balanceRatiosWithoutFee,\n        invariantRatioWithoutFees,\n        swapFeePercentage\n    );\n\n    const lpIn = mulUp(lpTotalSupply, complement(invariantRatio));\n    return { lpIn, swapFees };\n}\n\n/**\n * @dev Intermediate function to avoid stack-too-deep \"\n */\nexport function _computeExitExactTokensOutInvariantRatio(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsOut: BigNumber[],\n    balanceRatiosWithoutFee: BigNumber[],\n    invariantRatioWithoutFees: BigNumber,\n    swapFeePercentage: BigNumber\n): { invariantRatio: BigNumber, swapFees: BigNumber[] } {\n    let swapFees = Array(balances.length);\n    let invariantRatio = ONE;\n\n    for (let i = 0; i < balances.length; i++) {\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n        // 'token out'. This results in slightly larger price impact.\n\n        let amountOutWithFee;\n        if (invariantRatioWithoutFees.gt(balanceRatiosWithoutFee[i])) {\n            const nonTaxableAmount = mulDown(balances[i], complement(invariantRatioWithoutFees));\n            const taxableAmount = amountsOut[i].sub(nonTaxableAmount);\n            const taxableAmountPlusFees = divUp(taxableAmount, ONE.sub(swapFeePercentage));\n\n            swapFees[i] = taxableAmountPlusFees.sub(taxableAmount);\n            amountOutWithFee = nonTaxableAmount.add(taxableAmountPlusFees);\n        } else {\n            amountOutWithFee = amountsOut[i];\n        }\n\n        const balanceRatio = divDown(balances[i].sub(amountOutWithFee), balances[i]);\n\n        invariantRatio = mulDown(invariantRatio, powDown(balanceRatio, normalizedWeights[i]));\n    }\n\n    return { invariantRatio, swapFees }\n}\n\nexport function _calcTokenOutGivenExactLpIn(\n    balance: BigNumber,\n    normalizedWeight: BigNumber,\n    lpAmountIn: BigNumber,\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { amountOut: BigNumber, swapFee: BigNumber } {\n    /*****************************************************************************************\n    // exactBPTInForTokenOut                                                                //\n    // a = amountOut                                                                        //\n    // b = balance                     /      /    totalBPT - lpIn       \\    (1 / w)  \\   //\n    // lpIn = lpAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\n    // lp = totalBPT                  \\      \\       totalBPT            /             /   //\n    // w = weight                                                                           //\n    *****************************************************************************************/\n\n    // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\n    // rounds up). Because (totalBPT - lpIn) / totalBPT <= 1, the exponent rounds down.\n\n    // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\n    const invariantRatio = divUp(lpTotalSupply.sub(lpAmountIn), lpTotalSupply);\n    invariant(invariantRatio >= _MIN_INVARIANT_RATIO, \"MIN_LP_IN\");\n\n    // Calculate by how much the token balance has to decrease to match invariantRatio\n    const balanceRatio = powUp(invariantRatio, divDown(ONE, normalizedWeight));\n\n    // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\n    const amountOutWithoutFee = mulDown(balance, complement(balanceRatio));\n\n    // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n    // in swap fees.\n    const taxablePercentage = complement(normalizedWeight);\n\n    // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n    // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n    const taxableAmount = mulUp(amountOutWithoutFee, taxablePercentage);\n    const nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n    const swapFee = mulUp(taxableAmount, swapFeePercentage)\n    return {\n        swapFee,\n        amountOut: nonTaxableAmount.add(taxableAmount.sub(swapFee))\n    }\n}\n\nexport function _calcTokensOutGivenExactLpIn(\n    balances: BigNumber[],\n    lpAmountIn: BigNumber,\n    totalBPT: BigNumber\n): BigNumber[] {\n    /**********************************************************************************************\n    // exactBPTInForTokensOut                                                                    //\n    // (per token)                                                                               //\n    // aO = amountOut                  /        lpIn         \\                                  //\n    // b = balance           a0 = b * | ---------------------  |                                 //\n    // lpIn = lpAmountIn             \\       totalBPT       /                                  //\n    // lp = totalBPT                                                                            //\n    **********************************************************************************************/\n\n    // Since we're computing an amount out, we round down overall. This means rounding down on both the\n    // multiplication and division.\n\n    const lpRatio = divDown(lpAmountIn, totalBPT);\n\n    let amountsOut = [];\n    for (let i = 0; i < balances.length; i++) {\n        amountsOut.push(mulDown(balances[i], lpRatio));\n    }\n\n    return amountsOut;\n}\n\nexport function _calcDueTokenProtocolSwapFeeAmount(\n    balance: BigNumber,\n    normalizedWeight: BigNumber,\n    previousInvariant: BigNumber,\n    currentInvariant: BigNumber,\n    protocolSwapFeePercentage: BigNumber\n): BigNumber {\n    /*********************************************************************************\n    /*  protocolSwapFeePercentage * balanceToken * ( 1 - (previousInvariant / currentInvariant) ^ (1 / weightToken))\n    *********************************************************************************/\n\n    if (currentInvariant.lte(previousInvariant)) {\n        // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\n        // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\n        return ZERO;\n    }\n\n    // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol\n    // fees to the Vault.\n\n    // Fee percentage and balance multiplications round down, while the subtrahend (power) rounds up (as does the\n    // base). Because previousInvariant / currentInvariant <= 1, the exponent rounds down.\n\n    let base = divUp(previousInvariant, currentInvariant);\n    const exponent = divDown(ONE, normalizedWeight);\n\n    // Because the exponent is larger than one, the base of the power function has a lower bound. We cap to this\n    // value to avoid numeric issues, which means in the extreme case (where the invariant growth is larger than\n    // 1 / min exponent) the Pool will pay less in protocol fees than it should.\n    base = max(base, MIN_POW_BASE_FREE_EXPONENT);\n\n    const power = powUp(base, exponent);\n\n    const tokenAccruedFees = mulDown(balance, complement(power));\n    return mulDown(tokenAccruedFees, protocolSwapFeePercentage);\n}\n\n","// SPDX-License-Identifier: MIT\n\nimport { WeightedSwapStorage } from \"./weightedSwapStorage\";\n\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { _calcAllTokensInGivenExactLpOut, _calcInGivenOut, _calcLpInGivenExactTokensOut, _calcLpOutGivenExactTokensIn, _calcOutGivenIn, _calcTokenOutGivenExactLpIn } from \"./WeightedMath\";\nimport { ONE_18, ZERO } from \"./LogExpMath\";\n\nconst FEE_DENOMINATOR = ONE_18\n\nexport function calculateRemoveLiquidityOneTokenExactIn(\n    self: WeightedSwapStorage,\n    outIndex: number,\n    lpAmount: BigNumber,\n    lpSupply:BigNumber,\n    tokenBalances: BigNumber[]\n): { amountOut: BigNumber, swapFee: BigNumber } {\n    return _calcTokenOutGivenExactLpIn(\n        tokenBalances[outIndex].mul(self.tokenMultipliers[outIndex]),\n        self.normalizedWeights[outIndex],\n        lpAmount,\n        lpSupply,\n        self.fee\n    );\n}\n\nexport function calculateRemoveLiquidityExactIn(\n    self: WeightedSwapStorage,\n    lpAmount: BigNumber,\n    lpSupply:BigNumber,\n     tokenBalances: BigNumber[]\n): BigNumber[] {\n\n    return _calcAllTokensInGivenExactLpOut(\n        _xp(tokenBalances, self.tokenMultipliers),\n        lpAmount,\n        lpSupply\n    );\n}\n\n/**\n * Estimate amount of LP token minted or burned at deposit or withdrawal\n */\nexport function calculateTokenAmount(\n    self: WeightedSwapStorage,\n    amounts: BigNumber[],\n    lpSupply:BigNumber,\n    deposit: boolean,\n    tokenBalances: BigNumber[]\n): BigNumber {\n    let lpTokenAmount = ZERO\n    if (deposit) {\n        const { lpOut } = _calcLpOutGivenExactTokensIn(\n            _xp(tokenBalances, self.tokenMultipliers),\n            self.normalizedWeights,\n            _xp(amounts, self.tokenMultipliers),\n            lpSupply,\n            self.fee\n        );\n        lpTokenAmount = lpOut\n    } else {\n        const { lpIn } = _calcLpInGivenExactTokensOut(\n            _xp(tokenBalances, self.tokenMultipliers),\n            self.normalizedWeights,\n            _xp(amounts, self.tokenMultipliers),\n            lpSupply,\n            self.fee\n        );\n        lpTokenAmount = lpIn\n    }\n\n    return lpTokenAmount\n}\n\nexport function calculateSwapGivenIn(self: WeightedSwapStorage, inIndex: number, outIndex: number, amountIn: BigNumber, tokenBalances: BigNumber[]): BigNumber {\n    // use in amount with fee alredy deducted\n    const amountInWithFee = amountIn.mul(self.tokenMultipliers[inIndex]).mul(FEE_DENOMINATOR.sub(self.fee));\n\n    // calculate out amount\n    let amountOut = _calcOutGivenIn(\n        tokenBalances[inIndex].mul(self.tokenMultipliers[inIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[inIndex],\n        tokenBalances[outIndex].mul(self.tokenMultipliers[outIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[outIndex],\n        amountInWithFee\n    );\n\n    // downscale out amount\n    return amountOut.div(FEE_DENOMINATOR).div(self.tokenMultipliers[outIndex]);\n\n}\n\n\nexport function calculateSwapGivenOut(self: WeightedSwapStorage, inIndex: number, outIndex: number, amountOut: BigNumber,tokenBalances: BigNumber[]): BigNumber {\n    // calculate in amount with upscaled balances\n    const amountIn = _calcInGivenOut(\n        tokenBalances[inIndex].mul(self.tokenMultipliers[inIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[inIndex],\n        tokenBalances[outIndex].mul(self.tokenMultipliers[outIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[outIndex],\n        amountOut.mul(self.tokenMultipliers[outIndex]).mul(FEE_DENOMINATOR)\n    );\n    // adjust for fee and scale down - rounding up\n    return amountIn.div(FEE_DENOMINATOR.sub(self.fee)).div(self.tokenMultipliers[inIndex]).add(1);\n}\n\n\nexport function _xp(balances: BigNumber[], rates: BigNumber[]): BigNumber[] {\n    let result = []\n    for (let i = 0; i < balances.length; i++) {\n        result.push(rates[i].mul(balances[i]))\n    }\n    return result\n}","import invariant from 'tiny-invariant'\nimport { BigNumber } from '@ethersproject/bignumber'\n\nconst ZERO = BigNumber.from(0)\nconst ONE = BigNumber.from(1)\nconst TWO = BigNumber.from(2)\nconst TENK = BigNumber.from(10000)\nconst _256 = BigNumber.from('256')\nconst _128 = BigNumber.from('128')\nconst MIN_PRECISION = 32;\nconst MAX_PRECISION = 127;\n\nconst FIXED_1 = BigNumber.from('0x080000000000000000000000000000000')\nconst FIXED_2 = BigNumber.from('0x100000000000000000000000000000000')\nconst MAX_NUM = BigNumber.from('0x200000000000000000000000000000000')\n\nconst LN2_NUMERATOR = BigNumber.from('0x3f80fe03f80fe03f80fe03f80fe03f8')\nconst LN2_DENOMINATOR = BigNumber.from('0x5b9de1d10bf4103d647b0955897ba80')\n\nconst OPT_LOG_MAX_VAL = BigNumber.from('0x15bf0a8b1457695355fb8ac404e7a79e3')\nconst OPT_EXP_MAX_VAL = BigNumber.from('0x800000000000000000000000000000000')\n\n// const LAMBERT_CONV_RADIUS = BigNumber.from('0x002f16ac6c59de6f8d5d6f63c1482a7c86')\n// const LAMBERT_POS2_SAMPLE = BigNumber.from('0x0003060c183060c183060c183060c18306')\n// const LAMBERT_POS2_MAXVAL = BigNumber.from('0x01af16ac6c59de6f8d5d6f63c1482a7c80')\n// const LAMBERT_POS3_MAXVAL = BigNumber.from('0x6b22d43e72c326539cceeef8bb48f255ff')\n\n// const MAX_UNF_WEIGHT = BigNumber.from('0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9')\n\nconst maxExpArray = new Array<BigNumber>(128)\nmaxExpArray[32] = BigNumber.from('0x1c35fedd14ffffffffffffffffffffffff')\nmaxExpArray[33] = BigNumber.from('0x1b0ce43b323fffffffffffffffffffffff')\nmaxExpArray[34] = BigNumber.from('0x19f0028ec1ffffffffffffffffffffffff')\nmaxExpArray[35] = BigNumber.from('0x18ded91f0e7fffffffffffffffffffffff')\nmaxExpArray[36] = BigNumber.from('0x17d8ec7f0417ffffffffffffffffffffff')\nmaxExpArray[37] = BigNumber.from('0x16ddc6556cdbffffffffffffffffffffff')\nmaxExpArray[38] = BigNumber.from('0x15ecf52776a1ffffffffffffffffffffff')\nmaxExpArray[39] = BigNumber.from('0x15060c256cb2ffffffffffffffffffffff')\nmaxExpArray[40] = BigNumber.from('0x1428a2f98d72ffffffffffffffffffffff')\nmaxExpArray[41] = BigNumber.from('0x13545598e5c23fffffffffffffffffffff')\nmaxExpArray[42] = BigNumber.from('0x1288c4161ce1dfffffffffffffffffffff')\nmaxExpArray[43] = BigNumber.from('0x11c592761c666fffffffffffffffffffff')\nmaxExpArray[44] = BigNumber.from('0x110a688680a757ffffffffffffffffffff')\nmaxExpArray[45] = BigNumber.from('0x1056f1b5bedf77ffffffffffffffffffff')\nmaxExpArray[46] = BigNumber.from('0x0faadceceeff8bffffffffffffffffffff')\nmaxExpArray[47] = BigNumber.from('0x0f05dc6b27edadffffffffffffffffffff')\nmaxExpArray[48] = BigNumber.from('0x0e67a5a25da4107fffffffffffffffffff')\nmaxExpArray[49] = BigNumber.from('0x0dcff115b14eedffffffffffffffffffff')\nmaxExpArray[50] = BigNumber.from('0x0d3e7a392431239fffffffffffffffffff')\nmaxExpArray[51] = BigNumber.from('0x0cb2ff529eb71e4fffffffffffffffffff')\nmaxExpArray[52] = BigNumber.from('0x0c2d415c3db974afffffffffffffffffff')\nmaxExpArray[53] = BigNumber.from('0x0bad03e7d883f69bffffffffffffffffff')\nmaxExpArray[54] = BigNumber.from('0x0b320d03b2c343d5ffffffffffffffffff')\nmaxExpArray[55] = BigNumber.from('0x0abc25204e02828dffffffffffffffffff')\nmaxExpArray[56] = BigNumber.from('0x0a4b16f74ee4bb207fffffffffffffffff')\nmaxExpArray[57] = BigNumber.from('0x09deaf736ac1f569ffffffffffffffffff')\nmaxExpArray[58] = BigNumber.from('0x0976bd9952c7aa957fffffffffffffffff')\nmaxExpArray[59] = BigNumber.from('0x09131271922eaa606fffffffffffffffff')\nmaxExpArray[60] = BigNumber.from('0x08b380f3558668c46fffffffffffffffff')\nmaxExpArray[61] = BigNumber.from('0x0857ddf0117efa215bffffffffffffffff')\nmaxExpArray[62] = BigNumber.from('0x07ffffffffffffffffffffffffffffffff')\nmaxExpArray[63] = BigNumber.from('0x07abbf6f6abb9d087fffffffffffffffff')\nmaxExpArray[64] = BigNumber.from('0x075af62cbac95f7dfa7fffffffffffffff')\nmaxExpArray[65] = BigNumber.from('0x070d7fb7452e187ac13fffffffffffffff')\nmaxExpArray[66] = BigNumber.from('0x06c3390ecc8af379295fffffffffffffff')\nmaxExpArray[67] = BigNumber.from('0x067c00a3b07ffc01fd6fffffffffffffff')\nmaxExpArray[68] = BigNumber.from('0x0637b647c39cbb9d3d27ffffffffffffff')\nmaxExpArray[69] = BigNumber.from('0x05f63b1fc104dbd39587ffffffffffffff')\nmaxExpArray[70] = BigNumber.from('0x05b771955b36e12f7235ffffffffffffff')\nmaxExpArray[71] = BigNumber.from('0x057b3d49dda84556d6f6ffffffffffffff')\nmaxExpArray[72] = BigNumber.from('0x054183095b2c8ececf30ffffffffffffff')\nmaxExpArray[73] = BigNumber.from('0x050a28be635ca2b888f77fffffffffffff')\nmaxExpArray[74] = BigNumber.from('0x04d5156639708c9db33c3fffffffffffff')\nmaxExpArray[75] = BigNumber.from('0x04a23105873875bd52dfdfffffffffffff')\nmaxExpArray[76] = BigNumber.from('0x0471649d87199aa990756fffffffffffff')\nmaxExpArray[77] = BigNumber.from('0x04429a21a029d4c1457cfbffffffffffff')\nmaxExpArray[78] = BigNumber.from('0x0415bc6d6fb7dd71af2cb3ffffffffffff')\nmaxExpArray[79] = BigNumber.from('0x03eab73b3bbfe282243ce1ffffffffffff')\nmaxExpArray[80] = BigNumber.from('0x03c1771ac9fb6b4c18e229ffffffffffff')\nmaxExpArray[81] = BigNumber.from('0x0399e96897690418f785257fffffffffff')\nmaxExpArray[82] = BigNumber.from('0x0373fc456c53bb779bf0ea9fffffffffff')\nmaxExpArray[83] = BigNumber.from('0x034f9e8e490c48e67e6ab8bfffffffffff')\nmaxExpArray[84] = BigNumber.from('0x032cbfd4a7adc790560b3337ffffffffff')\nmaxExpArray[85] = BigNumber.from('0x030b50570f6e5d2acca94613ffffffffff')\nmaxExpArray[86] = BigNumber.from('0x02eb40f9f620fda6b56c2861ffffffffff')\nmaxExpArray[87] = BigNumber.from('0x02cc8340ecb0d0f520a6af58ffffffffff')\nmaxExpArray[88] = BigNumber.from('0x02af09481380a0a35cf1ba02ffffffffff')\nmaxExpArray[89] = BigNumber.from('0x0292c5bdd3b92ec810287b1b3fffffffff')\nmaxExpArray[90] = BigNumber.from('0x0277abdcdab07d5a77ac6d6b9fffffffff')\nmaxExpArray[91] = BigNumber.from('0x025daf6654b1eaa55fd64df5efffffffff')\nmaxExpArray[92] = BigNumber.from('0x0244c49c648baa98192dce88b7ffffffff')\nmaxExpArray[93] = BigNumber.from('0x022ce03cd5619a311b2471268bffffffff')\nmaxExpArray[94] = BigNumber.from('0x0215f77c045fbe885654a44a0fffffffff')\nmaxExpArray[95] = BigNumber.from('0x01ffffffffffffffffffffffffffffffff')\nmaxExpArray[96] = BigNumber.from('0x01eaefdbdaaee7421fc4d3ede5ffffffff')\nmaxExpArray[97] = BigNumber.from('0x01d6bd8b2eb257df7e8ca57b09bfffffff')\nmaxExpArray[98] = BigNumber.from('0x01c35fedd14b861eb0443f7f133fffffff')\nmaxExpArray[99] = BigNumber.from('0x01b0ce43b322bcde4a56e8ada5afffffff')\nmaxExpArray[100] = BigNumber.from('0x019f0028ec1fff007f5a195a39dfffffff')\nmaxExpArray[101] = BigNumber.from('0x018ded91f0e72ee74f49b15ba527ffffff')\nmaxExpArray[102] = BigNumber.from('0x017d8ec7f04136f4e5615fd41a63ffffff')\nmaxExpArray[103] = BigNumber.from('0x016ddc6556cdb84bdc8d12d22e6fffffff')\nmaxExpArray[104] = BigNumber.from('0x015ecf52776a1155b5bd8395814f7fffff')\nmaxExpArray[105] = BigNumber.from('0x015060c256cb23b3b3cc3754cf40ffffff')\nmaxExpArray[106] = BigNumber.from('0x01428a2f98d728ae223ddab715be3fffff')\nmaxExpArray[107] = BigNumber.from('0x013545598e5c23276ccf0ede68034fffff')\nmaxExpArray[108] = BigNumber.from('0x01288c4161ce1d6f54b7f61081194fffff')\nmaxExpArray[109] = BigNumber.from('0x011c592761c666aa641d5a01a40f17ffff')\nmaxExpArray[110] = BigNumber.from('0x0110a688680a7530515f3e6e6cfdcdffff')\nmaxExpArray[111] = BigNumber.from('0x01056f1b5bedf75c6bcb2ce8aed428ffff')\nmaxExpArray[112] = BigNumber.from('0x00faadceceeff8a0890f3875f008277fff')\nmaxExpArray[113] = BigNumber.from('0x00f05dc6b27edad306388a600f6ba0bfff')\nmaxExpArray[114] = BigNumber.from('0x00e67a5a25da41063de1495d5b18cdbfff')\nmaxExpArray[115] = BigNumber.from('0x00dcff115b14eedde6fc3aa5353f2e4fff')\nmaxExpArray[116] = BigNumber.from('0x00d3e7a3924312399f9aae2e0f868f8fff')\nmaxExpArray[117] = BigNumber.from('0x00cb2ff529eb71e41582cccd5a1ee26fff')\nmaxExpArray[118] = BigNumber.from('0x00c2d415c3db974ab32a51840c0b67edff')\nmaxExpArray[119] = BigNumber.from('0x00bad03e7d883f69ad5b0a186184e06bff')\nmaxExpArray[120] = BigNumber.from('0x00b320d03b2c343d4829abd6075f0cc5ff')\nmaxExpArray[121] = BigNumber.from('0x00abc25204e02828d73c6e80bcdb1a95bf')\nmaxExpArray[122] = BigNumber.from('0x00a4b16f74ee4bb2040a1ec6c15fbbf2df')\nmaxExpArray[123] = BigNumber.from('0x009deaf736ac1f569deb1b5ae3f36c130f')\nmaxExpArray[124] = BigNumber.from('0x00976bd9952c7aa957f5937d790ef65037')\nmaxExpArray[125] = BigNumber.from('0x009131271922eaa6064b73a22d0bd4f2bf')\nmaxExpArray[126] = BigNumber.from('0x008b380f3558668c46c91c49a2f8e967b9')\nmaxExpArray[127] = BigNumber.from('0x00857ddf0117efa215952912839f6473e6')\n\nfunction leftShift(num: BigNumber, shift: BigNumber) {\n    return num.mul(TWO.pow(shift))\n}\n\nfunction signedRightShift(num: BigNumber, shift: BigNumber) {\n    return num.div(TWO.pow(shift))\n}\n\n/**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\nexport function power(\n    _baseN: BigNumber,\n    _baseD: BigNumber,\n    _expN: BigNumber,\n    _expD: BigNumber\n): [BigNumber, number] {\n    invariant(_baseN.gt(_baseD), \"not support _baseN < _baseD\");\n    invariant(_baseN.lt(MAX_NUM))\n\n    let baseLog;\n    let base = (_baseN.mul(FIXED_1)).div(_baseD);\n    if (base.lt(OPT_LOG_MAX_VAL)) {\n        baseLog = optimalLog(base);\n    } else {\n        baseLog = generalLog(base);\n    }\n\n    let baseLogTimesExp = (baseLog.mul(_expN)).div(_expD);\n    if (baseLogTimesExp.lt(OPT_EXP_MAX_VAL)) {\n        return [optimalExp(baseLogTimesExp), MAX_PRECISION]\n    } else {\n        let precision = findPositionInMaxExpArray(baseLogTimesExp);\n        return [generalExp(signedRightShift(baseLogTimesExp, BigNumber.from(MAX_PRECISION - precision)), BigNumber.from(precision)), precision]\n    }\n}\n\n/**\n * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n */\nfunction floorLog2(_n: BigNumber): BigNumber {\n    let res = ZERO;\n    if (_n.lt(_256)) {\n        // At most 8 iterations\n        while (_n.gt(ONE)) {\n            _n = signedRightShift(_n, ONE);\n            res = res.add(ONE);\n        }\n    } else {\n        // Exactly 8 iterations\n        for (let s = _128; s.gt(ZERO); s = signedRightShift(s, ONE)) {\n            if (_n.gt(leftShift(ONE, s))) {\n                _n = signedRightShift(_n, s)\n                res = res.or(s);\n            }\n        }\n    }\n\n    return res;\n}\n\n/**\n * @dev computes log(x / FIXED_1) * FIXED_1.\n * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n */\nexport function generalLog(x: BigNumber): BigNumber {\n    let res = ZERO;\n    // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n    if (x.gte(FIXED_2)) {\n        const count = floorLog2(x.div(FIXED_1));\n        x = signedRightShift(x, count);\n        // now x < 2\n        res = count.mul(FIXED_1);\n    }\n\n    // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n    if (x.gt(FIXED_1)) {\n        for (let i = MAX_PRECISION; i > 0; --i) {\n            x = (x.mul(x)).div(FIXED_1);\n            // now 1 < x < 4\n            if (x.gte(FIXED_2)) {\n                x = signedRightShift(x, ONE);\n                // now 1 < x < 2\n                res = res.add(leftShift(ONE, BigNumber.from(i - 1)));\n            }\n        }\n    }\n\n    return (res.mul(LN2_NUMERATOR)).div(LN2_DENOMINATOR)\n}\n\n/**\n    * @dev computes log(x / FIXED_1) * FIXED_1\n    * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\n    * Auto-generated via \"PrintFunctionOptimalLog.py\"\n    * Detailed description:\n    * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n    * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n    * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n    * - The natural logarithm of the input is calculated by summing up the intermediate results above\n    * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n    */\nexport function optimalLog(x: BigNumber): BigNumber {\n    let res = ZERO;\n\n    let y;\n    let z;\n    let w;\n\n    if (x.gte('0xd3094c70f034de4b96ff7d5b6f99fcd8')) {\n        res = res.add(BigNumber.from('0x40000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0xd3094c70f034de4b96ff7d5b6f99fcd8'));\n    }\n    // add 1 / 2^1\n    if (x.gte('0xa45af1e1f40c333b3de1db4dd55f29a7')) {\n        res = res.add(BigNumber.from('0x20000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0xa45af1e1f40c333b3de1db4dd55f29a7'));\n    }\n    // add 1 / 2^2\n    if (x.gte('0x910b022db7ae67ce76b441c27035c6a1')) {\n        res = res.add(BigNumber.from('0x10000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x910b022db7ae67ce76b441c27035c6a1'));\n    }\n    // add 1 / 2^3\n    if (x.gte('0x88415abbe9a76bead8d00cf112e4d4a8')) {\n        res = res.add(BigNumber.from('0x08000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x88415abbe9a76bead8d00cf112e4d4a8'));\n    }\n    // add 1 / 2^4\n    if (x.gte('0x84102b00893f64c705e841d5d4064bd3')) {\n        res = res.add(BigNumber.from('0x04000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x84102b00893f64c705e841d5d4064bd3'));\n    }\n    // add 1 / 2^5\n    if (x.gte('0x8204055aaef1c8bd5c3259f4822735a2')) {\n        res = res.add(BigNumber.from('0x02000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x8204055aaef1c8bd5c3259f4822735a2'));\n    }\n    // add 1 / 2^6\n    if (x.gte('0x810100ab00222d861931c15e39b44e99')) {\n        res = res.add(BigNumber.from('0x01000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x810100ab00222d861931c15e39b44e99'));\n    }\n    // add 1 / 2^7\n    if (x.gte('0x808040155aabbbe9451521693554f733')) {\n        res = res.add(BigNumber.from('0x00800000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x808040155aabbbe9451521693554f733'));\n    }\n    // add 1 / 2^8\n\n    z = y = x.sub(FIXED_1);\n    w = (y.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x100000000000000000000000000000000').sub(y)).div(BigNumber.from('0x100000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^01 / 01 - y^02 / 02\n    res = res.add(z.mul(BigNumber.from('0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa').sub(y)).div(BigNumber.from('0x200000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^03 / 03 - y^04 / 04\n    res = res.add(z.mul(BigNumber.from('0x099999999999999999999999999999999').sub(y)).div(BigNumber.from('0x300000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^05 / 05 - y^06 / 06\n    res = res.add(z.mul(BigNumber.from('0x092492492492492492492492492492492').sub(y)).div(BigNumber.from('0x400000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^07 / 07 - y^08 / 08\n    res = res.add(z.mul(BigNumber.from('0x08e38e38e38e38e38e38e38e38e38e38e').sub(y)).div(BigNumber.from('0x500000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^09 / 09 - y^10 / 10\n    res = res.add(z.mul(BigNumber.from('0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b').sub(y)).div(BigNumber.from('0x600000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^11 / 11 - y^12 / 12\n    res = res.add(z.mul(BigNumber.from('0x089d89d89d89d89d89d89d89d89d89d89').sub(y)).div(BigNumber.from('0x700000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^13 / 13 - y^14 / 14\n    res = res.add(z.mul(BigNumber.from('0x088888888888888888888888888888888').sub(y)).div(BigNumber.from('0x800000000000000000000000000000000')));\n    // add y^15 / 15 - y^16 / 16\n\n    return res;\n}\n\nexport function optimalExp(x: BigNumber): BigNumber {\n    let res = ZERO;\n\n    let y;\n    let z;\n\n    z = y = x.mod(BigNumber.from('0x10000000000000000000000000000000'));\n    // get the input modulo 2^(-3)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x10e1b3be415a0000')));\n    // add y^02 * (20! / 02!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x05a0913f6b1e0000')));\n    // add y^03 * (20! / 03!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0168244fdac78000')));\n    // add y^04 * (20! / 04!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x004807432bc18000')));\n    // add y^05 * (20! / 05!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000c0135dca04000')));\n    // add y^06 * (20! / 06!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0001b707b1cdc000')));\n    // add y^07 * (20! / 07!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000036e0f639b800')));\n    // add y^08 * (20! / 08!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x00000618fee9f800')));\n    // add y^09 * (20! / 09!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000009c197dcc00')));\n    // add y^10 * (20! / 10!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000e30dce400')));\n    // add y^11 * (20! / 11!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000000012ebd1300')));\n    // add y^12 * (20! / 12!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000017499f00')));\n    // add y^13 * (20! / 13!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000001a9d480')));\n    // add y^14 * (20! / 14!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x00000000001c6380')));\n    // add y^15 * (20! / 15!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000000000001c638')));\n    // add y^16 * (20! / 16!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000000001ab8')));\n    // add y^17 * (20! / 17!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000000000000017c')));\n    // add y^18 * (20! / 18!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000000000014')));\n    // add y^19 * (20! / 19!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000000000001')));\n    // add y^20 * (20! / 20!)\n    res = res.div(BigNumber.from('0x21c3677c82b40000')).add(y).add(FIXED_1);\n    // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n    if (!(x.and(BigNumber.from('0x010000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x1c3d6a24ed82218787d624d3e5eba95f9'))).div(BigNumber.from('0x18ebef9eac820ae8682b9793ac6d1e776'));\n    // multiply by e^2^(-3)\n    if (!(x.and(BigNumber.from('0x020000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x18ebef9eac820ae8682b9793ac6d1e778'))).div(BigNumber.from('0x1368b2fc6f9609fe7aceb46aa619baed4'));\n    // multiply by e^2^(-2)\n    if (!(x.and(BigNumber.from('0x040000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x1368b2fc6f9609fe7aceb46aa619baed5'))).div(BigNumber.from('0x0bc5ab1b16779be3575bd8f0520a9f21f'));\n    // multiply by e^2^(-1)\n    if (!(x.and(BigNumber.from('0x080000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x0bc5ab1b16779be3575bd8f0520a9f21e'))).div(BigNumber.from('0x0454aaa8efe072e7f6ddbab84b40a55c9'));\n    // multiply by e^2^(+0)\n    if (!(x.and(BigNumber.from('0x100000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x0454aaa8efe072e7f6ddbab84b40a55c5'))).div(BigNumber.from('0x00960aadc109e7a3bf4578099615711ea'));\n    // multiply by e^2^(+1)\n    if (!(x.and(BigNumber.from('0x200000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x00960aadc109e7a3bf4578099615711d7'))).div(BigNumber.from('0x0002bf84208204f5977f9a8cf01fdce3d'));\n    // multiply by e^2^(+2)\n    if (!(x.and(BigNumber.from('0x400000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x0002bf84208204f5977f9a8cf01fdc307'))).div(BigNumber.from('0x0000003c6ab775dd0b95b4cbee7e65d11'));\n    // multiply by e^2^(+3)\n\n    return res;\n}\n\n/**\n   * @dev this function can be auto-generated by the script \"PrintFunctionGeneralExp.py\".\n   * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n   * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n   * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n   * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n   */\nexport function generalExp(_x: BigNumber, _precision: BigNumber) {\n    let xi = _x;\n    let res = ZERO;\n\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x3442c4e6074a82f1797f72ac0000000'));\n    // add x^02 * (33! / 02!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x116b96f757c380fb287fd0e40000000'));\n    // add x^03 * (33! / 03!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x045ae5bdd5f0e03eca1ff4390000000'));\n    // add x^04 * (33! / 04!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00defabf91302cd95b9ffda50000000'));\n    // add x^05 * (33! / 05!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x002529ca9832b22439efff9b8000000'));\n    // add x^06 * (33! / 06!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00054f1cf12bd04e516b6da88000000'));\n    // add x^07 * (33! / 07!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000a9e39e257a09ca2d6db51000000'));\n    // add x^08 * (33! / 08!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000012e066e7b839fa050c309000000'));\n    // add x^09 * (33! / 09!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000001e33d7d926c329a1ad1a800000'));\n    // add x^10 * (33! / 10!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000002bee513bdb4a6b19b5f800000'));\n    // add x^11 * (33! / 11!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000003a9316fa79b88eccf2a00000'));\n    // add x^12 * (33! / 12!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000048177ebe1fa812375200000'));\n    // add x^13 * (33! / 13!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000005263fe90242dcbacf00000'));\n    // add x^14 * (33! / 14!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000057e22099c030d94100000'));\n    // add x^15 * (33! / 15!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000057e22099c030d9410000'));\n    // add x^16 * (33! / 16!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000052b6b54569976310000'));\n    // add x^17 * (33! / 17!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000004985f67696bf748000'));\n    // add x^18 * (33! / 18!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000003dea12ea99e498000'));\n    // add x^19 * (33! / 19!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000031880f2214b6e000'));\n    // add x^20 * (33! / 20!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000000025bcff56eb36000'));\n    // add x^21 * (33! / 21!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000000001b722e10ab1000'));\n    // add x^22 * (33! / 22!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000001317c70077000'));\n    // add x^23 * (33! / 23!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000cba84aafa00'));\n    // add x^24 * (33! / 24!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000082573a0a00'));\n    // add x^25 * (33! / 25!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000005035ad900'));\n    // add x^26 * (33! / 26!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000000000000002f881b00'));\n    // add x^27 * (33! / 27!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000001b29340'));\n    // add x^28 * (33! / 28!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000000000efc40'));\n    // add x^29 * (33! / 29!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000007fe0'));\n    // add x^30 * (33! / 30!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000000420'));\n    // add x^31 * (33! / 31!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000000021'));\n    // add x^32 * (33! / 32!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000000001'));\n    // add x^33 * (33! / 33!)\n\n\n    return (res.div(BigNumber.from('0x688589cc0e9505e2f2fee5580000000'))).add(_x).add(leftShift(ONE, _precision));\n    // divide by 33! and then add x^1 / 1! + x^0 / 0!\n}\n\n/**\n    * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n    * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n    * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n    */\nexport function findPositionInMaxExpArray(_x: BigNumber): number {\n    let lo = MIN_PRECISION;\n    let hi = MAX_PRECISION;\n\n    while (lo + 1 < hi) {\n        let mid = (lo + hi) / 2;\n        if (maxExpArray[mid].gte(_x)) lo = mid;\n        else hi = mid;\n    }\n\n    if (maxExpArray[hi].gte(_x)) return hi;\n    if (maxExpArray[lo].gte(_x)) return lo;\n\n    invariant(false);\n}\n\n/**\n * @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset,\n *\n * Formula:\n * return = reserveOut * (1 - (reserveIn * 10000 / (reserveIn * 10000 + amountIn * (10000 - swapFee))) ^ (tokenWeightIn / tokenWeightOut))\n *\n * @param amountIn                  source reserve amount\n * @param reserveIn    source reserve balance\n * @param reserveOut    target reserve balance\n * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n * @param swapFee                  swap fee of the conversion\n *\n * @return amountOut\n */\nexport function getAmountOut(\n    amountIn: BigNumber,\n    reserveIn: BigNumber,\n    reserveOut: BigNumber,\n    tokenWeightIn: BigNumber,\n    tokenWeightOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    // validate input\n    invariant(amountIn.gt(ZERO), \"RequiemFormula: INSUFFICIENT_INPUT_AMOUNT\");\n    // if (amountIn.lte(ZERO) || amountIn.eq(ZERO))\n    //     return ZERO\n\n    invariant(reserveIn.gt(ZERO) && reserveOut.gt(ZERO), \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n    const amountInWithFee = amountIn.mul(TENK.sub(swapFee))\n    // special case for equal weights\n    if (tokenWeightIn.eq(tokenWeightOut)) {\n        return (reserveOut.mul(amountInWithFee)).div(reserveIn.mul(TENK).add(amountInWithFee));\n    }\n\n    // let result;\n    // let precision: number;\n    const baseN = (reserveIn.mul(TENK)).add(amountInWithFee)\n    const [result, precision] = power(baseN, reserveIn.mul(TENK), tokenWeightIn, tokenWeightOut);\n\n    const temp1 = reserveOut.mul(result);\n    const temp2 = leftShift(reserveOut, BigNumber.from(precision));\n\n    return (temp1.sub(temp2)).div(result)\n}\n\n/**\n * @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n *\n * Formula:\n * return = reserveIn * ( (reserveOut / (reserveOut - amountOut)) ^ (tokenWeightOut / tokenWeightIn) - 1) * (10000/ (10000 - swapFee)\n *\n * @param amountOut     target reserve amount\n * @param reserveIn    source reserve balance\n * @param reserveOut    target reserve balance\n * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n * @param swapFee                  swap fee of the conversion\n *\n * @return amountIn\n */\nexport function getAmountIn(\n    amountOut: BigNumber,\n    reserveIn: BigNumber,\n    reserveOut: BigNumber,\n    tokenWeightIn: BigNumber,\n    tokenWeightOut: BigNumber,\n    swapFee: BigNumber\n) {\n    // validate input\n    invariant(amountOut.gt(ZERO), \"RequiemFormula: INSUFFICIENT_OUTPUT_AMOUNT\");\n\n    // if (amountOut.gte(ZERO) || amountOut.eq(ZERO))\n    //     return ZERO\n\n    invariant(reserveIn.gt(ZERO) && reserveOut.gt(ZERO), \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n    // special case for equal weights\n    if (tokenWeightIn.eq(tokenWeightOut)) {\n        const numerator = reserveIn.mul(amountOut).mul(TENK);\n        const denominator = reserveOut.sub(amountOut).mul(TENK.sub(swapFee));\n        return (numerator.div(denominator)).add(1);\n    }\n\n    const baseD = reserveOut.sub(amountOut);\n    const [result, precision] = power(reserveOut, baseD, tokenWeightOut, tokenWeightIn);\n    const baseReserveIn = reserveIn.mul(TENK);\n    const temp1 = baseReserveIn.mul(result);\n    const temp2 = leftShift(baseReserveIn, BigNumber.from(precision));\n    return (signedRightShift(temp1.sub(temp2), BigNumber.from(precision)).div(TENK.sub(swapFee))).add(1);\n}\n\n","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\nimport { Token } from '../token'\nimport { Price, TokenAmount } from '../fractions'\n\n// const ZERO = BigNumber.from(0)\n\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport abstract class Pool {\n\n    // the index-token map \n    public abstract readonly tokens: Token[]\n    public abstract readonly liquidityToken: Token\n    public abstract tokenBalances: BigNumber[]\n    public abstract readonly address: string\n    public abstract _name: string\n\n    /**\n     * Returns true if the token is either token0 or token1\n     * @param token to check\n     */\n    public involvesToken(token: Token): boolean {\n        let res = false\n        for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n            res || token.equals(this.tokens[i])\n        }\n\n        return res\n    }\n\n    // maps the index to the token in the stablePool\n    public tokenFromIndex(index: number): Token {\n        return this.tokens[index]\n    }\n\n    public indexFromToken(token: Token): number {\n        for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n            if (token.equals(this.tokens[index])) {\n                return index\n            }\n        }\n        throw new Error('token not in pool');\n    }\n\n    public getBalances(): BigNumber[] {\n        return Object.keys(this.tokens).map((_, index) => (this.tokenBalances[index]))\n    }\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public abstract calculateSwapGivenIn(\n        tokenIn: Token,\n        tokenOut: Token,\n        inAmount: BigNumber): BigNumber;\n\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public abstract calculateSwapGivenOut(\n        tokenIn: Token,\n        tokenOut: Token,\n        outAmount: BigNumber): BigNumber;\n\n    /**\n     * Returns the chain ID of the tokens in the pair.\n     */\n    public get chainId(): number {\n        return this.tokens[0].chainId\n    }\n\n    public token(index: number): Token {\n        return this.tokens[index]\n    }\n\n    public reserveOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n            if (token.equals(this.tokens[i]))\n                return this.tokenBalances[i]\n        }\n        return BigNumber.from(0)\n    }\n\n    public set name(value: string) {\n        this._name = value\n    }\n\n    public get name(): string {\n        return this._name\n    }\n\n\n    public setBalanceValueByIndex(index: number, newBalance: BigNumber) {\n        this.tokenBalances[index] = newBalance\n    }\n\n    public getTokenAmounts(): TokenAmount[] {\n        return this.tokens.map((t, i) => new TokenAmount(t, this.tokenBalances[i]))\n    }\n\n    public setTokenBalances(tokenBalances: BigNumber[]) {\n        this.tokenBalances = tokenBalances\n    }\n\n    public subtractBalanceValue(tokenAmount: TokenAmount) {\n        let newBalances = [] // safe way for replacement\n        for (let i = 0; i < this.tokenBalances.length; i++) {\n            newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].sub(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n        }\n        this.setTokenBalances(newBalances)\n    }\n\n    public abstract poolPrice(tokenIn: Token, tokenOut: Token): Price;\n\n    public abstract poolPriceBases(tokenIn: Token, tokenOut: Token): {\n        priceBaseIn: BigNumber\n        priceBaseOut: BigNumber\n    };\n\n    // function that adjusts pool for swap  amounts if routed through more than once\n    public abstract adjustForSwap(amountIn: TokenAmount, amountOut: TokenAmount): void;\n\n    // function that adjusts pool for swap  amounts if routed through more than once\n    public abstract clone(): Pool;\n\n    public abstract getName(): string;\n}\n\n\nexport enum PoolType {\n    Pair = 'Pair',\n    StablePairWrapper = 'StablePairWrapper',\n    AmplifiedWeightedPair = 'AmplifiedWeightedPair',\n    PoolPairWrapper = 'PoolPairWrapper',\n}\n\nexport type PoolDictionary = { [id: string]: Pool }\n\nexport type PoolHops = {\n    [tokenAddress: string]: Set<Token>; // the set of pool ids\n}","import { BigNumber } from \"ethers\"\nimport { ZERO } from \"./LogExpMath\"\n\nexport class WeightedSwapStorage {\n    public readonly tokenMultipliers: BigNumber[]\n    public readonly normalizedWeights: BigNumber[]\n    public readonly fee: BigNumber\n    public readonly adminFee: BigNumber\n    constructor(\n        tokenMultipliers: BigNumber[],\n        normalizedWeights: BigNumber[],\n        fee: BigNumber,\n        adminFee: BigNumber,\n    ) {\n        this.tokenMultipliers = tokenMultipliers\n        this.normalizedWeights = normalizedWeights\n        this.fee = fee\n        this.adminFee = adminFee\n\n    }\n\n    public static mock(): WeightedSwapStorage {\n        return new WeightedSwapStorage([ZERO], [ZERO], ZERO, ZERO)\n    }\n\n}","import { BigNumber } from \"ethers\"\n\nexport class StableSwapStorage {\n    public readonly tokenMultipliers: BigNumber[]\n    public readonly fee: BigNumber\n    public readonly adminFee: BigNumber\n    public readonly initialA: BigNumber\n    public readonly futureA: BigNumber\n    public readonly initialATime: BigNumber\n    public readonly futureATime: BigNumber\n    public readonly lpAddress: string\n\n    constructor(tokenMultipliers: BigNumber[],\n        fee: BigNumber,\n        adminFee: BigNumber,\n        initialA: BigNumber,\n        futureA: BigNumber,\n        initialATime: BigNumber,\n        futureATime: BigNumber,\n        lpAddress: string) {\n        this.lpAddress = lpAddress\n        this.tokenMultipliers = tokenMultipliers\n        this.fee = fee\n        this.adminFee = adminFee\n        this.initialA = initialA\n        this.futureA = futureA\n        this.initialATime = initialATime\n        this.futureATime = futureATime\n    }\n\n    public static mock(): StableSwapStorage {\n        const dummy = BigNumber.from(0)\n        return new StableSwapStorage([dummy], dummy, dummy, dummy, dummy, dummy, dummy, '')\n    }\n\n}","import { Price } from '../../fractions/price'\nimport { TokenAmount } from '../../fractions/tokenAmount'\nimport invariant from 'tiny-invariant'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport {\n    BigintIsh,\n    MINIMUM_LIQUIDITY,\n    ZERO,\n    // ONE,\n    FIVE,\n    // _100,\n    // FEES_NUMERATOR,\n    // FEES_DENOMINATOR,\n    FACTORY_ADDRESS,\n    TENK,\n} from '../../../constants'\nimport { sqrt, parseBigintIsh } from '../../../helperUtils'\nimport {\n    // InsufficientReservesError,\n    InsufficientInputAmountError, InsufficientReservesError\n} from '../../../errors'\nimport { Token } from '../../token'\nimport { getAmountOut, getAmountIn } from '../../calculators/weightedPairCalc'\nimport { PoolType, Pool } from '../pool'\n// import { getAmountIn, getAmountOut } from 'entities/calculators/weightedPairCalc'\nimport { ethers } from 'ethers'\nimport { ChainId } from '../../currency'\n\nconst _100 = BigNumber.from(100)\n\nlet PAIR_ADDRESS_CACHE: {\n    [token0Address: string]: {\n        [token1Address: string]: {\n            [weight0: string]: string\n        }\n    }\n} = {}\n\nconst PAIR_HASH: { [chainId: number]: string } = {\n    [ChainId.AVAX_TESTNET]: '0x9054fb12bf026c7ef2c6d1f68fbbead8f68cdbfa477faca7f9d8ec63173f87ff',\n    [ChainId.BSC_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.AVAX_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.OASIS_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.OASIS_TESTNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.BSC_TESTNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.MATIC_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.MATIC_TESTNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.QUARKCHAIN_DEV_S0]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.ARBITRUM_TETSNET_RINKEBY]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.ARBITRUM_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84'\n}\n\nexport class AmplifiedWeightedPair extends Pool {\n    public readonly address: string\n    public readonly tokens: Token[]\n    public tokenBalances: BigNumber[]\n    public virtualReserves: BigNumber[]\n    public readonly liquidityToken: Token\n    private readonly weights: BigNumber[]\n    private readonly fee: BigNumber\n    private readonly ampBPS: BigNumber\n    public readonly type: PoolType\n    public _name: string\n\n    public static getAddress(tokenA: Token, tokenB: Token, weightA: BigNumber): string {\n        const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n        const weights = tokenA.sortsBefore(tokenB) ? [weightA.toString(), _100.sub(weightA).toString()] : [_100.sub(weightA).toString(), weightA.toString()] // does safety checks\n        if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address]?.[`${weights[0]}`] === undefined) {\n            PAIR_ADDRESS_CACHE = {\n                ...PAIR_ADDRESS_CACHE,\n                [tokens[0].address]: {\n                    ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\n                    [tokens[1].address]: {\n                        ...PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address],\n                        [`${weights[0]}`]: getCreate2Address(\n                            FACTORY_ADDRESS[tokens[0].chainId],\n                            keccak256(\n                                ['bytes'],\n                                [pack(\n                                    ['address', 'address', 'uint32'],\n                                    [tokens[0].address, tokens[1].address, weights[0]]\n                                )]\n                            ),\n                            PAIR_HASH[tokens[0].chainId]\n                        )\n                    },\n                },\n            }\n        }\n\n        return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address][`${weights[0]}`]\n    }\n\n    public constructor(tokens: Token[], tokenBalances: BigNumber[], virtualReserves: BigNumber[], weightA: BigNumber, fee: BigNumber, amp: BigNumber, address?: string) {\n        super()\n\n        this.tokenBalances = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? tokenBalances\n            : [tokenBalances[1], tokenBalances[0]]\n        this.tokens = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? tokens\n            : [tokens[1], tokens[0]]\n\n        this.ampBPS = amp\n        this.weights = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? [weightA, _100.sub(weightA)]\n            : [_100.sub(weightA), weightA]\n\n        this.virtualReserves = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? virtualReserves\n            : [virtualReserves[1], virtualReserves[0]]\n\n\n        this.fee = fee\n        this.liquidityToken = new Token(\n            tokens[0].chainId,\n            address ? ethers.utils.getAddress(address) : AmplifiedWeightedPair.getAddress(this.tokens[0], this.tokens[1], this.weights[0]),\n            18,\n            'Requiem-LP',\n            'Requiem LPs'\n        )\n        this.type = PoolType.AmplifiedWeightedPair\n        this.address = !address ? AmplifiedWeightedPair.getAddress(this.token0, this.token1, this.weight0) : address\n\n        this._name = tokens.map(t => t.symbol).join('-')\n    }\n\n    public static fromBigIntish(tokens: Token[], tokenBalances: BigintIsh[], virtualReserves: BigintIsh[], weightA: BigintIsh, fee: BigintIsh, amp: BigintIsh, address?: string): AmplifiedWeightedPair {\n        return new AmplifiedWeightedPair(\n            tokens,\n            tokenBalances.map(b => BigNumber.from(b)),\n            virtualReserves.map(b => BigNumber.from(b)),\n            BigNumber.from(weightA),\n            BigNumber.from(fee),\n            BigNumber.from(amp),\n            address\n        )\n    }\n\n    public getAddressForRouter(): string {\n        return this.liquidityToken.address\n    }\n\n    /**\n     * Returns true if the token is either token0 or token1\n     * @param token to check\n     */\n    public involvesToken(token: Token): boolean {\n        return token.equals(this.token0) || token.equals(this.token1)\n    }\n\n    public get amp(): BigNumber {\n        return this.ampBPS\n    }\n\n    /**\n     * Returns the current mid price of the pair in terms of token0 in virtual reserves\n     */\n    public get token0Price(): Price {\n        return new Price(\n            this.token0,\n            this.token1,\n            this.virtualReserves[0].mul(this.weights[1]),\n            this.virtualReserves[1].mul(this.weights[0])\n        )\n    }\n\n    /**\n     * Returns the current mid price of the pair in terms of token1 in virtual reserves\n     */\n    public get token1Price(): Price {\n        return new Price(\n            this.token1,\n            this.token0,\n            this.virtualReserves[1].mul(this.weights[0]),\n            this.virtualReserves[0].mul(this.weights[1])\n        )\n    }\n\n    public poolPrice(tokenIn: Token, _: Token): Price {\n        return tokenIn.equals(this.token0) ? this.token0Price : this.token1Price\n    }\n\n    public get fee0(): BigNumber {\n        return this.fee\n    }\n\n    public poolPriceBases(tokenIn: Token, _: Token): { priceBaseIn: BigNumber; priceBaseOut: BigNumber; } {\n        if (tokenIn.equals(this.token0)) {\n            return {\n                priceBaseIn: this.virtualReserves[0].mul(this.weights[1]),\n                priceBaseOut: this.virtualReserves[1].mul(this.weights[0])\n            }\n        } else {\n            return {\n                priceBaseIn: this.virtualReserves[1].mul(this.weights[0]),\n                priceBaseOut: this.virtualReserves[0].mul(this.weights[1])\n            }\n        }\n    }\n\n    /**\n     * Return the price of the given token in terms of the other token in the pair.\n     * @param token token to return price of\n     */\n    public priceOf(token: Token): Price {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.token0Price : this.token1Price\n    }\n\n    /**\n     * Returns the chain ID of the tokens in the pair.\n     */\n    public get chainId(): ChainId {\n        return this.token0.chainId\n    }\n\n    public get token0(): Token {\n        return this.tokens[0]\n    }\n\n    public get token1(): Token {\n        return this.tokens[1]\n    }\n\n    public get reserve0(): TokenAmount {\n        return new TokenAmount(this.tokens[0], this.tokenBalances[0])\n    }\n\n    public get reserve1(): TokenAmount {\n        return new TokenAmount(this.tokens[1], this.tokenBalances[1])\n    }\n\n    public get virtualReserve0(): TokenAmount {\n        return new TokenAmount(this.tokens[0], this.virtualReserves[0])\n    }\n\n    public get virtualReserve1(): TokenAmount {\n        return new TokenAmount(this.tokens[1], this.virtualReserves[1])\n    }\n\n    public get weight0(): BigNumber {\n        return this.weights[0]\n    }\n\n    public get weight1(): BigNumber {\n        return this.weights[1]\n    }\n\n\n    public reserveOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.reserve0.raw : this.reserve1.raw\n    }\n\n\n    public virtualReserveOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.virtualReserve0.raw : this.virtualReserve1.raw\n    }\n\n    public weightOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.weight0 : this.weight1\n    }\n\n\n    public getLiquidityMinted(\n        totalSupply: TokenAmount,\n        tokenAmountA: TokenAmount,\n        tokenAmountB: TokenAmount\n    ): TokenAmount {\n        invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n        const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n            ? [tokenAmountA, tokenAmountB]\n            : [tokenAmountB, tokenAmountA]\n        invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n        let liquidity: BigNumber\n        if (totalSupply.raw.eq(ZERO)) {\n            liquidity = sqrt(tokenAmounts[0].raw.mul(tokenAmounts[1].raw)).sub(MINIMUM_LIQUIDITY)\n        } else {\n            const amount0 = tokenAmounts[0].raw.mul(totalSupply.raw).div(this.reserve0.raw)\n            const amount1 = tokenAmounts[1].raw.mul(totalSupply.raw).div(this.reserve1.raw)\n            liquidity = amount0.lte(amount1) ? amount0 : amount1\n        }\n        if (!liquidity.gt(ZERO)) {\n            throw new InsufficientInputAmountError()\n        }\n        return new TokenAmount(this.liquidityToken, liquidity)\n    }\n\n    public getLiquidityValue(\n        token: Token,\n        totalSupply: TokenAmount,\n        liquidity: TokenAmount,\n        feeOn: boolean = false,\n        kLast?: BigintIsh\n    ): TokenAmount {\n        invariant(this.involvesToken(token), 'TOKEN')\n        invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n        invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n        invariant(liquidity.raw.lte(totalSupply.raw), 'LIQUIDITY')\n\n        let totalSupplyAdjusted: TokenAmount\n        if (!feeOn) {\n            totalSupplyAdjusted = totalSupply\n        } else {\n            invariant(!!kLast, 'K_LAST')\n            const kLastParsed = parseBigintIsh(kLast)\n            if (!kLastParsed.eq(ZERO)) {\n                const rootK = sqrt(this.reserve0.raw.mul(this.reserve1.raw))\n                const rootKLast = sqrt(kLastParsed)\n                if (rootK.gt(rootKLast)) {\n                    const numerator = totalSupply.raw.mul(rootK.sub(rootKLast))\n                    const denominator = rootK.mul(FIVE).add(rootKLast)\n                    const feeLiquidity = numerator.div(denominator)\n                    totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n                } else {\n                    totalSupplyAdjusted = totalSupply\n                }\n            } else {\n                totalSupplyAdjusted = totalSupply\n            }\n        }\n\n        return new TokenAmount(\n            token,\n            liquidity.raw.mul(this.reserveOf(token)).div(totalSupplyAdjusted.raw)\n        )\n    }\n\n    // these are only supposed to be used for liquidity calculations\n    /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n    public get token0PriceRaw(): Price {\n        return new Price(this.token0, this.token1, this.tokenBalances[0], this.tokenBalances[1])\n    }\n\n    /**\n     * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n     */\n    public get token1PriceRaw(): Price {\n        return new Price(this.token1, this.token0, this.tokenBalances[1], this.tokenBalances[0])\n    }\n\n    /**\n     * Return the price of the given token in terms of the other token in the pair.\n     * @param token token to return price of\n     */\n    public priceRatioOf(token: Token): Price {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.token0PriceRaw : this.token1PriceRaw\n    }\n\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public calculateSwapGivenIn(\n        tokenIn: Token,\n        tokenOut: Token,\n        inAmount: BigNumber): BigNumber {\n        if (\n            inAmount.gte(this.reserveOf(tokenIn))\n        ) {\n            throw new InsufficientReservesError()\n        }\n        const inputReserve = this.virtualReserveOf(tokenIn)\n        const outputReserve = this.virtualReserveOf(tokenOut)\n\n        const inputWeight = this.weightOf(tokenIn)\n        const outputWeight = this.weightOf(tokenOut)\n\n        return getAmountOut(\n            inAmount,\n            inputReserve,\n            outputReserve,\n            inputWeight,\n            outputWeight,\n            this.fee\n        )\n    }\n\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public calculateSwapGivenOut(\n        tokenIn: Token,\n        tokenOut: Token,\n        outAmount: BigNumber): BigNumber {\n        if (\n            outAmount.gte(this.reserveOf(tokenOut))\n        ) {\n            throw new InsufficientReservesError()\n        }\n\n        const outputReserve = this.virtualReserveOf(tokenOut)\n        const inputReserve = this.virtualReserveOf(tokenIn)\n\n        const outputWeight = this.weightOf(tokenOut)\n        const inputWeight = this.weightOf(tokenIn)\n\n\n        return getAmountIn(\n            outAmount,\n            inputReserve,\n            outputReserve,\n            inputWeight,\n            outputWeight,\n            this.fee\n        )\n\n    }\n\n    public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pool] {\n        invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n        if (this.reserve0.raw.eq(ZERO) || this.reserve1.raw.eq(ZERO)) {\n            throw new InsufficientReservesError()\n        }\n        const inputReserve = this.virtualReserveOf(inputAmount.token)\n        const outputReserve = this.virtualReserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n        const inputWeight = this.weightOf(inputAmount.token)\n        const outputWeight = this.weightOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n\n        const outputAmount = new TokenAmount(\n            inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n\n            getAmountOut(\n                inputAmount.toBigNumber(),\n                inputReserve,\n                outputReserve,\n                inputWeight,\n                outputWeight,\n                this.fee\n            )\n        )\n        // console.log(\"OA\", outputAmount.raw.toString())\n        if (outputAmount.raw.eq(ZERO)) {\n            throw new InsufficientInputAmountError()\n        }\n\n        return [\n            outputAmount,\n            new AmplifiedWeightedPair(\n                [inputAmount.token, inputAmount.token.equals(this.token0) ? this.token1 : this.token0], // tokens\n                [this.reserveOf(inputAmount.token).add(inputAmount.raw), this.reserveOf(outputAmount.token).sub(outputAmount.raw)], // reserves\n                [inputReserve.add(inputAmount.raw), outputReserve.sub(outputAmount.raw)], // virtual reserves\n                inputWeight,\n                this.ampBPS,\n                this.fee\n            )\n        ]\n    }\n\n    public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pool] {\n        invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n        console.log(\"-- this 0\", this.reserve0.raw, \"1\", this.reserve1.raw, \"out\", outputAmount.raw)\n        if (\n            this.reserve0.raw.eq(ZERO) ||\n            this.reserve1.raw.eq(ZERO) ||\n            outputAmount.raw.gte(this.reserveOf(outputAmount.token))\n        ) {\n            throw new Error(\"insufficcient reserves\")\n        }\n\n        const outputReserve = this.virtualReserveOf(outputAmount.token)\n        const inputReserve = this.virtualReserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n        const outputWeight = this.weightOf(outputAmount.token)\n        const inputWeight = this.weightOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n        const inputAmount = new TokenAmount(\n            outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n            getAmountIn(\n                outputAmount.toBigNumber(),\n                inputReserve,\n                outputReserve,\n                inputWeight,\n                outputWeight,\n                this.fee\n            )\n        )\n\n        return [\n            inputAmount,\n            new AmplifiedWeightedPair(\n                [inputAmount.token, outputAmount.token],\n                [this.reserveOf(inputAmount.token).add(inputAmount.raw), this.reserveOf(outputAmount.token).sub(outputAmount.raw)],\n                [inputReserve.add(inputAmount.raw), outputReserve.sub(outputAmount.raw)],\n                inputWeight,\n                this.ampBPS,\n                this.fee\n            )\n        ]\n    }\n\n    public adjustForSwap(amountIn: TokenAmount, amountOut: TokenAmount) {\n        this.virtualReserves[this.indexFromToken(amountIn.token)] = this.virtualReserves[this.indexFromToken(amountIn.token)].add(amountIn.raw.mul(this.amp).div(TENK))\n        this.virtualReserves[this.indexFromToken(amountOut.token)] = this.virtualReserves[this.indexFromToken(amountOut.token)].sub(amountOut.raw.mul(this.amp).div(TENK))\n    };\n\n    public clone(): AmplifiedWeightedPair {\n        return new AmplifiedWeightedPair(this.tokens, this.tokenBalances, this.virtualReserves, this.weight0, this.fee0, this.amp, this.address)\n    }\n\n    public getName(): string {\n        return this.tokens.map((t, i) => String(this.weights[i]) + '-' + t.symbol).join('/');\n    }\n}\n\n\n","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\n\nimport { Contract } from '@ethersproject/contracts'\nimport { ethers } from 'ethers'\nimport { WeightedSwapStorage } from '../../calculators/weightedSwapStorage'\nimport {\n  BigintIsh,\n} from '../../../constants'\nimport weightedPoolABI from '../../../abis/WeightedPool.json'\nimport { Token } from '../../token'\nimport { TokenAmount } from '../../fractions/tokenAmount'\nimport { ZERO } from '../../calculators/LogExpMath'\nimport { calculateRemoveLiquidityExactIn, calculateRemoveLiquidityOneTokenExactIn, calculateSwapGivenIn, calculateSwapGivenOut, calculateTokenAmount } from '../../calculators/WeightedPoolLib'\nimport { Pool } from '../pool'\nimport { Price } from '../../fractions'\nimport { ChainId } from '../../currency'\n// const ZERO = BigNumber.from(0)\n\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport class WeightedPool extends Pool {\n  public readonly address: string\n  // the only LP token\n  public readonly liquidityToken: Token\n  // the index-token map \n  public readonly tokens: Token[]\n  public tokenBalances: BigNumber[]\n  public swapStorage: WeightedSwapStorage\n  public _name: string\n\n  public lpTotalSupply: BigNumber\n\n  public constructor(\n    poolAddress: string,\n    tokens: Token[],\n    tokenBalances: BigNumber[],\n    swapStorage: WeightedSwapStorage,\n    lpTotalSupply: BigNumber,\n    lpAddress?: string\n  ) {\n    super()\n    this.tokens = tokens\n    this.tokenBalances = tokenBalances\n    this.address = ethers.utils.getAddress(poolAddress)\n    this.lpTotalSupply = lpTotalSupply\n    this.swapStorage = swapStorage\n    this.tokens = tokens\n    this.tokenBalances = tokenBalances\n    this.liquidityToken = new Token(\n      tokens[0].chainId,\n      lpAddress ?? '0x0000000000000000000000000000000000000001',\n      18,\n      'Requiem-LP',\n      'Requiem Swap LPs'\n    )\n\n    for (let i = 0; i < Object.values(this.tokens).length; i++) {\n      invariant(tokens[i].address != ethers.constants.AddressZero, \"invalidTokenAddress\");\n      invariant(tokens[i].decimals <= 18, \"invalidDecimals\");\n      invariant(tokens[i].chainId === tokens[0].chainId, 'INVALID TOKENS')\n    }\n\n    this._name = 'Weighted Pool'\n  }\n\n  public static mock() {\n    return new WeightedPool('', [new Token(1, '0x0000000000000000000000000000000000000001', 6, 'Mock USDC', 'MUSDC')], [ZERO], WeightedSwapStorage.mock(), ZERO)\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    let res = false\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      res || token.equals(this.tokens[i])\n    }\n\n    return res\n  }\n\n  // maps the index to the token in the stablePool\n  public tokenFromIndex(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public indexFromToken(token: Token): number {\n    for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n      if (token.equals(this.tokens[index])) {\n        return index\n      }\n    }\n    throw new Error('token not in pool');\n  }\n\n  // calculates the output amount usingn the input for the swableSwap\n  // requires the view on a contract as manual calculation on the frontend would\n  // be inefficient\n  public async calculateSwapViaPing(\n    inToken: Token,\n    outToken: Token,\n    inAmount: BigNumber | BigintIsh,\n    // chainId: number,\n    provider: ethers.Signer | ethers.providers.Provider): Promise<BigintIsh> {\n\n    const outAmount: BigintIsh = await new Contract(\n      '0xCc62754F15f7F35E4c58Ce6aD5608fA575C5583E',\n      new ethers.utils.Interface(weightedPoolABI as any),\n      provider\n    ).calculateSwapGivenIn(inToken.address, outToken.address, inAmount)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenIn(\n    tokenIn: Token,\n    tokenOut: Token,\n    inAmount: BigNumber): BigNumber {\n\n    const outAmount: BigNumber = calculateSwapGivenIn(\n      this.swapStorage,\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      inAmount,\n      this.tokenBalances\n    )\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenOut(\n    tokenIn: Token,\n    tokenOut: Token,\n    outAmount: BigNumber): BigNumber {\n\n    const inAmount: BigNumber = calculateSwapGivenOut(\n      this.swapStorage,\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      outAmount,\n      this.tokenBalances,\n    )\n\n    return inAmount\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount, tokenOut: Token): TokenAmount {\n    const swap = this.calculateSwapGivenIn(inputAmount.token, tokenOut, inputAmount.raw)\n    return new TokenAmount(tokenOut, swap)\n  }\n\n  public getInputAmount(outputAmount: TokenAmount, tokenIn: Token): TokenAmount {\n    const swap = this.calculateSwapGivenOut(tokenIn, outputAmount.token, outputAmount.raw)\n    return new TokenAmount(tokenIn, swap.toBigInt())\n  }\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.tokens[0].chainId\n  }\n\n  public token(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public reserveOf(token: Token): BigNumber {\n    invariant(this.involvesToken(token), 'TOKEN')\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      if (token.equals(this.tokens[i]))\n        return this.tokenBalances[i]\n    }\n    return BigNumber.from(0)\n  }\n\n  public calculateRemoveLiquidity(amountLp: BigNumber): BigNumber[] {\n    return calculateRemoveLiquidityExactIn(\n      this.swapStorage,\n      amountLp,\n      this.lpTotalSupply,\n      this.tokenBalances\n    ).map((x, i) => x.div(this.swapStorage.tokenMultipliers[i]))\n  }\n\n  public calculateRemoveLiquidityOneToken(amount: BigNumber, index: number): { amountOut: BigNumber, swapFee: BigNumber } {\n    const { amountOut, swapFee } = calculateRemoveLiquidityOneTokenExactIn(\n      this.swapStorage,\n      index,\n      amount,\n      this.lpTotalSupply,\n      this.tokenBalances\n    )\n    return {\n      amountOut: amountOut.div(this.swapStorage.tokenMultipliers[index]),\n      swapFee\n    }\n  }\n\n  public getLiquidityAmount(amounts: BigNumber[], deposit: boolean) {\n    return calculateTokenAmount(\n      this.swapStorage,\n      amounts,\n      this.lpTotalSupply,\n      deposit,\n      this.tokenBalances,\n    )\n  }\n\n  public getLiquidityValue(outIndex: number, userBalances: BigNumber[]): TokenAmount {\n    let amount = BigNumber.from(0)\n    for (let i = 0; i < userBalances.length; i++) {\n      if (i !== outIndex)\n        amount = amount.add(this.calculateSwapGivenIn(this.tokens[i], this.tokens[outIndex], userBalances[i]))\n    }\n    amount = amount.add(userBalances[outIndex])\n    return new TokenAmount(this.tokens[outIndex], amount)\n  }\n\n  public setSwapStorage(swapStorage: WeightedSwapStorage) {\n    this.swapStorage = swapStorage\n  }\n\n  public setTokenBalances(tokenBalances: BigNumber[]) {\n    this.tokenBalances = tokenBalances\n  }\n\n  public setLpTotalSupply(totalSupply: BigNumber) {\n    this.lpTotalSupply = totalSupply\n  }\n\n  public setBalanceValueByIndex(index: number, newBalance: BigNumber) {\n    this.tokenBalances[index] = newBalance\n  }\n\n  public setBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? tokenAmount.toBigNumber() : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public addBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].add(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public subtractBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].sub(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public clone(): WeightedPool {\n    return new WeightedPool(\n      this.address,\n      this.tokens,\n      this.tokenBalances,\n      this.swapStorage,\n      this.lpTotalSupply\n    )\n  }\n\n  public poolPrice(tokenIn: Token, tokenOut: Token): Price {\n    const inIndex = this.indexFromToken(tokenIn)\n    const outIndex = this.indexFromToken(tokenOut)\n    return new Price(\n      tokenIn,\n      tokenOut,\n      this.swapStorage.normalizedWeights[outIndex].mul(this.tokenBalances[inIndex]),\n      this.swapStorage.normalizedWeights[inIndex].mul(this.tokenBalances[outIndex])\n    )\n  }\n\n  public poolPriceBases(tokenIn: Token, tokenOut: Token): { priceBaseIn: BigNumber; priceBaseOut: BigNumber; } {\n    const inIndex = this.indexFromToken(tokenIn)\n    const outIndex = this.indexFromToken(tokenOut)\n    return {\n      priceBaseIn: this.swapStorage.normalizedWeights[outIndex].mul(this.tokenBalances[inIndex]),\n      priceBaseOut: this.swapStorage.normalizedWeights[inIndex].mul(this.tokenBalances[outIndex])\n    }\n  }\n\n  public adjustForSwap(amountIn: TokenAmount, amountOut: TokenAmount) {\n    this.tokenBalances[this.indexFromToken(amountIn.token)] = this.tokenBalances[this.indexFromToken(amountIn.token)].add(amountIn.raw)\n    this.tokenBalances[this.indexFromToken(amountOut.token)] = this.tokenBalances[this.indexFromToken(amountOut.token)].sub(amountOut.raw)\n  };\n\n  public getName(): string {\n    return this._name;\n  }\n\n}\n","import { BigNumber } from 'ethers'\nimport invariant from 'tiny-invariant'\nimport { ONE_18 } from './LogExpMath'\nimport { StableSwapStorage } from './stableSwapStorage'\n\nconst MAX_ITERATION = 256\nexport const A_PRECISION = BigNumber.from(1000)\nconst FEE_DENOMINATOR = ONE_18\nconst ONE = BigNumber.from(1)\n\nexport function _xp(balances: BigNumber[], rates: BigNumber[]): BigNumber[] {\n    let result = []\n    for (let i = 0; i < balances.length; i++) {\n        result.push(rates[i].mul(balances[i]))\n    }\n    return result\n}\n\n\nexport function _getAPrecise(blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage\n): BigNumber {\n    if (blockTimestamp.gte(swapStorage.futureATime)) {\n        return swapStorage.futureA;\n    }\n\n    if (swapStorage.futureA.gt(swapStorage.initialA)) {\n        return swapStorage.initialA.add(\n            swapStorage.futureA.sub(swapStorage.initialA).mul(blockTimestamp.sub(swapStorage.initialATime)).div(\n                swapStorage.futureATime.sub(swapStorage.initialATime)))\n    }\n\n    return swapStorage.initialA.sub(swapStorage.initialA.sub(swapStorage.futureA).mul(blockTimestamp.sub(swapStorage.initialATime))).div(\n        swapStorage.futureATime.sub(swapStorage.initialATime))\n}\n\nexport function _sumOf(x: BigNumber[]): BigNumber {\n    let sum = BigNumber.from(0);\n    for (let i = 0; i < x.length; i++) {\n        sum = sum.add(x[i])\n    }\n    return sum\n}\n\n\nexport function _distance(x: BigNumber, y: BigNumber): BigNumber {\n    return x.gt(y) ? x.sub(y) : y.sub(x)\n}\n\n/**\n * Calculate D for *NORMALIZED* balances of each tokens\n * @param xp normalized balances of token\n */\nexport function _getD(xp: BigNumber[], amp: BigNumber): BigNumber {\n    const nCoins = xp.length;\n    let sum = _sumOf(xp)\n    if (sum.eq(0)) {\n        return BigNumber.from(0)\n    }\n\n    let Dprev = BigNumber.from(0)\n    let D = sum;\n    let Ann = amp.mul(nCoins)\n\n    for (let i = 0; i < MAX_ITERATION; i++) {\n        let D_P = D;\n        for (let j = 0; j < xp.length; j++) {\n            D_P = D_P.mul(D).div(xp[j].mul(nCoins))\n        }\n\n        Dprev = D;\n        D = ((Ann.mul(sum)).div(A_PRECISION).add(D_P.mul(nCoins)).mul(D)).div(\n            ((Ann.sub(A_PRECISION)).mul(D).div(A_PRECISION)).add(D_P.mul(nCoins + 1)))\n\n        if (_distance(D, Dprev).lte(1)) {\n            return D;\n        }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    invariant(\"invariantCalculationFailed\");\n    return D\n}\n\nexport function _getY(\n    inIndex: number,\n    outIndex: number,\n    inBalance: BigNumber,\n    // self, shoudl be replaced with swapStorage object\n    blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage,\n    normalizedBalances: BigNumber[]\n\n): BigNumber {\n    invariant(inIndex != outIndex, \"sameToken\");\n    const nCoins = normalizedBalances.length;\n    invariant(inIndex < nCoins && outIndex < nCoins, \"indexOutOfRange\");\n\n    let amp = _getAPrecise(blockTimestamp, swapStorage);\n    let Ann = amp.mul(nCoins)\n    let D = _getD(normalizedBalances, amp);\n    let sum = BigNumber.from(0) // sum of new balances except output token\n    let c = D;\n    for (let i = 0; i < nCoins; i++) {\n        if (i == outIndex) {\n            continue;\n        }\n\n        let x = i == inIndex ? inBalance : normalizedBalances[i];\n        sum = sum.add(x)\n        c = (c.mul(D)).div(x.mul(nCoins))\n    }\n\n    c = c.mul(D.mul(A_PRECISION)).div(Ann.mul(nCoins))\n    let b = sum.add(D.mul(A_PRECISION).div(Ann))\n\n    let lastY = BigNumber.from(0)\n    let y = D;\n    for (let index = 0; index < MAX_ITERATION; index++) {\n        lastY = y;\n        y = ((y.mul(y)).add(c)).div(y.mul(2).add(b).sub(D))\n        if (_distance(lastY, y).lte(1)) {\n            return y;\n        }\n    }\n\n    invariant(\"yCalculationFailed\")\n    return BigNumber.from(0)\n}\n\nexport function calculateSwapGivenIn(inIndex: number, outIndex: number, inAmount: BigNumber, // standard fields\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage\n): BigNumber {\n    let normalizedBalances = _xp(balances, swapStorage.tokenMultipliers)\n    let newInBalance = normalizedBalances[inIndex].add(inAmount.mul(swapStorage.tokenMultipliers[inIndex]))\n    let outBalance = _getY(\n        inIndex,\n        outIndex,\n        newInBalance,\n        blockTimestamp,\n        swapStorage,\n        normalizedBalances\n    )\n\n    let outAmount = ((normalizedBalances[outIndex].sub(outBalance)).sub(ONE)).div(swapStorage.tokenMultipliers[outIndex])\n    let _fee = swapStorage.fee.mul(outAmount).div(FEE_DENOMINATOR)\n    return outAmount.sub(_fee)\n}\n\nexport function calculateSwapGivenOut(inIndex: number, outIndex: number, outAmount: BigNumber, // standard fields\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage\n): BigNumber {\n\n    let normalizedBalances = _xp(balances, swapStorage.tokenMultipliers)\n\n    let _amountOutInclFee = outAmount.mul(FEE_DENOMINATOR).div(FEE_DENOMINATOR.sub(swapStorage.fee));\n    let newOutBalance = normalizedBalances[outIndex].sub(_amountOutInclFee.mul(swapStorage.tokenMultipliers[outIndex]));\n\n    let inBalance = _getY(\n        outIndex,\n        inIndex,\n        newOutBalance,\n        blockTimestamp,\n        swapStorage,\n        normalizedBalances\n    )\n\n    const inAmount = ((inBalance.sub(normalizedBalances[inIndex]).sub(ONE)).div(swapStorage.tokenMultipliers[inIndex])).add(ONE)\n    return inAmount;\n}\n\n// function to calculate the amounts of stables from the amounts of LP\nexport function _calculateRemoveLiquidity(\n    amount: BigNumber,\n    swapStorage: StableSwapStorage,\n    totalSupply: BigNumber,\n    currentWithdrawFee: BigNumber,\n    balances: BigNumber[]\n): BigNumber[] {\n\n    invariant(amount.lte(totalSupply), \"Cannot exceed total supply\");\n\n    let feeAdjustedAmount = amount.mul(FEE_DENOMINATOR.sub(currentWithdrawFee)).div(\n        FEE_DENOMINATOR)\n\n    let amounts = []\n\n    for (let i = 0; i < swapStorage.tokenMultipliers.length; i++) {\n        amounts.push((balances[i].mul(feeAdjustedAmount)).div(totalSupply))\n    }\n    return amounts;\n}\n\n\nfunction _getYD(\n    A: BigNumber,\n    index: number,\n    xp: BigNumber[],\n    D: BigNumber\n): BigNumber {\n    let nCoins = xp.length;\n    invariant(index < nCoins, \"INDEX\");\n    let Ann = A.mul(nCoins)\n    let c = D;\n    let s = BigNumber.from(0)\n    let _x = BigNumber.from(0)\n    let yPrev = BigNumber.from(0)\n\n    for (let i = 0; i < nCoins; i++) {\n        if (i == index) {\n            continue;\n        }\n        _x = xp[i];\n        s = s.add(_x)\n        c = (c.mul(D)).div(_x.mul(nCoins))\n    }\n\n    c = (c.mul(D).mul(A_PRECISION)).div(Ann.mul(nCoins))\n    let b = s.add(D.mul(A_PRECISION).div(Ann))\n    let y = D;\n\n    for (let i = 0; i < MAX_ITERATION; i++) {\n        yPrev = y;\n        y = ((y.mul(y)).add(c)).div(((y.mul(2)).add(b)).sub(D))\n        if (_distance(yPrev, y).lt(1)) {\n            return y;\n        }\n    }\n    invariant(\"invariantCalculationFailed\")\n    return BigNumber.from(0)\n}\n\nfunction _feePerToken(swapStorage: StableSwapStorage): BigNumber {\n    let nCoins = swapStorage.tokenMultipliers.length;\n    return (swapStorage.fee.mul(nCoins)).div(4 * (nCoins - 1));\n}\n\n\nexport function _calculateRemoveLiquidityOneToken(\n    swapStorage: StableSwapStorage,\n    tokenAmount: BigNumber,\n    index: number,\n    blockTimestamp: BigNumber,\n    balances: BigNumber[],\n    totalSupply: BigNumber,\n    currentWithdrawFee: BigNumber\n): { [returnVal: string]: BigNumber }// {dy:BigNumber, fee:BigNumber} \n{\n    invariant(index < swapStorage.tokenMultipliers.length, \"indexOutOfRange\")\n\n    let amp = _getAPrecise(blockTimestamp, swapStorage)\n    let xp = _xp(balances, swapStorage.tokenMultipliers)\n    let D0 = _getD(xp, amp);\n    let D1 = D0.sub((tokenAmount.mul(D0)).div(totalSupply))\n    let newY = _getYD(amp, index, xp, D1);\n    let reducedXP = xp;\n    let _fee = _feePerToken(swapStorage);\n\n    for (let i = 0; i < swapStorage.tokenMultipliers.length; i++) {\n        let expectedDx = BigNumber.from(0)\n        if (i == index) {\n            expectedDx = ((xp[i].mul(D1)).div(D0)).sub(newY)\n        } else {\n            expectedDx = xp[i].sub(xp[i].mul(D1).div(D0))\n        }\n        reducedXP[i] = reducedXP[i].sub(_fee.mul(expectedDx).div(FEE_DENOMINATOR))\n    }\n\n    let dy = reducedXP[index].sub(_getYD(amp, index, reducedXP, D1))\n    dy = (dy.sub(1)).div(swapStorage.tokenMultipliers[index])\n    let fee = ((xp[index].sub(newY)).div(swapStorage.tokenMultipliers[index])).sub(dy)\n    dy = dy.mul(FEE_DENOMINATOR.sub(currentWithdrawFee)).div(FEE_DENOMINATOR)\n    return { \"dy\": dy, \"fee\": fee }\n}\n\n\n/**\n * Estimate amount of LP token minted or burned at deposit or withdrawal\n * without taking fees into account\n */\nexport function _calculateTokenAmount(\n    swapStorage: StableSwapStorage,\n    amounts: BigNumber[],\n    deposit: boolean,\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    totalSupply: BigNumber\n): BigNumber {\n    let nCoins = swapStorage.tokenMultipliers.length;\n    invariant(amounts.length == nCoins, \"invalidAmountsLength\");\n    let amp = _getAPrecise(blockTimestamp, swapStorage);\n    let D0 = _getD(_xp(balances, swapStorage.tokenMultipliers), amp);\n\n    let newBalances = balances;\n    for (let i = 0; i < nCoins; i++) {\n        if (deposit) {\n            newBalances[i] = newBalances[i].add(amounts[i])\n        } else {\n            newBalances[i] = newBalances[i].sub(amounts[i])\n        }\n    }\n\n    let D1 = _getD(_xp(newBalances, swapStorage.tokenMultipliers), amp);\n\n\n    if (totalSupply.eq(0)) {\n        return D1; // first depositor take it all\n    }\n\n    let diff = deposit ? D1.sub(D0) : D0.sub(D1)\n    return (diff.mul(totalSupply)).div(D0)\n}","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\nimport {\n  _getAPrecise,\n  calculateSwapGivenIn,\n  _calculateRemoveLiquidity,\n  _calculateRemoveLiquidityOneToken,\n  _calculateTokenAmount,\n  calculateSwapGivenOut\n} from '../../calculators/stableCalc'\nimport { Contract } from '@ethersproject/contracts'\nimport { ethers } from 'ethers'\nimport { StableSwapStorage } from '../../calculators/stableSwapStorage'\nimport {\n  BigintIsh,\n  STABLE_POOL_ADDRESS\n} from '../../../constants'\nimport StableSwap from '../../../abis/RequiemStableSwap.json'\nimport { Token } from '../../token'\nimport { TokenAmount } from '../../fractions/tokenAmount'\nimport { Pool } from '../pool'\nimport { Price } from '../../fractions'\n\n// const ZERO = BigNumber.from(0)\n\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport class StablePool extends Pool {\n  public readonly address: string\n  // the only LP token\n  public readonly liquidityToken: Token\n  // the index-token map \n  public readonly tokens: Token[]\n  public tokenBalances: BigNumber[]\n  public _A: BigNumber\n  public swapStorage: StableSwapStorage\n  // public readonly rates: BigNumber[]\n  public blockTimestamp: BigNumber\n\n  public lpTotalSupply: BigNumber\n  public currentWithdrawFee: BigNumber\n  public _name: string\n\n  public constructor(\n    tokens: Token[],\n    tokenBalances: BigNumber[],\n    _A: BigNumber,\n    swapStorage: StableSwapStorage,\n    blockTimestamp: number,\n    lpTotalSupply: BigNumber,\n    currentWithdrawFee: BigNumber,\n    poolAddress: string,\n    lpAddress?: string\n  ) {\n    super()\n    this.tokens = tokens\n    this.currentWithdrawFee = currentWithdrawFee\n    this.lpTotalSupply = lpTotalSupply\n    this.swapStorage = swapStorage\n    this.blockTimestamp = BigNumber.from(blockTimestamp)\n    this.tokenBalances = tokenBalances\n    this._A = _A\n    this.liquidityToken = new Token(\n      tokens[0].chainId,\n      lpAddress ?? '0x0000000000000000000000000000000000000001',\n      18,\n      'RequiemStable-LP',\n      'Requiem StableSwap LPs'\n    )\n    this.address = ethers.utils.getAddress(poolAddress)\n\n    for (let i = 0; i < Object.values(this.tokens).length; i++) {\n      invariant(tokens[i].address != ethers.constants.AddressZero, \"invalidTokenAddress\");\n      invariant(tokens[i].decimals <= 18, \"invalidDecimals\");\n      invariant(tokens[i].chainId === tokens[0].chainId, 'INVALID TOKENS')\n    }\n\n    this._name = 'Stable Pool'\n  }\n\n  public static mock() {\n    const dummy = BigNumber.from(0)\n    return new StablePool([new Token(1, '0x0000000000000000000000000000000000000001', 6, 'Mock USDC', 'MUSDC')], [dummy], dummy, StableSwapStorage.mock(), 0, dummy, dummy, '0x0000000000000000000000000000000000000001')\n  }\n\n  public getAddressForRouter(): string {\n    return STABLE_POOL_ADDRESS[this.tokens[0].chainId]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    let res = false\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      res || token.equals(this.tokens[i])\n    }\n\n    return res\n  }\n\n  public set setCurrentWithdrawFee(feeToSet: BigNumber) {\n    this.currentWithdrawFee = feeToSet\n  }\n\n  // maps the index to the token in the stablePool\n  public tokenFromIndex(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public indexFromToken(token: Token): number {\n    for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n      if (token.equals(this.tokens[index])) {\n        return index\n      }\n    }\n    throw new Error('token not in pool');\n  }\n\n  public getBalances(): BigNumber[] {\n    return Object.keys(this.tokens).map((_, index) => (this.tokenBalances[index]))\n  }\n\n  // calculates the output amount usingn the input for the swableSwap\n  // requires the view on a contract as manual calculation on the frontend would\n  // be inefficient\n  public async calculateSwapViaPing(\n    inToken: Token,\n    outToken: Token,\n    inAmount: BigNumber | BigintIsh,\n    provider: ethers.Signer | ethers.providers.Provider): Promise<BigintIsh> {\n\n    const outAmount: BigintIsh = await new Contract(this.address, new ethers.utils.Interface(StableSwap), provider).calculateSwap(inToken.address, outToken.address, inAmount)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenIn(\n    tokenIn: Token,\n    tokenOut: Token,\n    inAmount: BigNumber): BigNumber {\n\n    // if (this.getBalances()[inIndex].lte(inAmount)) // || inAmount.eq(ZERO))\n    //   return ZERO\n\n    const outAmount: BigNumber = calculateSwapGivenIn(\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      inAmount,\n      this.tokenBalances,\n      this.blockTimestamp,\n      this.swapStorage)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenOut(\n    tokenIn: Token,\n    tokenOut: Token,\n    outAmount: BigNumber): BigNumber {\n\n    // if (this.getBalances()[outIndex].lte(outAmount)) // || outAmount.eq(ZERO))\n    //   return ZERO\n\n    const inAmount: BigNumber = calculateSwapGivenOut(\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      outAmount,\n      this.tokenBalances,\n      this.blockTimestamp,\n      this.swapStorage)\n\n    return inAmount\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount, tokenOut: Token): TokenAmount {\n    const swap = this.calculateSwapGivenIn(inputAmount.token, tokenOut, inputAmount.toBigNumber())\n    return new TokenAmount(tokenOut, swap.toBigInt())\n  }\n\n  public getInputAmount(outputAmount: TokenAmount, tokenIn: Token): TokenAmount {\n    const swap = this.calculateSwapGivenOut(tokenIn, outputAmount.token, outputAmount.toBigNumber())\n    return new TokenAmount(tokenIn, swap)\n  }\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): number {\n    return this.tokens[0].chainId\n  }\n\n  public token(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public reserveOf(token: Token): BigNumber {\n    invariant(this.involvesToken(token), 'TOKEN')\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      if (token.equals(this.tokens[i]))\n        return this.tokenBalances[i]\n    }\n    return BigNumber.from(0)\n  }\n\n  public calculateRemoveLiquidity(amountLp: BigNumber): BigNumber[] {\n    return _calculateRemoveLiquidity(\n      amountLp,\n      this.swapStorage,\n      this.lpTotalSupply,\n      this.currentWithdrawFee,\n      this.getBalances()\n    )\n  }\n\n  public calculateRemoveLiquidityOneToken(amount: BigNumber, index: number): { [returnVal: string]: BigNumber } {\n    return _calculateRemoveLiquidityOneToken(\n      this.swapStorage,\n      amount,\n      index,\n      this.blockTimestamp,\n      this.getBalances(),\n      this.lpTotalSupply,\n      this.currentWithdrawFee\n    )\n  }\n\n  public getLiquidityAmount(amounts: BigNumber[], deposit: boolean) {\n    return _calculateTokenAmount(\n      this.swapStorage,\n      amounts,\n      deposit,\n      this.getBalances(),\n      this.blockTimestamp,\n      this.lpTotalSupply\n    )\n  }\n\n  public getLiquidityValue(outIndex: number, userBalances: BigNumber[]): TokenAmount {\n    let amount = BigNumber.from(0)\n    for (let i = 0; i < userBalances.length; i++) {\n      if (i !== outIndex)\n        amount = amount.add(this.calculateSwapGivenIn(this.tokens[i], this.tokens[outIndex], userBalances[i]))\n    }\n    amount = amount.add(userBalances[outIndex])\n    return new TokenAmount(this.tokens[outIndex], amount.toBigInt())\n  }\n\n  public setSwapStorage(swapStorage: StableSwapStorage) {\n    this.swapStorage = swapStorage\n  }\n\n  public setTokenBalances(tokenBalances: BigNumber[]) {\n    this.tokenBalances = tokenBalances\n  }\n\n  public setBlockTimestamp(blockTimestamp: BigNumber) {\n    this.blockTimestamp = blockTimestamp\n  }\n\n  public setLpTotalSupply(totalSupply: BigNumber) {\n    this.lpTotalSupply = totalSupply\n  }\n\n  public setBalanceValueByIndex(index: number, newBalance: BigNumber) {\n    this.tokenBalances[index] = newBalance\n  }\n\n  public setBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? tokenAmount.toBigNumber() : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public addBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].add(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public subtractBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].sub(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public clone(): StablePool {\n    return new StablePool(\n      this.tokens, this.tokenBalances, this._A, this.swapStorage, this.blockTimestamp.toNumber(), this.lpTotalSupply, this.currentWithdrawFee, this.address\n    )\n  }\n\n  public poolPrice(tokenIn: Token, tokenOut: Token): Price {\n    const virtualIn = BigNumber.from(this.tokenBalances[this.indexFromToken(tokenIn)]).div(10000)\n    return new Price(tokenIn, tokenOut, virtualIn, this.calculateSwapGivenIn(tokenIn, tokenOut, virtualIn))\n  }\n\n\n  public poolPriceBases(tokenIn: Token, tokenOut: Token): { priceBaseIn: BigNumber; priceBaseOut: BigNumber; } {\n    const virtualIn = this.tokenBalances[this.indexFromToken(tokenIn)].div(10000)\n    return {\n      priceBaseIn: virtualIn,\n      priceBaseOut: this.calculateSwapGivenIn(tokenIn, tokenOut, virtualIn)\n    }\n  }\n\n  public adjustForSwap(amountIn: TokenAmount, amountOut: TokenAmount) {\n    this.tokenBalances[this.indexFromToken(amountIn.token)] = this.tokenBalances[this.indexFromToken(amountIn.token)].add(amountIn.raw)\n    this.tokenBalances[this.indexFromToken(amountOut.token)] = this.tokenBalances[this.indexFromToken(amountOut.token)].sub(amountOut.raw)\n  };\n\n  public getName(): string {\n    return this._name;\n  }\n} \n","import { BigNumber } from \"ethers\";\nimport invariant from \"tiny-invariant\";\nimport { ChainId } from \"../currency\";\nimport { TokenAmount } from \"../fractions\";\nimport { Token } from \"../token\";\nimport { Pool, PoolDictionary } from \"./pool\";\n\nexport interface SwapReturn {\n    amount: TokenAmount;\n    pool: { [id: string]: Pool };\n}\n\n// class that stores data for a Pair to swap through\n// does not store any pricing or calculation functions - these are used through the poolId which is taken from a pool dictionary\n// these pools are then used for pricing\nexport class SwapData {\n\n    public readonly tokenIn: Token\n    public readonly tokenOut: Token\n    public readonly poolRef: string\n    public pool: Pool | null\n\n    // these are for saving the pool price with not using the price class as it would store the token object twice\n    public priceBaseIn: BigNumber | undefined\n    public priceBaseOut: BigNumber | undefined\n\n    constructor(tokenIn: Token, tokenOut: Token, poolRef: string) {\n        // invariant(!tokenIn.equals(tokenOut), 'TOKEN')\n        this.tokenIn = tokenIn\n        this.tokenOut = tokenOut\n        this.poolRef = poolRef\n        this.pool = null;\n\n    }\n\n    public calculateSwapGivenOut(\n        tokenOutAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        return new TokenAmount(this.tokenIn, poolDict[this.poolRef].calculateSwapGivenOut(this.tokenIn, tokenOutAmount.token, tokenOutAmount.raw))\n    }\n\n    public calculateSwapGivenIn(\n        tokenInAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        return new TokenAmount(this.tokenOut, poolDict[this.poolRef].calculateSwapGivenIn(tokenInAmount.token, this.tokenOut, tokenInAmount.raw))\n    }\n\n\n    public calculateSwapGivenOutAmendingPool(\n        tokenOutAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        // const poolDictCopy = { ...poolDict }\n        const refPool: Pool = Object.assign({}, poolDict[this.poolRef]);\n        const amount = new TokenAmount(this.tokenIn, refPool.calculateSwapGivenOut(this.tokenIn, tokenOutAmount.token, tokenOutAmount.raw))\n        poolDict[this.poolRef] = refPool;\n        return amount\n    }\n\n    public calculateSwapGivenInAmendingPool(\n        tokenInAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        // const poolDictCopy = { ...poolDict }\n        const refPool: Pool = Object.assign({}, poolDict[this.poolRef]);\n        const amount = new TokenAmount(this.tokenOut, refPool.calculateSwapGivenIn(tokenInAmount.token, this.tokenOut, tokenInAmount.raw))\n        refPool.adjustForSwap(tokenInAmount, amount)\n        poolDict[this.poolRef] = refPool;\n        return amount\n\n    }\n\n    public get chainId(): ChainId { return this.tokenIn.chainId }\n\n    public involvesToken(token: Token) {\n        return this.tokenIn.address === token.address || this.tokenOut.address === token.address\n    }\n\n    /**\n     *  Calculate the mid price for a pool - if possible\n     * @param tokenIn in token for price\n     * @param tokenOut out/ quote token for price\n     * @param poolDict pool dictionary to fetch the underlying pool from\n     * @returns price object\n     */\n    public poolPrice(poolDict: { [id: string]: Pool }) {\n        return poolDict[this.poolRef].poolPrice(this.tokenIn, this.tokenOut)\n    }\n\n\n    /**\n * @param pool input pool to generate pair from\n * @returns pair route\n */\n    public static singleDataFromPool(tokenIn: Token, tokenOut: Token, pool: Pool): SwapData {\n        invariant(pool.tokens.includes(tokenIn) && pool.tokens.includes(tokenOut))\n        const data = new SwapData(tokenIn, tokenOut, pool.address)\n        data.pool = pool\n        return data;\n\n    }\n\n    public fetchPoolPrice(poolDict: PoolDictionary) {\n        const { priceBaseIn, priceBaseOut } = poolDict[this.poolRef].poolPriceBases(this.tokenIn, this.tokenOut)\n        this.priceBaseIn = priceBaseIn\n        this.priceBaseOut = priceBaseOut\n    }\n\n    public setPool(pool: Pool) {\n        this.pool = pool;\n    }\n\n}","import { ChainId } from \"../currency\";\nimport { TokenAmount } from \"../fractions\";\nimport { Token } from \"../token\";\nimport { Pool } from \"./pool\";\nimport { SwapData } from \"./swapData\";\n\n\n// class that stores data for a Pair to swap through\n// does not store any pricing or calculation functions - these are used through the poolId which is taken from a pool dictionary\n// these pools are then used for pricing\nexport class PairData {\n\n    public readonly token0: Token\n    public readonly token1: Token\n    public readonly poolRef: string\n    constructor(token0: Token, token1: Token, poolRef: string) {\n        this.token0 = token0\n        this.token1 = token1\n        this.poolRef = poolRef\n\n    }\n\n    public calculateSwapGivenOut(\n        tokenOutAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        const tokenIn = tokenOutAmount.token.equals(this.token0) ? this.token1 : this.token0\n        return new TokenAmount(tokenIn, poolDict[this.poolRef].calculateSwapGivenOut(tokenIn, tokenOutAmount.token, tokenOutAmount.raw))\n    }\n\n    public calculateSwapGivenIn(\n        tokenInAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        const tokenOut = tokenInAmount.token.equals(this.token0) ? this.token1 : this.token0\n        return new TokenAmount(tokenOut, poolDict[this.poolRef].calculateSwapGivenIn(tokenInAmount.token, tokenOut, tokenInAmount.raw))\n    }\n\n    public get chainId(): ChainId { return this.token0.chainId }\n\n    public involvesToken(token: Token) {\n        return this.token0.address === token.address || this.token1.address === token.address\n    }\n\n    /**\n     *  Calculate the mid price for a pool - if possible\n     * @param tokenIn in token for price\n     * @param tokenOut out/ quote token for price\n     * @param poolDict pool dictionary to fetch the underlying pool from\n     * @returns price object\n     */\n    public poolPrice(tokenIn: Token, tokenOut: Token, poolDict: { [id: string]: Pool }) {\n        return poolDict[this.poolRef].poolPrice(tokenIn, tokenOut)\n    }\n\n    /**\n     * Pools with n > 2 tokens generate (n^2-n)/2 possible pair routes to trade\n     * The fubnction creates these pair routes\n     * @param pool input pool to generate pairs from\n     * @returns pair routes\n     */\n    public static dataFromPool(pool: Pool): PairData[] {\n        let pairData = []\n\n        for (let i = 0; i < pool.tokenBalances.length; i++) {\n            for (let j = 0; j < i; j++) {\n                pairData.push(new PairData(pool.tokens[i], pool.tokens[j], pool.address))\n            }\n        }\n        return pairData\n    }\n\n    /**\n     * @param pool input pool to generate pair from\n     * @returns pair route\n     */\n    public static singleDataFromPool(index0: number, index1: number, pool: Pool): PairData {\n        return new PairData(pool.tokens[index0], pool.tokens[index1], pool.address)\n    }\n\n    /**\n     * Pools with n > 2 tokens generate (n^2-n)/2 possible pair routes to trade\n     * The fubnction creates these pair routes\n     * @param pool input pool to generate pairs from\n     * @returns pair routes\n     */\n    public static dataFromPools(pools: Pool[]): PairData[] {\n        let pairData = []\n        for (let k = 0; k < pools.length; k++) {\n            const pool = pools[k]\n            for (let i = 0; i < pool.tokenBalances.length; i++) {\n                for (let j = 0; j < i; j++) {\n                    pairData.push(new PairData(pool.tokens[i], pool.tokens[j], pool.address))\n                }\n            }\n        }\n        return pairData\n    }\n\n    /**\n     * Converts unordered pair to directioned swap pair\n     * @param tokenIn in token, the other will be tokenOut\n     * @returns SwapData object\n     */\n    public toSwapDataFrom(tokenIn: Token): SwapData {\n        return new SwapData(tokenIn, this.token0.equals(tokenIn) ? this.token1 : this.token0, this.poolRef)\n    }\n\n    /**\n    * Converts unordered pair to directioned swap pair\n    * @param tokenIn in token, the other will be tokenOut\n    * @returns SwapData object\n    */\n    public toSwapDataTo(tokenOut: Token): SwapData {\n        return new SwapData(this.token0.equals(tokenOut) ? this.token1 : this.token0, tokenOut, this.poolRef)\n    }\n\n    /**\n     * Converts unordered swap pairs to swap route\n     * @param pairData input pair array - has to be a route to make sense\n     * @param tokenIn \n     * @returns \n     */\n    public static toSwapArrayFrom(pairData: PairData[], tokenIn: Token): SwapData[] {\n        let swaps = []\n        let currentIn = tokenIn\n        for (let i = 0; i < pairData.length; i++) {\n            const swap = pairData[i].toSwapDataFrom(currentIn)\n            swaps.push(swap)\n            currentIn = swap.tokenOut\n        }\n        return swaps\n    }\n\n    /**\n * Converts unordered swap pairs to swap route\n * @param pairData input pair array - has to be a route to make sense\n * @param tokenIn \n * @returns \n */\n    public static toSwapArrayTo(pairData: PairData[], tokenOut: Token): SwapData[] {\n        let swaps = new Array(pairData.length)\n        let currentOut = tokenOut\n        for (let i = pairData.length - 1; i >= 0; i--) {\n            const swap = pairData[i].toSwapDataTo(currentOut)\n            swaps[i] = swap\n            currentOut = swap.tokenIn\n        }\n        return swaps\n    }\n\n\n}","import { BigNumber } from 'ethers'\nimport { Token } from '../token';\nimport {  AmplifiedWeightedPair } from '../pools/weightedPair';\n\nconst ONE = BigNumber.from(1)\nconst TEN = BigNumber.from(10)\nconst TWO = BigNumber.from(2)\nconst SQRT2x100 = BigNumber.from('141421356237309504880');\nconst ONE_E18 = BigNumber.from('1000000000000000000')\n\n\nexport function sqrrt(a: BigNumber): BigNumber {\n    let c = ONE\n    if (a.gt(3)) {\n        c = a;\n        let b = a.div(TWO).add(ONE);\n        while (b < c) {\n            c = b;\n            b = (a.div(b).add(b)).div(TWO);\n        }\n    } else if (!a.eq(0)) {\n        c = ONE;\n    }\n    return c\n}\n\nexport function getTotalValue(pair: AmplifiedWeightedPair, payoutToken: Token): BigNumber {\n    const reserve0 = pair.reserve0\n    const reserve1 = pair.reserve1\n\n    const [reservesOther, weightPayoutToken, weightOther] = payoutToken.equals(pair.token0)\n        ? [reserve1, pair.weight0, pair.weight1]\n        : [reserve0, pair.weight1, pair.weight0]\n\n    return SQRT2x100.mul(reservesOther.toBigNumber()).div(\n        sqrrt(weightOther.mul(weightOther).add(weightPayoutToken.add(weightPayoutToken))\n        )).div(ONE_E18)\n}\n\n/**\n* - calculates the value in payoutToken of the input LP amount provided\n* @param _pair general pair that has the RequiemSwap interface implemented\n* @param amount_ the amount of LP to price in REQT\n*  - is consistent with the uniswapV2-type case \n*/\nexport function valuation(pair: AmplifiedWeightedPair, totalSupply: BigNumber, amount: BigNumber, payoutToken: Token) {\n    const totalValue = getTotalValue(pair, payoutToken);\n    return totalValue.mul(amount).div(totalSupply);\n}\n\n\n\n// markdown function for bond valuation\nexport function markdown(pair: AmplifiedWeightedPair, payoutToken: Token): BigNumber {\n    const [reservesOther, weightOther, weightPayoutToken] = payoutToken.equals(pair.token0)\n        ? [pair.reserve1.toBigNumber(), BigNumber.from(pair.weight1.toString()), BigNumber.from(pair.weight0.toString())]\n        : [pair.reserve0.toBigNumber(), BigNumber.from(pair.weight0.toString()), BigNumber.from(pair.weight1.toString())];\n\n    // adjusted markdown scaling up the reserve as the trading mechnism allows\n    // higher or lower valuation for payoutToken reserve\n    return reservesOther.add(\n        weightOther.mul(reservesOther).div(weightPayoutToken)).mul(\n            TEN.pow(BigNumber.from((payoutToken.decimals))).div(\n                getTotalValue(pair, payoutToken)\n            )\n        )\n}","\n\nimport { BigNumber } from 'ethers'\nimport invariant from 'tiny-invariant';\n\nconst RESOLUTION = BigNumber.from(112);\nconst resPrec = BigNumber.from(2).pow(RESOLUTION)\nconst ZERO = BigNumber.from(0)\n// const Q112 = BigNumber.from('0x10000000000000000000000000000');\n// const Q224 = BigNumber.from('0x100000000000000000000000000000000000000000000000000000000');\n// const LOWER_MASK = BigNumber.from('0xffffffffffffffffffffffffffff'); // decimal of UQ*x112 (lower 112 bits)\n\nexport function decode(x: BigNumber) {\n    return x.div(RESOLUTION);\n}\n\nexport function decode112with18(x: BigNumber) {\n    return x.div(BigNumber.from('5192296858534827'))\n}\n\nexport function fraction(numerator: BigNumber, denominator: BigNumber) {\n\n    invariant(denominator.gt(ZERO), \"FixedPoint::fraction: division by zero\");\n    if (numerator.isZero()) return ZERO;\n\n    // if (numerator.lte(BigNumber.) <= type(uint144).max) {\n    const result = (numerator.mul(resPrec)).div(denominator)\n    //   require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n    return result;\n    // } else {\n    //    return numerator.mul(Q112).div(denominator);\n    // }\n}","import { BigNumber } from 'ethers'\nimport { Token } from '../token';\nimport {  AmplifiedWeightedPair } from '../pools/weightedPair';\nimport { valuation } from './bondCalculator';\n// import JSBI from 'jsbi';\nimport { fraction, decode112with18 } from './fixedPoint';\n\nconst ONE_E16 = BigNumber.from('10000000000000000')\nconst ONE_E18 = BigNumber.from('10000000000000000')\nconst ONE_E9 = BigNumber.from('1000000000')\n\nexport interface BondTerms {\n    controlVariable: BigNumber; // scaling variable for price\n    vesting: BigNumber; // in blocks\n    maxPayout: BigNumber; // in thousandths of a %. i.e. 500 = 0.5%\n    maxDebt: BigNumber;\n}\n\nexport function payoutFor(value: BigNumber, bondPrice: BigNumber): BigNumber {\n    return value.mul(ONE_E18.mul(ONE_E18)).div(bondPrice).div(ONE_E18)\n}\n\n\nexport function fullPayoutFor(\n    pair: AmplifiedWeightedPair,\n    currentDebt: BigNumber,\n    totalSupply: BigNumber,\n    amount: BigNumber,\n    payoutToken: Token,\n    terms: BondTerms\n): BigNumber {\n    const value = valuation(pair, totalSupply, amount, payoutToken)\n    const bondPrice_ = bondPrice(terms.controlVariable, totalSupply, currentDebt)\n    return payoutFor(value, bondPrice_)\n}\n\n\n/**\n *  @notice calculate current ratio of debt to REQT supply\n *  @return debtRatio_ uint\n */\nexport function debtRatio(totalSupply: BigNumber, currentDebt: BigNumber): BigNumber {\n\n    return decode112with18(fraction(currentDebt.mul(ONE_E9), totalSupply)).div(\n        ONE_E18);\n}\n\n\n/**\n *  @notice calculate current bond premium\n *  @return price_ uint\n */\nexport function bondPrice(controlVariable: BigNumber, totalSupply: BigNumber, currentDebt: BigNumber): BigNumber {\n    let price_ = (controlVariable.mul(debtRatio(totalSupply, currentDebt)).add(ONE_E18)).div(ONE_E16);\n    return price_\n}\n\n\n/**\n *  @notice calculate current bond premium\n *  @return price_ uint\n */\nexport function bondPriceUsingDebtRatio(controlVariable: BigNumber, debtRatio: BigNumber): BigNumber {\n    return controlVariable.mul(debtRatio).div(ONE_E18);\n\n}\n\nexport function fullPayoutForUsingDebtRatio(\n    pair: AmplifiedWeightedPair,\n    debtRatio: BigNumber,\n    totalSupply: BigNumber,\n    amount: BigNumber,\n    payoutToken: Token,\n    terms: BondTerms\n): BigNumber {\n    const value = valuation(pair, totalSupply, amount, payoutToken)\n    const bondPrice_ = bondPriceUsingDebtRatio(terms.controlVariable, debtRatio)\n    return payoutFor(value, bondPrice_)\n}","import invariant from 'tiny-invariant'\nimport { Pool, PoolDictionary } from './pools/pool'\nimport { ChainId, Currency, NETWORK_CCY } from './currency'\nimport { Token, WRAPPED_NETWORK_TOKENS } from './token'\nimport { Price } from './fractions/price'\nimport { PairData } from './pools/pairData'\n\n\n/**\n * \n * @param pools pools to generate pairData with, i.e. a 3-Pool generating the respective 6 pairs\n * @returns an array of the pairData\n */\nexport function pairDataFromPools(pools: Pool[]): PairData[] {\n  let pairData = PairData.dataFromPool(pools[0])\n  for (let i = 1; i < pools.length; i++) {\n    pairData = pairData.concat(PairData.dataFromPool(pools[i]))\n  }\n\n  return pairData\n}\n\n// new version of the route \n// the first verion to include the stable pool for less friction\nexport class Route {\n  public readonly pairData: PairData[]\n  public readonly path: Token[]\n  public readonly input: Currency\n  public readonly output: Currency\n  public readonly midPrice: Price\n\n  public constructor(poolDict: PoolDictionary, pairData: PairData[], input: Currency, output?: Currency) {\n    invariant(pairData.length > 0, 'pairData')\n\n    invariant(\n      (input instanceof Token && pairData[0].involvesToken(input)) ||\n      (input === NETWORK_CCY[pairData[0].chainId] && pairData[0].involvesToken(WRAPPED_NETWORK_TOKENS[pairData[0].chainId])),\n      'INPUT'\n    )\n    invariant(\n      typeof output === 'undefined' ||\n      (output instanceof Token && pairData[pairData.length - 1].involvesToken(output)) ||\n      (output === NETWORK_CCY[pairData[0].chainId] && pairData[pairData.length - 1].involvesToken(WRAPPED_NETWORK_TOKENS[pairData[0].chainId])),\n      'OUTPUT'\n    )\n    const path: Token[] = [input instanceof Token ? input : WRAPPED_NETWORK_TOKENS[pairData[0].chainId]]\n    for (const [i, pool] of pairData.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pool.token0) || currentInput.equals(pool.token1), 'PATH')\n      const output = currentInput.equals(pool.token0) ? pool.token1 : pool.token0\n      path.push(output)\n    }\n\n    this.pairData = pairData\n    this.path = path\n    this.midPrice = Price.fromRoute(this, poolDict)\n    this.input = input\n    this.output = output ?? path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.pairData[0].chainId\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { ONE, ZERO } from '../constants'\n// import { sortedInsert } from '../helperUtils'\nimport { ChainId, NETWORK_CCY } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount, InputOutput } from './fractions/tokenAmount'\nimport { currencyEquals, WRAPPED_NETWORK_TOKENS } from './token'\nimport {\n  PoolDictionary\n} from './pools/pool'\nimport { SwapRoute } from './swapRoute'\nimport * as _ from \"lodash\";\n// import { SwapRoute } from './swapRoute'\n// import { SwapData } from './pools/swapData'\n\nexport enum SwapType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\n// function computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n//   const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n//   // calculate slippage := (exactQuote - outputAmount) / exactQuote\n//   const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n//   return new Percent(slippage.numerator, slippage.denominator)\n// }\n\n// function computePriceImpactWeightedPair(pair: WeightedPair, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n//   const artificialMidPrice = new Price(\n//     inputAmount.currency,\n//     outputAmount.currency,\n//     pair.reserveOf(wrappedCurrency(inputAmount.currency, pair.chainId)).raw,\n//     pair.reserveOf(wrappedCurrency(outputAmount.currency, pair.chainId)).raw)\n//   const exactQuote = artificialMidPrice.raw.multiply(inputAmount.raw)\n//   // calculate slippage := (exactQuote - outputAmount) / exactQuote\n//   const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n//   return new Percent(slippage.numerator, slippage.denominator)\n// }\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Swap, b: Swap) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // // consider lowest slippage next, since these are less likely to fail\n  // if (a.priceImpact.lessThan(b.priceImpact)) {\n  //   return -1\n  // } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n  //   return 1\n  // }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === NETWORK_CCY[chainId]) return new TokenAmount(WRAPPED_NETWORK_TOKENS[chainId], currencyAmount.raw)\n  invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Swap {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: SwapRoute\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: SwapType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly swapAmounts: TokenAmount[]\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: TokenAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: TokenAmount\n\n  public readonly isValid: boolean\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  // public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: SwapRoute, amountIn: TokenAmount, poolDict: PoolDictionary): Swap {\n    return new Swap(route, amountIn, SwapType.EXACT_INPUT, poolDict)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: SwapRoute, amountOut: TokenAmount, poolDict: PoolDictionary): Swap {\n    return new Swap(route, amountOut, SwapType.EXACT_OUTPUT, poolDict)\n  }\n\n  public constructor(route: SwapRoute, amount: TokenAmount, tradeType: SwapType, poolDict: PoolDictionary) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    let _isValid = true\n    if (tradeType === SwapType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      let poolDictCopy: PoolDictionary = _.cloneDeep(poolDict);\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.swapData[i]\n        try {\n          const outputAmount = pair.calculateSwapGivenIn(amounts[i], poolDictCopy);\n          // clone pool and adjust it for the swapped amount\n          const pool = _.cloneDeep(poolDictCopy[pair.poolRef]);\n          pool.adjustForSwap(amounts[i], outputAmount)\n          // assign to cloned pool\n          poolDictCopy[pair.poolRef] = pool;\n          amounts[i + 1] = outputAmount;\n        } catch {\n          _isValid = false\n          break;\n        }\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      let poolDictCopy: PoolDictionary = _.cloneDeep(poolDict);\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.swapData[i - 1]\n        try {\n          const inputAmount = pair.calculateSwapGivenOut(amounts[i], poolDictCopy)\n          // clone pool and adjust it for the swapped amount\n          const pool = _.cloneDeep(poolDictCopy[pair.poolRef]);\n          pool.adjustForSwap(inputAmount, amounts[i])\n          // assign to cloned pool\n          poolDictCopy[pair.poolRef] = pool;\n          amounts[i - 1] = inputAmount\n        } catch {\n          _isValid = false\n          break;\n        }\n      }\n    }\n    this.isValid = _isValid\n    this.route = route\n    this.tradeType = tradeType\n    this.swapAmounts = amounts\n    if (this.isValid) {\n      this.inputAmount = tradeType === SwapType.EXACT_INPUT ? amount : amounts[0]\n      this.outputAmount = tradeType === SwapType.EXACT_OUTPUT ? amount : amounts[amounts.length - 1]\n    } else { // default\n      this.inputAmount = tradeType === SwapType.EXACT_INPUT ? amount : new TokenAmount(this.route.swapData[0].tokenIn, '0')\n      this.outputAmount = tradeType === SwapType.EXACT_OUTPUT ? amount : new TokenAmount(this.route.swapData[this.route.swapData.length - 1].tokenIn, '0')\n    }\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    // this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): TokenAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === SwapType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): TokenAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === SwapType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n    }\n  }\n  /**\n   * \n   * @param swapRoutes input routes - should already not include duplicates\n   * @param swapType determines in which direction the swap will be calculated\n   * @param poolDict dictionary used to price the trade routes\n   * @returns trades in an array\n   */\n  public static PriceRoutes(swapRoutes: SwapRoute[], amount: TokenAmount, swapType: SwapType, poolDict: PoolDictionary): Swap[] {\n    const swaps: Swap[] = []\n    for (let i = 0; i < swapRoutes.length; i++) {\n      const swap = new Swap(swapRoutes[i], amount, swapType, poolDict)\n      if (swap.isValid)\n        swaps.push(swap)\n    }\n    if (swapType === SwapType.EXACT_INPUT)\n      return swaps.sort((a, b) => (a.outputAmount.raw.lt(b.outputAmount.raw) ? 1 : -1))\n    else\n      return swaps.filter(s => Swap.validateRouteForExactOut(s.route)).sort((a, b) => (a.inputAmount.raw.gt(b.inputAmount.raw)) ? 1 : -1)\n  }\n\n  /**\n   * @notice the solidity router cannot calculate exact out swaps whewn routing twice through the same pool\n   * -> this function returns false if the route is of that kind\n   * @param route \n   * @returns \n   */\n  public static validateRouteForExactOut(route: SwapRoute): boolean {\n    const refs = route.swapData.map(sd => sd.poolRef)\n    return (new Set(refs)).size === refs.length;\n  }\n\n}\n\n\n\n\n\n\n\n","import { ChainId } from './currency'\nimport { Token } from './token'\nimport { SwapData } from './pools/swapData'\n\n\n\n// new version of the route \n// the first verion to include the stable pool for less friction\nexport class SwapRoute {\n  public readonly swapData: SwapData[]\n  public readonly path: Token[]\n  public readonly input: Token\n  public readonly output: Token\n  public readonly identifier: string\n  // public readonly midPrice: Price\n\n  public constructor(swapData: SwapData[]) {\n\n    const path: Token[] = [swapData[0].tokenIn]\n\n    // it can happen that the pool is traded through consecutively, we want to remove this case \n    const swapDataAggregated = []\n    for (let i = 0; i < swapData.length; i++) {\n      let currentSwap = swapData[i]\n      const tokenIn = currentSwap.tokenIn\n      let relevantOut = currentSwap.tokenOut\n      for (let j = i + 1; j < swapData.length; j++) {\n        if (swapData[j].poolRef === currentSwap.poolRef) {\n          currentSwap = swapData[j]\n          relevantOut = currentSwap.tokenOut\n          i++\n        } else {\n          break;\n        }\n      }\n      const swap = new SwapData(tokenIn, relevantOut, currentSwap.poolRef)\n      swapDataAggregated.push(swap)\n      // const currentInput = path[i]\n      // invariant(currentInput.equals(currentSwap.tokenIn), 'PATH')\n      const output = currentSwap.tokenOut\n      path.push(output)\n    }\n\n\n    this.swapData = swapDataAggregated\n\n    this.identifier = swapDataAggregated.map(x => x.poolRef).join('') + path.map(p => p.address).join('')\n    this.path = path\n    // this.midPrice = Price.fromRoute(this, poolDict)\n    this.input = path[0]\n    this.output = path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.swapData[0].chainId\n  }\n\n  public equals(otherRoute: SwapRoute): boolean {\n    for (let i = 0; i < this.swapData.length; i++) {\n      if (!this.swapData[i].tokenIn.equals(otherRoute.swapData[i].tokenIn) && !this.swapData[i].tokenOut.equals(otherRoute.swapData[i].tokenOut) && !(this.swapData[i].poolRef === otherRoute.swapData[i].poolRef))\n        return false\n    }\n    return true\n  }\n\n  public static cleanRoutes(swapRoutes: SwapRoute[]): SwapRoute[] {\n    var routeIds: string[] = []\n    var routes: SwapRoute[] = []\n    for (var i = 0; i < swapRoutes.length; i++) {\n      if (!routeIds.includes(swapRoutes[i].identifier)) {\n        routeIds.push(swapRoutes[i].identifier)\n        routes.push(swapRoutes[i])\n      }\n    }\n    return routes\n  }\n\n}\n","\n\n// import { SwapData } from \"entities/pools/SwapData\";\n// import { BigNumber } from \"ethers\";\n// import { Pool, PoolDictionary, PoolHops, Token, ZERO } from \".\";\n\nimport { PairData } from \"./entities/pools/pairData\"\nimport { SwapData } from \"./entities/pools/swapData\"\nimport { SwapRoute } from \"./entities/swapRoute\"\nimport invariant from \"tiny-invariant\"\nimport { ChainId, Currency, NETWORK_CCY, Token, WRAPPED_NETWORK_TOKENS } from \"./entities\"\n\n\nexport function wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n    if (currency instanceof Token) return currency\n    if (currency === NETWORK_CCY[chainId]) return WRAPPED_NETWORK_TOKENS[chainId]\n    invariant(false, 'CURRENCY')\n  }\n\nexport class RouteProvider {\n\n  /**\n  * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n  * amount to an output token, making at most `maxHops` hops.\n  * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n  * the amount in among multiple routes.\n  * @param pairs the pairs to consider in finding the best trade\n  * @param currencyAmountIn exact amount of input currency to spend\n  * @param currencyOut the desired currency out\n  * @param maxNumResults maximum number of results to return\n  * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n  * @param currentPairs used in recursion; the current list of pairs\n  * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n  * @param bestTrades used in recursion; the current list of best trades\n  */\n   public static getRouteIteration(\n    pairData: PairData[],\n    tokenIn: Token,\n    tokenOut: Token,\n    maxHops = 3,\n    // used in recursion.\n    lastPool:string='',\n    currentpools: SwapData[] = [],\n    originalCurrencyIn: Token = tokenIn,\n    bestRoutes: SwapRoute[] = []\n  ): SwapRoute[] {\n    invariant(pairData.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalCurrencyIn === tokenIn || currentpools.length > 0, 'INVALID_RECURSION')\nconst relevantPairs = pairData.filter(p=>p.poolRef !== lastPool)\n    for (let i = 0; i < relevantPairs.length; i++) {\n      let pair = relevantPairs[i]\n      // filters for valid connection\n      const inIs0 = pair.token0.equals(tokenIn)\n      if (!inIs0 && !pair.token1.equals(tokenIn)) continue;\n      \n      const tokenOutNew: Token = inIs0 ? pair.token1 : pair.token0\n      \n      let swap:SwapData\n      // const lastSwap:SwapData = currentpools[currentpools.length -1]\n\n      // if(lastSwap?.poolRef === pair.poolRef)\n      // {\n        // swap =  new SwapData(lastSwap.tokenIn, tokenOutNew, pair.poolRef)\n      //   currentpools.splice(currentpools.length -1,1)\n      // } else\n      // {\n        swap = new SwapData(tokenIn, tokenOutNew, pair.poolRef)\n      // }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (tokenOutNew.equals(tokenOut)) {\n        bestRoutes.push(new SwapRoute([...currentpools, swap]))\n      } else if (maxHops > 1 && relevantPairs.length > 1) {\n        // const poolsExcludingThispool = pairData.slice(0, i).concat(pairData.slice(i + 1, pairData.length)) // pairData.filter(data => data.poolRef !== pair.poolRef)\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        RouteProvider.getRouteIteration(\n          // poolsExcludingThispool,\n          pairData,\n          tokenOutNew,\n          tokenOut,\n          maxHops - 1,\n          pair.poolRef,\n          [...currentpools, swap],\n          originalCurrencyIn,\n          bestRoutes\n        )\n      }\n\n    }\n    return bestRoutes\n  }\n\n  public static getRoutes(\n    pairData: PairData[],\n    currencyIn: Token,\n    currencyOut: Token,\n    maxHops = 3\n  ): SwapRoute[] {\n    return this.getRouteIteration(\n      pairData,\n      currencyIn,\n      currencyOut,\n      maxHops,\n      '',\n      [],\n      currencyIn,\n      []\n    )\n  }\n}\n\n\n// export enum SwapTypes {\n//     SwapExactIn,\n//     SwapExactOut,\n// }\n\n// export interface SwapOptions {\n//     gasPrice: BigNumber;\n//     swapGas: BigNumber;\n//     timestamp: number;\n//     maxPools: number;\n//     poolTypeFilter: PoolFilter;\n//     forceRefresh: boolean;\n// }\n\n\n// export enum PoolFilter {\n//     All = 'All',\n//     Weighted = 'Weighted',\n//     Stable = 'Stable',\n//     MetaStable = 'MetaStable',\n//     LBP = 'LiquidityBootstrapping',\n//     Investment = 'Investment',\n//     Element = 'Element',\n//     AaveLinear = 'AaveLinear',\n//     StablePhantom = 'StablePhantom',\n//     ERC4626Linear = 'ERC4626Linear',\n// }\n\n\n// /*\n// The purpose of this function is to build dictionaries of direct pools \n// and plausible hop pools.\n// */\n// export function filterPoolsOfInterest(\n//     allPools: PoolDictionary,\n//     tokenIn: Token,\n//     tokenOut: Token,\n//     maxPools: number\n// ): [PoolDictionary, PoolHops, PoolHops] {\n//     const directPools: PoolDictionary = {};\n//     const hopsIn: PoolHops = {};\n//     const hopsOut: PoolHops = {};\n\n//     Object.keys(allPools).forEach((id) => {\n//         const pool = allPools[id];\n//         const tokenListSet = new Set(pool.tokens);\n//         const containsTokenIn = tokenListSet.has(tokenIn);\n//         const containsTokenOut = tokenListSet.has(tokenOut);\n\n//         // This is a direct pool as has both tokenIn and tokenOut\n//         if (containsTokenIn && containsTokenOut) {\n//             directPools[pool.address] = pool;\n//             return;\n//         }\n\n//         if (maxPools > 1) {\n//             if (containsTokenIn && !containsTokenOut) {\n//                 for (const hopToken of tokenListSet) {\n//                     if (!hopsIn[hopToken.address]) hopsIn[hopToken.address] = new Set([]);\n//                     hopsIn[hopToken.address].add(pool.address);\n//                 }\n//             } else if (!containsTokenIn && containsTokenOut) {\n//                 for (const hopToken of [...tokenListSet]) {\n//                     if (!hopsOut[hopToken.address]) hopsOut[hopToken.address] = new Set([]);\n//                     hopsOut[hopToken.address].add(pool.address);\n//                 }\n//             }\n//         }\n//     });\n//     return [directPools, hopsIn, hopsOut];\n// }\n\n\n\n// export function searchConnectionsTo(\n//     token: Token,\n//     poolsDict: { [id: string]: Pool },\n//     toToken: Token\n//   ): Path[] {\n//     // this assumes that every pool in poolsDict contains toToken\n//     const connections: Path[] = [];\n//     for (const id in poolsDict) {\n//       const pool = poolsDict[id];\n//       if (pool.involvesToken(token)) {\n//         const connection = createPath([token, toToken], [pool]);\n//         connections.push(connection);\n//       }\n//     }\n//     return connections;\n//   }\n  \n//   export interface Path {\n//     id: string; // pool address if direct path, contactenation of pool addresses if multihop\n//     swaps: Swap[];\n//   }\n  \n//   export interface Swap {\n//     pool: string;\n//     tokenIn: Token;\n//     tokenOut: Token;\n//     swapAmount?: BigNumber;\n//   }\n  \n//   // Creates a path with pools.length hops\n//   // i.e. tokens[0]>[Pool0]>tokens[1]>[Pool1]>tokens[2]>[Pool2]>tokens[3]\n//   export function createPath(tokens: Token[], pools: Pool[]): Path {\n//     let tI: Token, tO: Token;\n//     const swaps: Swap[] = [];\n//     // const poolPairData: PairData[] = [];\n//     let id = '';\n  \n//     for (let i = 0; i < pools.length; i++) {\n//       tI = tokens[i];\n//       tO = tokens[i + 1];\n//       // const poolPair = pools[i].parsePoolPairData(tI, tO);\n//       // poolPairData.push(poolPair);\n  \n//       const swap: Swap = {\n//         pool: pools[i].address,\n//         tokenIn: tI,\n//         tokenOut: tO,\n//       };\n  \n//       swaps.push(swap);\n//     }\n  \n//     const path: Path = {\n//       id,\n//       swaps,\n//     };\n  \n//     return path;\n//   }\n  \n  \n  \n\n\n// export function producePaths(\n//     tokenIn: Token,\n//     tokenOut: Token,\n//     directPools: PoolDictionary,\n//     hopsIn: PoolHops,\n//     hopsOut: PoolHops,\n//     pools: PoolDictionary\n// ): Path[] {\n//     const paths: Path[] = [];\n\n//     // Create direct paths\n//     for (const id in directPools) {\n//         const path = createPath([tokenIn, tokenOut], [pools[id]]);\n//         paths.push(path);\n//     }\n\n//     for (const hopToken in hopsIn) {\n//         if (hopsOut[hopToken]) {\n//             let highestNormalizedLiquidityFirst = ZERO; // Aux variable to find pool with most liquidity for pair (tokenIn -> hopToken)\n//             let highestNormalizedLiquidityFirstPoolId: string | undefined; // Aux variable to find pool with most liquidity for pair (tokenIn -> hopToken)\n//             let highestNormalizedLiquiditySecond = ZERO; // Aux variable to find pool with most liquidity for pair (hopToken -> tokenOut)\n//             let highestNormalizedLiquiditySecondPoolId: string | undefined; // Aux variable to find pool with most liquidity for pair (hopToken -> tokenOut)\n//             for (const poolInId of [...hopsIn[hopToken]]) {\n//                 const poolIn = pools[poolInId.address];\n//                 const poolPairData = SwapData.singleDataFromPool(\n//                     tokenIn,\n//                     hopToken,\n//                     poolIn\n//                 );\n     \n//                 // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n//                 if (\n//                     normalizedLiquidity.isGreaterThanOrEqualTo(\n//                         highestNormalizedLiquidityFirst\n//                     )\n//                 ) {\n//                     highestNormalizedLiquidityFirst = normalizedLiquidity;\n//                     highestNormalizedLiquidityFirstPoolId = poolIn.id;\n//                 }\n//             }\n//             for (const poolOutId of [...hopsOut[hopToken]]) {\n//                 const poolOut = pools[poolOutId.address];\n//                 const poolPairData = poolOut.parsePoolPairData(\n//                     hopToken,\n//                     tokenOut\n//                 );\n//                 const normalizedLiquidity =\n//                     poolOut.getNormalizedLiquidity(poolPairData);\n//                 // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n//                 if (\n//                     normalizedLiquidity.isGreaterThanOrEqualTo(\n//                         highestNormalizedLiquiditySecond\n//                     )\n//                 ) {\n//                     highestNormalizedLiquiditySecond = normalizedLiquidity;\n//                     highestNormalizedLiquiditySecondPoolId = poolOut.address;\n//                 }\n//             }\n//             if (\n//                 highestNormalizedLiquidityFirstPoolId &&\n//                 highestNormalizedLiquiditySecondPoolId\n//             ) {\n//                 const path = createPath(\n//                     [tokenIn, hopToken, tokenOut],\n//                     [\n//                         pools[highestNormalizedLiquidityFirstPoolId],\n//                         pools[highestNormalizedLiquiditySecondPoolId],\n//                     ]\n//                 );\n//                 paths.push(path);\n//             }\n//         }\n//     }\n//     return paths;\n// }\n\n\n// export class RouteProvider {\n//     cache: Record<string, { paths: Path[] }> = {};\n\n//     // constructor(private readonly config: SorConfig) {}\n\n//     /**\n//      * Given a list of pools and a desired input/output, returns a set of possible paths to route through\n//      */\n//     getCandidatePaths(\n//         tokenIn: Token,\n//         tokenOut: Token,\n//         swapType: SwapTypes,\n//         poolsAllDict: PoolDictionary,\n//         swapOptions: SwapOptions\n//     ): Path[] {\n//         if (!poolsAllDict) return [];\n\n//         // If token pair has been processed before that info can be reused to speed up execution\n//         const cache =\n//             this.cache[\n//             `${tokenIn.address}${tokenOut.address}${swapType}${swapOptions.timestamp}`\n//             ];\n\n//         // forceRefresh can be set to force fresh processing of paths/prices\n//         if (!swapOptions.forceRefresh && !!cache) {\n//             // Using pre-processed data from cache\n//             return cache.paths;\n//         }\n\n//         const [directPools, hopsIn, hopsOut] = filterPoolsOfInterest(\n//             poolsAllDict,\n//             tokenIn,\n//             tokenOut,\n//             swapOptions.maxPools\n//         );\n\n//         const pathData = producePaths(\n//             tokenIn,\n//             tokenOut,\n//             directPools,\n//             hopsIn,\n//             hopsOut,\n//             poolsAllDict\n//         );\n\n//         const boostedPaths = getBoostedPaths(\n//             tokenIn,\n//             tokenOut,\n//             poolsAllDict,\n//             this.config\n//         );\n\n//         const pathsUsingStaBal = getPathsUsingStaBalPool(\n//             tokenIn,\n//             tokenOut,\n//             poolsAllDict,\n//             poolsAllDict,\n//             this.config\n//         );\n\n//         const combinedPathData = pathData\n//             .concat(...boostedPaths)\n//             .concat(...pathsUsingStaBal);\n//         const [paths] = calculatePathLimits(combinedPathData, swapType);\n\n//         this.cache[`${tokenIn}${tokenOut}${swapType}${swapOptions.timestamp}`] =\n//         {\n//             paths: paths,\n//         };\n\n//         return paths;\n//     }\n\n//     /**\n//      * Given a pool dictionary and a desired input/output, returns a set of possible paths to route through.\n//      * @param {string} tokenIn - Address of tokenIn\n//      * @param {string} tokenOut - Address of tokenOut\n//      * @param {SwapTypes} swapType - SwapExactIn where the amount of tokens in (sent to the Pool) is known or SwapExactOut where the amount of tokens out (received from the Pool) is known.\n//      * @param {PoolDictionary} poolsAllDict - Dictionary of pools.\n//      * @param {number }maxPools - Maximum number of pools to hop through.\n//      * @returns {NewPath[]} Array of possible paths sorted by liquidity.\n//      */\n//     getCandidatePathsFromDict(\n//         tokenIn: string,\n//         tokenOut: string,\n//         swapType: SwapTypes,\n//         poolsAllDict: PoolDictionary,\n//         maxPools: number\n//     ): NewPath[] {\n//         if (Object.keys(poolsAllDict).length === 0) return [];\n\n//         const [directPools, hopsIn, hopsOut] = filterPoolsOfInterest(\n//             poolsAllDict,\n//             tokenIn,\n//             tokenOut,\n//             maxPools\n//         );\n\n//         const pathData = producePaths(\n//             tokenIn,\n//             tokenOut,\n//             directPools,\n//             hopsIn,\n//             hopsOut,\n//             poolsAllDict\n//         );\n\n//         const boostedPaths = getBoostedPaths(\n//             tokenIn,\n//             tokenOut,\n//             poolsAllDict,\n//             this.config\n//         );\n\n//         const combinedPathData = pathData.concat(...boostedPaths);\n//         const [paths] = calculatePathLimits(combinedPathData, swapType);\n//         return paths;\n//     }\n// }\n","\nimport invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from './helperUtils'\nimport { CurrencyAmount, Percent, Swap, SwapType } from './entities'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n\n  /**\n   * Whether we swap through multiple routers / pair types\n   */\n  multiSwap?: boolean\n\n  /**\n   * Checks whether the networkccy is used in in- or output: helps us to avoid checks in route calculations\n   */\n  etherIn: boolean\n  etherOut: boolean\n}\n\nexport interface SwapOptionsDeadline extends Omit<SwapOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[] | string[][])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount) {\n  return currencyAmount.raw.toHexString()\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Router, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() { }\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(trade: Swap, options: SwapOptions | SwapOptionsDeadline): SwapParameters {\n    const etherIn = options.etherIn\n    const etherOut = options.etherOut\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n\n\n    let methodName: string\n\n    let args: (string | string[] | string[][])[] = []\n    let value: string\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    if (!options.multiSwap) {\n      const path: string[] = trade.route.path.map((token) => token.address)\n      const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n      switch (trade.tradeType) {\n        case SwapType.EXACT_INPUT:\n          if (etherIn) {\n            methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n            // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n            args = [amountOut, path, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n            // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n            args = [amountIn, amountOut, path, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = useFeeOnTransfer\n              ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n              : 'swapExactTokensForTokens'\n            // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n            args = [amountIn, amountOut, path, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n        case SwapType.EXACT_OUTPUT:\n          invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n          if (etherIn) {\n            methodName = 'swapETHForExactTokens'\n            // (uint amountOut, address[] calldata path, address to, uint deadline)\n            args = [amountOut, path, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = 'swapTokensForExactETH'\n            // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n            args = [amountOut, amountIn, path, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = 'swapTokensForExactTokens'\n            // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n            args = [amountOut, amountIn, path, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n      }\n    } else {\n      const path = trade.route.path.map(token => token.address)\n      const pairData = trade.route.swapData.map(p => p.poolRef)\n\n      switch (trade.tradeType) {\n        case SwapType.EXACT_INPUT:\n          if (etherIn) {\n            methodName = 'onSwapExactETHForTokens'\n            // function multiSwapExactETHForTokens( address[][] calldata path, uint256[] memory routerId,\n            // uint256 amountOutMin, uint256 deadline )\n            args = [pairData, path, amountOut, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = 'onSwapExactTokensForETH'\n            // multiSwapExactTokensForETH( address[][] calldata path, uint256[] memory pools, uint256 amountIn,\n            // uint256 amountOutMin, uint256 deadline )\n            args = [pairData, path, amountIn, amountOut, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = 'onSwapExactTokensForTokens'\n            // function onSwapExactTokensForTokens(\n            //   address[] memory pools,\n            //   address[] memory tokens,\n            //   uint256 amountIn,\n            //   uint256 amountOutMin,\n            //   address to,\n            //   uint256 deadline\n            args = [pairData, path, amountIn, amountOut, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n        case SwapType.EXACT_OUTPUT:\n          if (etherIn) {\n            methodName = 'onSwapETHForExactTokens'\n            // multiSwapETHForExactTokens( address[][] calldata path, uint256[] memory pools, uint256 amountOut, uint256 deadline )\n            args = [pairData, path, amountOut, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = 'onSwapTokensForExactETH'\n            // multiSwapTokensForExactETH( address[][] calldata path, uint256[] memory pools,\n            // uint256 amountOut, uint256 amountInMax, uint256 deadline )\n            args = [pairData, path, amountOut, amountIn, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = 'onSwapTokensForExactTokens'\n            // multiSwapTokensForExactTokens( address[][] calldata path, uint256[] memory pools, \n            // uint256 amountOut, uint256 amountInMax,  uint256 deadline )\n            args = [pairData, path, amountOut, amountIn, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n      }\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n"],"names":["TradeType","SolidityType","FACTORY_ADDRESS","56","97","80001","43113","STABLE_POOL_ADDRESS","42261","110001","MINIMUM_LIQUIDITY","BigNumber","from","ZERO","ONE","TWO","THREE","FIVE","TEN","TENK","_100","SOLIDITY_TYPE_MAXIMA","uint8","uint256","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","_this","name","constructor","setPrototypeOf","prototype","_inheritsLoose","Error","InsufficientInputAmountError","_this2","validateSolidityTypeInstance","value","solidityType","gte","invariant","lte","validateAndParseAddress","address","getAddress","error","parseBigintIsh","bigintIsh","toString","sqrt","y","x","z","gt","div","add","lt","eq","ChainId","Currency","chainId","decimals","symbol","this","NETWORK_CCY","TT_MAINNET","TT_TESTNET","BSC_MAINNET","BSC_TESTNET","ARBITRUM_MAINNET","ARBITRUM_TETSNET_RINKEBY","AVAX_MAINNET","AVAX_TESTNET","MATIC_MAINNET","MATIC_TESTNET","OASIS_MAINNET","OASIS_TESTNET","QUARKCHAIN_DEV_S0","Token","projectLink","_proto","equals","other","sortsBefore","toLowerCase","currencyEquals","currencyA","currencyB","Rounding","WETH","WRAPPED_NETWORK_TOKENS","STABLECOINS","0","STABLES_INDEX_MAP","1","2","3","STABLES_LP_TOKEN","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","numerator","denominator","invert","otherParsed","mul","subtract","sub","lessThan","equalTo","greaterThan","multiply","divide","toSignificant","significantDigits","format","rounding","groupSeparator","Number","isInteger","set","precision","quotient","toSignificantDigits","decimalPlaces","toFixed","DP","RM","_createClass","key","get","mod","_100_PERCENT","Percent","CurrencyAmount","currency","amount","parsedAmount","pow","networkCCYAmount","raw","toExact","toBigNumber","TokenAmount","token","Price","baseCurrency","quoteCurrency","scalar","fromRoute","route","poolDict","prices","pairData","entries","i","price","poolPrice","path","push","slice","reduce","accumulator","currentValue","fraction","quote","currencyAmount","_Fraction","adjusted","ONE_18","ONE_20","ONE_36","LN_36_LOWER_BOUND","LN_36_UPPER_BOUND","x0","a0","x1","a1","x2","a2","x3","a3","x4","a4","x5","a5","x6","a6","x7","a7","x8","a8","x9","a9","x10","a10","x11","a11","logx_times_y","x_int256","y_int256","ln_36_x","_ln_36","_ln","exp","firstAN","product","term","seriesSum","a","sum","z_squared","num","MAX_POW_RELATIVE_ERROR","MIN_POW_BASE_FREE_EXPONENT","mulDown","b","mulUp","divDown","divUp","powDown","maxError","powUp","complement","max","_MAX_IN_RATIO","_MAX_OUT_RATIO","_MAX_INVARIANT_RATIO","_MIN_INVARIANT_RATIO","_calcOutGivenIn","balanceIn","weightIn","balanceOut","weightOut","amountIn","_calcInGivenOut","amountOut","_calcLpOutGivenExactTokensIn","balances","normalizedWeights","amountsIn","lpTotalSupply","swapFeePercentage","balanceRatiosWithFee","invariantRatioWithFees","length","_computeJoinExactTokensInInvariantRatio","invariantRatio","swapFees","lpOut","amountInWithoutFee","nonTaxableAmount","taxableAmount","swapFee","_calcAllTokensInGivenExactLpOut","lpAmountOut","totalBPT","lpRatio","_calcLpInGivenExactTokensOut","amountsOut","balanceRatiosWithoutFee","Array","invariantRatioWithoutFees","_computeExitExactTokensOutInvariantRatio","lpIn","amountOutWithFee","taxableAmountPlusFees","_calcTokenOutGivenExactLpIn","balance","normalizedWeight","lpAmountIn","amountOutWithoutFee","FEE_DENOMINATOR","calculateRemoveLiquidityOneTokenExactIn","self","outIndex","lpAmount","lpSupply","tokenBalances","tokenMultipliers","fee","calculateRemoveLiquidityExactIn","_xp","calculateTokenAmount","amounts","deposit","calculateSwapGivenIn","inIndex","amountInWithFee","calculateSwapGivenOut","rates","result","_256","_128","FIXED_1","FIXED_2","MAX_NUM","LN2_NUMERATOR","LN2_DENOMINATOR","OPT_LOG_MAX_VAL","OPT_EXP_MAX_VAL","maxExpArray","leftShift","shift","signedRightShift","power","_baseN","_baseD","_expN","_expD","base","baseLogTimesExp","optimalLog","generalLog","optimalExp","findPositionInMaxExpArray","generalExp","res","count","_n","s","or","floorLog2","w","and","isZero","_x","_precision","xi","lo","hi","mid","getAmountOut","reserveIn","reserveOut","tokenWeightIn","tokenWeightOut","temp1","temp2","getAmountIn","baseD","baseReserveIn","PoolType","WeightedSwapStorage","adminFee","mock","StableSwapStorage","initialA","futureA","initialATime","futureATime","lpAddress","dummy","Pool","involvesToken","keys","tokens","tokenFromIndex","index","indexFromToken","getBalances","map","_","reserveOf","setBalanceValueByIndex","newBalance","getTokenAmounts","t","setTokenBalances","subtractBalanceValue","tokenAmount","newBalances","_name","PAIR_ADDRESS_CACHE","PAIR_HASH","AmplifiedWeightedPair","virtualReserves","weightA","amp","ampBPS","weights","liquidityToken","ethers","utils","type","token0","token1","weight0","join","tokenA","tokenB","undefined","_PAIR_ADDRESS_CACHE2","_PAIR_ADDRESS_CACHE3","_PAIR_ADDRESS_CACHE3$","getCreate2Address","keccak256","pack","fromBigIntish","getAddressForRouter","tokenIn","token0Price","token1Price","poolPriceBases","priceBaseIn","priceBaseOut","priceOf","reserve0","reserve1","virtualReserveOf","virtualReserve0","virtualReserve1","weightOf","weight1","getLiquidityMinted","totalSupply","tokenAmountA","tokenAmountB","liquidity","tokenAmounts","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","priceRatioOf","token0PriceRaw","token1PriceRaw","tokenOut","inAmount","outAmount","outputReserve","inputReserve","outputWeight","getOutputAmount","inputAmount","inputWeight","outputAmount","getInputAmount","console","log","adjustForSwap","clone","fee0","getName","String","WeightedPool","poolAddress","swapStorage","values","constants","AddressZero","calculateSwapViaPing","inToken","outToken","provider","Contract","Interface","weightedPoolABI","swap","toBigInt","calculateRemoveLiquidity","amountLp","calculateRemoveLiquidityOneToken","getLiquidityAmount","userBalances","setSwapStorage","setLpTotalSupply","setBalanceValue","addBalanceValue","A_PRECISION","_getAPrecise","blockTimestamp","_distance","_getD","xp","nCoins","_sumOf","Dprev","D","Ann","D_P","j","_getY","inBalance","normalizedBalances","c","_getYD","A","StablePool","_A","currentWithdrawFee","StableSwap","calculateSwap","outBalance","_fee","_amountOutInclFee","feeAdjustedAmount","_calculateRemoveLiquidity","D0","D1","newY","reducedXP","_feePerToken","expectedDx","dy","_calculateRemoveLiquidityOneToken","_calculateTokenAmount","setBlockTimestamp","toNumber","virtualIn","feeToSet","SwapData","poolRef","pool","tokenOutAmount","tokenInAmount","calculateSwapGivenOutAmendingPool","refPool","assign","calculateSwapGivenInAmendingPool","singleDataFromPool","includes","data","fetchPoolPrice","setPool","PairData","dataFromPool","index0","index1","dataFromPools","pools","k","toSwapDataFrom","toSwapDataTo","toSwapArrayFrom","swaps","currentIn","toSwapArrayTo","currentOut","SQRT2x100","ONE_E18","sqrrt","getTotalValue","pair","payoutToken","weightPayoutToken","weightOther","valuation","RESOLUTION","resPrec","decode112with18","ONE_E16","ONE_E9","payoutFor","bondPrice","debtRatio","currentDebt","controlVariable","bondPriceUsingDebtRatio","SwapType","Route","input","output","currentInput","midPrice","inputOutputComparator","wrappedAmount","Swap","tradeType","_isValid","EXACT_INPUT","poolDictCopy","swapData","isValid","swapAmounts","EXACT_OUTPUT","executionPrice","exactIn","exactOut","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","PriceRoutes","swapRoutes","swapType","sort","filter","validateRouteForExactOut","refs","sd","Set","size","SwapRoute","swapDataAggregated","currentSwap","relevantOut","identifier","p","otherRoute","cleanRoutes","routeIds","routes","RouteProvider","getRouteIteration","maxHops","lastPool","currentpools","originalCurrencyIn","bestRoutes","relevantPairs","inIs0","tokenOutNew","getRoutes","currencyIn","currencyOut","toHex","toHexString","SwapRouter","swapCallParameters","trade","options","etherIn","etherOut","ttl","methodName","to","recipient","allowedSlippage","args","deadline","Math","floor","Date","getTime","multiSwap","useFeeOnTransfer","Boolean","feeOnTransfer","previousInvariant","currentInvariant","protocolSwapFeePercentage","exponent","tokenAccruedFees","_invariant","terms","arg","logBase","reservesOther","concat","ioComp"],"mappings":"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CjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,IAAM1S,YAAUC,KAAK,wCACjCyS,GAAY,KAAO1S,YAAUC,KAAK,wCAClCyS,GAAY,KAAO1S,YAAUC,KAAK,wCAClCyS,GAAY,KAAO1S,YAAUC,KAAK,wCAClCyS,GAAY,KAAO1S,YAAUC,KAAK,wCAClCyS,GAAY,KAAO1S,YAAUC,KAAK,wCAClCyS,GAAY,KAAO1S,YAAUC,KAAK,wCAClCyS,GAAY,KAAO1S,YAAUC,KAAK,wCAClCyS,GAAY,KAAO1S,YAAUC,KAAK,wCAClCyS,GAAY,KAAO1S,YAAUC,KAAK,wCAClCyS,GAAY,KAAO1S,YAAUC,KAAK,wCA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"}