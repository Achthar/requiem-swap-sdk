{"version":3,"file":"sdk.cjs.production.min.js","sources":["../src/constants.ts","../src/errors.ts","../src/helperUtils.ts","../src/entities/currency.ts","../src/entities/token.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/percent.ts","../src/entities/fractions/currencyAmount.ts","../src/entities/fractions/tokenAmount.ts","../src/entities/fractions/price.ts","../src/entities/calculators/LogExpMath.ts","../src/entities/calculators/FixedPoint.ts","../src/entities/calculators/WeightedMath.ts","../src/entities/calculators/WeightedPoolLib.ts","../src/entities/calculators/weightedPairCalc.ts","../src/entities/pools/pool.ts","../src/entities/calculators/weightedSwapStorage.ts","../src/entities/calculators/stableSwapStorage.ts","../src/entities/pools/weightedPair/amplifiedWeightedPair.ts","../src/entities/pools/weightedPool/weightedPool.ts","../src/entities/calculators/stableCalc.ts","../src/entities/pools/stable/stablePool.ts","../src/entities/pools/swapData.ts","../src/entities/pools/pairData.ts","../src/entities/bonds/bondCalculator.ts","../src/entities/bonds/fixedPoint.ts","../src/entities/bonds/bondDepository.ts","../src/entities/route.ts","../src/entities/swap.ts","../src/entities/swapRoute.ts","../src/routeProvider.ts","../src/swapRouter.ts"],"sourcesContent":["import { BigNumber } from 'ethers'\n\n// exports for external consumption\nexport type BigintIsh = BigNumber | bigint | string | number\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport const FACTORY_ADDRESS: { [chainId: number]: string } = {\n  56: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n  97: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n  80001: '0xf10Bd0dA1f0e69c3334D7F8116C9082746EBC1B4',\n  43113: '0xFb94c4CeA93f8369Fe18C3078060605eE2B14eC3',\n}\n\nexport const WEIGHTED_FACTORY_ADDRESS: { [chainId: number]: string } = {\n  43113: '0xacd3602152763C3AAFA705D8a90C36661ecD7d46',\n  42261: '0x0459e858F17ef5D927625f34602432f4fac6941e',\n  110001: '0xe092CB3124aF36a0B851839D8EC51CaaD9a3DCD0'\n}\n\n// export const INIT_CODE_HASH = '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5'\n\n\nexport const INIT_CODE_HASH: { [chainId: number]: string } = {\n  56: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',\n  97: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',\n  80001: '0xc2b3644608b464a0df0eb711ce9c6ce7535d1bd4d0154b8389738a3e7fbb1a61',\n  43113: '0x98fcd7ed545dc443aa0c7e57e5f54affba6cf755a7eadfd269143f9bf62024d8',\n}\n\nexport const INIT_CODE_HASH_WEIGHTED: { [chainId: number]: string } = {\n  43113: '0xbeec252b6527ff023d9f20fa336f9f131a002be662ce64ef7f9ed17b5ea8b591',\n  42261: '0x98fcd7ed545dc443aa0c7e57e5f54affba6cf755a7eadfd269143f9bf62024d8',\n  110001: '0x98fcd7ed545dc443aa0c7e57e5f54affba6cf755a7eadfd269143f9bf62024d8'\n}\n\nexport const STABLE_POOL_ADDRESS: { [chainId: number]: string } = {\n  43113: '0x0Be60C571BdA7841D8F6eE68afDBa648EC710fD7',\n  42261: '0x2a90276992ddC21C3585FE50f5B43D0Cf62aDe03',\n  110001: '0x211F00f4071A4af8f0cC289d9853d778047DB8Ba',\n}\n\nexport const STABLE_POOL_LP_ADDRESS: { [chainId: number]: string } = {\n  43113: '0x3372de341a07418765ae12f77aee9029eaa4442a',\n  42261: '0x9364E91ca784ca51f88dE2a76a35Ba2665bdad04',\n  110001: '0x029f9f8e2c27627341824120ee814F31a1551256'\n}\n\nexport const MINIMUM_LIQUIDITY = BigNumber.from(1000)\n\n// exports for internal consumption\nexport const ZERO = BigNumber.from(0)\nexport const ONE = BigNumber.from(1)\nexport const TWO = BigNumber.from(2)\nexport const THREE = BigNumber.from(3)\nexport const FIVE = BigNumber.from(5)\nexport const TEN = BigNumber.from(10)\nexport const TENK = BigNumber.from(10000)\nexport const _100 = BigNumber.from(100)\nexport const FEES_NUMERATOR = BigNumber.from(9975)\nexport const FEES_DENOMINATOR = BigNumber.from(10000)\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: BigNumber.from('0xff'),\n  [SolidityType.uint256]: BigNumber.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\nimport { BigNumber } from 'ethers'\n\nexport function validateSolidityTypeInstance(value: BigNumber, solidityType: SolidityType): void {\n  invariant(value.gte(ZERO), `${value} is not a ${solidityType}.`)\n  invariant(value.lte(SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): BigNumber {\n  return bigintIsh instanceof BigNumber\n    ? bigintIsh\n    : typeof bigintIsh === 'bigint'\n    ? BigNumber.from(bigintIsh.toString())\n    : BigNumber.from(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: BigNumber): BigNumber {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: BigNumber = ZERO\n  let x: BigNumber\n  if (y.gt(THREE)) {\n    z = y\n    x = y.div(TWO).add(ONE)\n    while (x.lt(z)) {\n      z = x\n      x = y.div(x).add( x).div(TWO)\n    }\n  } else if (!y.eq(ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n","/**\n * A currency is any fungible financial instrument on Ethereum, including Ether and all ERC20 tokens.\n *\n * The only instance of the base class `Currency` is Ether.\n */\nexport class Currency {\n  public readonly decimals: number\n  public readonly chainId: number\n  public readonly symbol?: string\n  public readonly name?: string\n\n  /**\n   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.ETHER`.\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  constructor(chainId: number, decimals: number, symbol?: string, name?: string) {\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n    this.chainId = chainId\n  }\n}\n\n\nexport enum ChainId {\n  BSC_MAINNET = 56,\n  BSC_TESTNET = 97,\n  AVAX_MAINNET = 43114,\n  AVAX_TESTNET = 43113,\n  ARBITRUM_MAINNET = 42161,\n  ARBITRUM_TETSNET_RINKEBY = 421611,\n  MATIC_MAINNET = 137,\n  MATIC_TESTNET = 80001,\n  OASIS_TESTNET = 42261,\n  OASIS_MAINNET = 42262,\n  QUARKCHAIN_DEV_S0 = 110001,\n}\n\nexport const NETWORK_CCY: { [chainId: number]: Currency } = {\n  [ChainId.BSC_MAINNET]: new Currency(ChainId.BSC_MAINNET, 18, 'BNB', 'BNB'),\n  [ChainId.BSC_TESTNET]: new Currency(ChainId.BSC_TESTNET, 18, 'BNB', 'BNB'),\n  [ChainId.ARBITRUM_MAINNET]: new Currency(ChainId.ARBITRUM_MAINNET, 18, 'ETH', 'ETH'),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Currency(ChainId.ARBITRUM_TETSNET_RINKEBY, 18, 'ETH', 'ETH'),\n  [ChainId.AVAX_MAINNET]: new Currency(ChainId.AVAX_MAINNET, 18, 'AVAX', 'AVAX'),\n  [ChainId.AVAX_TESTNET]: new Currency(ChainId.AVAX_TESTNET, 18, 'AVAX', 'AVAX'),\n  [ChainId.MATIC_MAINNET]: new Currency(ChainId.MATIC_MAINNET, 18, 'MATIC', 'MATIC'),\n  [ChainId.MATIC_TESTNET]: new Currency(ChainId.MATIC_TESTNET, 18, 'MATIC', 'MATIC'),\n  [ChainId.OASIS_MAINNET]: new Currency(ChainId.OASIS_MAINNET, 18, 'ROSE', 'ROSE'),\n  [ChainId.OASIS_TESTNET]: new Currency(ChainId.OASIS_TESTNET, 18, 'ROSE', 'ROSE'),\n  [ChainId.QUARKCHAIN_DEV_S0]: new Currency(ChainId.QUARKCHAIN_DEV_S0, 18, 'QKC', 'QKC')\n}\n","import invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from '../helperUtils'\nimport { Currency, ChainId } from './currency'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token extends Currency {\n  public readonly address: string\n  public readonly projectLink?: string\n\n  public constructor(\n    chainId: ChainId,\n    address: string,\n    decimals: number,\n    symbol?: string,\n    name?: string,\n    projectLink?: string\n  ) {\n    super(chainId, decimals, symbol, name)\n    this.address = validateAndParseAddress(address)\n    this.projectLink = projectLink\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Token): boolean {\n    // short circuit on reference equality\n    if (this === other) {\n      return true\n    }\n    return this.chainId === other.chainId && this.address === other.address\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n}\n\n/**\n * Compares two currencies for equality\n */\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB)\n  } else if (currencyA instanceof Token) {\n    return false\n  } else if (currencyB instanceof Token) {\n    return false\n  } else {\n    return currencyA === currencyB\n  }\n}\n\nexport const WETH = {\n  [ChainId.BSC_MAINNET]: new Token(\n    ChainId.BSC_MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.BSC_TESTNET]: new Token(\n    ChainId.BSC_TESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_MAINNET]: new Token(\n    ChainId.ARBITRUM_MAINNET,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped ETH',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Token(\n    ChainId.ARBITRUM_TETSNET_RINKEBY,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_MAINNET]: new Token(\n    ChainId.AVAX_MAINNET,\n    '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_TESTNET]: new Token(\n    ChainId.AVAX_TESTNET,\n    '0xd00ae08403B9bbb9124bB305C09058E32C39A48c',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_MAINNET]: new Token(\n    ChainId.MATIC_MAINNET,\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_TESTNET]: new Token(\n    ChainId.MATIC_TESTNET,\n    '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n\n}\n// this has not to be mixed up with the ERC20 token WETH on BSC or MATIC\n// these are the respective wrapped network tokens, e.g. WBNB for Binance\n// or WMATIC for Polygon\nexport const WRAPPED_NETWORK_TOKENS:{[chainId:number]:Token} = {\n  [ChainId.BSC_MAINNET]: new Token(\n    ChainId.BSC_MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.BSC_TESTNET]: new Token(\n    ChainId.BSC_TESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_MAINNET]: new Token(\n    ChainId.ARBITRUM_MAINNET,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped ETH',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Token(\n    ChainId.ARBITRUM_TETSNET_RINKEBY,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_MAINNET]: new Token(\n    ChainId.AVAX_MAINNET,\n    '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_TESTNET]: new Token(\n    ChainId.AVAX_TESTNET,\n    '0xd00ae08403B9bbb9124bB305C09058E32C39A48c',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_MAINNET]: new Token(\n    ChainId.MATIC_MAINNET,\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_TESTNET]: new Token(\n    ChainId.MATIC_TESTNET,\n    '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.OASIS_TESTNET]:\n  new Token( ChainId.OASIS_TESTNET,\n    '0x792296e2a15e6Ceb5f5039DecaE7A1f25b00B0B0',\n    18,\n    'wROSE',\n    'Wrapped ROSE',\n    'https://docs.oasis.dev/'\n  ),\n  [ChainId.OASIS_MAINNET]:\n  new Token( ChainId.OASIS_MAINNET,\n    '0xfb40cd35C0cF322fA3cfB8D67b533Bd9ad7df056',\n    18,\n    'wROSE',\n    'Wrapped ROSE',\n    'https://docs.oasis.dev/'\n  ),\n  [ChainId.QUARKCHAIN_DEV_S0]:\n  new Token( ChainId.OASIS_MAINNET,\n    '0x56fB4da0E246003DEc7dD108e47f5d8e8F4cC493',\n    18,\n    'wQKC',\n    'Wrapped QKC',\n    'https://docs.oasis.dev/'\n  ),\n\n}\n\n\n\nexport const STABLECOINS: { [chainId: number]: Token[] } = {\n  43113: [\n    new Token(ChainId.AVAX_TESTNET, '0xca9ec7085ed564154a9233e1e7d8fef460438eea', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.AVAX_TESTNET, '0xffb3ed4960cac85372e6838fbc9ce47bcf2d073e', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.AVAX_TESTNET, '0xaea51e4fee50a980928b4353e852797b54deacd8', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.AVAX_TESTNET, '0xccf7ed44c5a0f3cb5c9a9b9f765f8d836fb93ba1', 18, 'TUSD', 'True USD'),\n  ],\n  42261 :[\n    new Token(ChainId.OASIS_TESTNET, '0x9aEeeD65aE87e3b28793aefAeED59c3f10ef956b', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.OASIS_TESTNET, '0xfA0D8065755Fb3b6520149e86Ac5A3Dc3ee5Dc92', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.OASIS_TESTNET, '0xf10Bd0dA1f0e69c3334D7F8116C9082746EBC1B4', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.OASIS_TESTNET, '0x4e8848da06E40E866b82f6b52417494936c9509b', 18, 'TUSD', 'True USD'),\n  ],\n  110001 :[\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0xE59c1Ddf4fAAC4Fa7C8c93d9392d4bBa55383268', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0x1a69a6e206c680A8559c59b951527437CBCe6Ed7', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0x51b90a5Bc99B7c76EDf3863E1d61ca6197a6e542', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.QUARKCHAIN_DEV_S0, '0xD71C821a373E16D607277DB6C1356c1209C7d866', 18, 'TUSD', 'True USD'),\n  ],\n  0: [// dummy value\n    new Token(-1, '0xCa9eC7085Ed564154a9233e1e7D8fEF460438EEA', 6, 'USDC', 'USD Coin')]\n}\n\n\nexport const STABLES_INDEX_MAP: { [chainId: number]: { [index: number]: Token } } = {\n  43113: {\n    0: STABLECOINS[43113][0],\n    1: STABLECOINS[43113][1],\n    2: STABLECOINS[43113][2],\n    3: STABLECOINS[43113][3]\n  },\n  42261: {\n    0: STABLECOINS[42261][0],\n    1: STABLECOINS[42261][1],\n    2: STABLECOINS[42261][2],\n    3: STABLECOINS[42261][3]\n  },\n  110001: {\n    0: STABLECOINS[110001][0],\n    1: STABLECOINS[110001][1],\n    2: STABLECOINS[110001][2],\n    3: STABLECOINS[110001][3]\n  }\n}\n\nexport const STABLES_LP_TOKEN: { [chainId: number]: { [index: number]: Token } } = {\n  43113: {\n    0: STABLECOINS[43113][0],\n    1: STABLECOINS[43113][1],\n    2: STABLECOINS[43113][2],\n    3: STABLECOINS[43113][3]\n  }\n}","import invariant from 'tiny-invariant'\nimport _Decimal from 'decimal.js-light'\nimport _Big, { RoundingMode } from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh } from '../../constants'\nimport { ONE } from '../../constants'\nimport { parseBigintIsh } from '../../helperUtils'\nimport { BigNumber } from 'ethers'\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp\n}\n\nexport class Fraction {\n  public readonly numerator: BigNumber\n  public readonly denominator: BigNumber\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = ONE) {\n    this.numerator = parseBigintIsh(numerator)\n    this.denominator = parseBigintIsh(denominator)\n  }\n\n  // performs floor division\n  public get quotient(): BigNumber {\n    return this.numerator.div(this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(this.numerator.mod(this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (this.denominator.eq(otherParsed.denominator)) {\n      return new Fraction(this.numerator.add(otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator).add(\n        otherParsed.numerator.mul(this.denominator)\n      ),\n      this.denominator.mul(otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (this.denominator.eq(otherParsed.denominator)) {\n      return new Fraction(this.numerator.sub(otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator).sub(\n       otherParsed.numerator.mul(this.denominator)\n      ),\n      this.denominator.mul(otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return this.numerator.mul(otherParsed.denominator).lt(\n      otherParsed.numerator.mul(this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return this.numerator.mul(otherParsed.denominator).eq(\n      otherParsed.numerator.mul(this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return this.numerator.mul(otherParsed.denominator).gt(otherParsed.numerator.mul(this.denominator))\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n     this.numerator.mul(otherParsed.numerator),\n      this.denominator.mul(otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator),\n      this.denominator.mul(otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n}\n","import { _100 } from '../../constants'\nimport { Fraction, Rounding } from './fraction'\n\nconst _100_PERCENT = new Fraction(_100)\n\nexport class Percent extends Fraction {\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { currencyEquals } from '../token'\nimport { Currency, ChainId, NETWORK_CCY } from '../currency'\nimport invariant from 'tiny-invariant'\nimport _Big from 'big.js'\nimport toFormat from 'toformat'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { BigintIsh, TEN, SolidityType } from '../../constants'\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../helperUtils'\nimport { Fraction, Rounding } from './fraction'\n\nconst Big = toFormat(_Big)\n\nexport class CurrencyAmount extends Fraction {\n  public readonly currency: Currency\n\n  /**\n   * Helper that calls the constructor with the more flexible network currency\n   * dependent on the selected chainId\n   * @param amount ether amount in wei\n   */\n  public static networkCCYAmount(chainId: ChainId, amount: BigintIsh): CurrencyAmount {\n    return new CurrencyAmount(NETWORK_CCY[chainId], amount)\n  }\n\n  // amount _must_ be raw, i.e. in the native representation\n  protected constructor(currency: Currency, amount: BigintIsh) {\n    const parsedAmount = parseBigintIsh(amount)\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\n\n    super(parsedAmount, TEN.pow(currency.decimals))\n    this.currency = currency\n  }\n\n  public get raw(): BigNumber {\n    return this.numerator\n  }\n\n  public add(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, this.raw.add(other.raw))\n  }\n\n  public subtract(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, this.raw.sub(other.raw))\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\n  }\n\n  public toBigNumber(): BigNumber { return BigNumber.from(this.numerator.toString()) }\n}\n","import { CurrencyAmount } from './currencyAmount'\nimport { Token } from '../token'\nimport invariant from 'tiny-invariant'\nimport { BigintIsh } from '../../constants'\n\n\n// minimal interface so the input output comparator may be shared across types\nexport interface InputOutput {\n  readonly inputAmount: CurrencyAmount\n  readonly outputAmount: CurrencyAmount\n}\n\nexport class TokenAmount extends CurrencyAmount {\n  public readonly token: Token\n\n  // amount _must_ be raw, i.e. in the native representation\n  public constructor(token: Token, amount: BigintIsh) {\n    super(token, amount)\n    this.token = token\n  }\n\n  public add(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, this.raw.add(other.raw))\n  }\n\n  public subtract(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, this.raw.sub(other.raw))\n  }\n}\n","import { Token } from '../token'\nimport { TokenAmount } from './tokenAmount'\nimport { currencyEquals } from '../token'\nimport invariant from 'tiny-invariant'\n\nimport { BigintIsh, TEN } from '../../constants'\nimport { Currency } from '../currency'\n\nimport { Fraction, Rounding } from './fraction'\nimport { CurrencyAmount } from './currencyAmount'\n\nimport { Pool } from '../pools/pool'\nimport { Route } from '../route'\n\nexport class Price extends Fraction {\n  public readonly baseCurrency: Currency // input i.e. denominator\n  public readonly quoteCurrency: Currency // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n\n  // upgraded version to include StablePairWrappers in a Route\n  // as well as weighted pairs\n  public static fromRoute(route: Route, poolDict: { [id: string]: Pool }): Price {\n    const prices: Price[] = []\n    // console.log(\"=========PATH\", route.path.map(x=>x.symbol))\n    // console.log(\"=========PATH PAIRs\", route.pairData.map(x=>[x.token0.symbol, x.token1.symbol]))\n    for (const [i, pool] of route.pairData.entries()) {\n      const price = pool.poolPrice(route.path[i], route.path[i + 1], poolDict)\n      prices.push(price)\n    }\n    // console.log(\"=========PRICE\", prices.map(p=>[p.baseCurrency.symbol, p.quoteCurrency.symbol]))\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n  }\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  public constructor(baseCurrency: Currency, quoteCurrency: Currency, denominator: BigintIsh, numerator: BigintIsh) {\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      TEN.pow(baseCurrency.decimals),\n      TEN.pow(quoteCurrency.decimals)\n    )\n  }\n\n  public get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n\n  public get adjusted(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public invert(): Price {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  public multiply(other: Price): Price {\n    invariant(currencyEquals(this.quoteCurrency, other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  // performs floor division on overflow\n  public quote(chainId: number, currencyAmount: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(currencyAmount.currency, this.baseCurrency), 'TOKEN')\n    if (this.quoteCurrency instanceof Token) {\n      return new TokenAmount(this.quoteCurrency, super.multiply(currencyAmount.raw).quotient)\n    }\n    return CurrencyAmount.networkCCYAmount(chainId, super.multiply(currencyAmount.raw).quotient)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the “Software”), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport { BigNumber } from '@ethersproject/bignumber'\n// import { ethers } from 'ethers'\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\n\n// All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n// two numbers, and multiply by ONE when dividing them.\nexport const ZERO = BigNumber.from(0)\n// All arguments and return values are 18 decimal fixed point numbers.\nexport const ONE_18 = BigNumber.from('1000000000000000000');\n\n// Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n// case of ln36, 36 decimals.\nconst ONE_20 = BigNumber.from('100000000000000000000');\nconst ONE_36 = BigNumber.from('1000000000000000000000000000000000000');\n\n// The domain of natural exponentiation is bound by the word size and number of decimals used.\n//\n// Because internally the result will be stored using 20 decimals, the largest possible result is\n// (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n// The smallest possible result is 10^(-18), which makes largest negative argument\n// ln(10^(-18)) = -41.446531673892822312.\n// We use 130.0 and -41.0 to have some safety margin.\n// const MAX_NATURAL_EXPONENT = BigNumber.from('130000000000000000000');\n// const MIN_NATURAL_EXPONENT = BigNumber.from(-'41000000000000000000');\n\n// Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n// 256 bit integer.\nconst LN_36_LOWER_BOUND = ONE_18.sub(BigNumber.from('100000000000000000'));\nconst LN_36_UPPER_BOUND = ONE_18.add(BigNumber.from('100000000000000000'));\n\n// const MILD_EXPONENT_BOUND = ethers.constants.MaxUint256.div(ONE_20);\n\n// 18 decimal constants\nconst x0 = BigNumber.from('128000000000000000000'); // 2ˆ7\nconst a0 = BigNumber.from('38877084059945950922200000000000000000000000000000000000'); // eˆ(x0) (no decimals)\nconst x1 = BigNumber.from('64000000000000000000'); // 2ˆ6\nconst a1 = BigNumber.from('6235149080811616882910000000'); // eˆ(x1) (no decimals)\n\n// 20 decimal constants\nconst x2 = BigNumber.from('3200000000000000000000'); // 2ˆ5\nconst a2 = BigNumber.from('7896296018268069516100000000000000'); // eˆ(x2)\nconst x3 = BigNumber.from('1600000000000000000000'); // 2ˆ4\nconst a3 = BigNumber.from('888611052050787263676000000'); // eˆ(x3)\nconst x4 = BigNumber.from('800000000000000000000'); // 2ˆ3\nconst a4 = BigNumber.from('298095798704172827474000'); // eˆ(x4)\nconst x5 = BigNumber.from('400000000000000000000'); // 2ˆ2\nconst a5 = BigNumber.from('5459815003314423907810'); // eˆ(x5)\nconst x6 = BigNumber.from('200000000000000000000'); // 2ˆ1\nconst a6 = BigNumber.from('738905609893065022723'); // eˆ(x6)\nconst x7 = BigNumber.from('100000000000000000000'); // 2ˆ0\nconst a7 = BigNumber.from('271828182845904523536'); // eˆ(x7)\nconst x8 = BigNumber.from('50000000000000000000'); // 2ˆ-1\nconst a8 = BigNumber.from('164872127070012814685'); // eˆ(x8)\nconst x9 = BigNumber.from('25000000000000000000'); // 2ˆ-2\nconst a9 = BigNumber.from('128402541668774148407'); // eˆ(x9)\nconst x10 = BigNumber.from('12500000000000000000'); // 2ˆ-3\nconst a10 = BigNumber.from('113314845306682631683'); // eˆ(x10)\nconst x11 = BigNumber.from('6250000000000000000'); // 2ˆ-4\nconst a11 = BigNumber.from('106449445891785942956'); // eˆ(x11)\n\n/**\n * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n *\n * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n */\nexport function pow(x: BigNumber, y: BigNumber): BigNumber {\n    if (y.eq(0)) {\n        // We solve the 0^0 indetermination by making it equal one.\n        return ONE_18;\n    }\n\n    if (x.eq(0)) {\n        return ZERO;\n    }\n    let x_int256 = x;\n    let y_int256 = y\n    let logx_times_y\n    if (LN_36_LOWER_BOUND.lt(x_int256) && x_int256.lt(LN_36_UPPER_BOUND)) {\n        let ln_36_x = _ln_36(x_int256);\n\n        // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n        // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n        // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n        // (downscaled) last 18 decimals.\n        logx_times_y = (ln_36_x.div(ONE_18).mul(y_int256)).add(ln_36_x.mod(ONE_18).mul(y_int256).div(ONE_18))\n    } else {\n        logx_times_y = _ln(x_int256).mul(y_int256);\n    }\n    logx_times_y = logx_times_y.div(ONE_18);\n\n\n    return exp(logx_times_y); // that +1 differs from the original variant\n}\n\n/**\n * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n *\n * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n */\nexport function exp(x: BigNumber): BigNumber {\n\n    if (x.lt(ZERO)) {\n        // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n        // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n        // Fixed point division requires multiplying by ONE_18.\n        return (ONE_18.mul(ONE_18)).div(exp(x.mul(-1)));\n    }\n    // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n    // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n    // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n    // decomposition.\n    // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n    // decomposition, which will be lower than the smallest x_n.\n    // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n    // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n    // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n    // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n    // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n    // decomposition.\n\n    // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n    // it and compute the accumulated product.\n\n    let firstAN;\n    if (x.gte(x0)) {\n        x = x.sub(x0);\n        firstAN = a0;\n    } else if (x.gte(x1)) {\n        x = x.sub(x1);\n        firstAN = a1;\n    } else {\n        firstAN = BigNumber.from(1); // One with no decimal places\n    }\n\n    // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n    // smaller terms.\n    x = x.mul(100);\n\n    // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n    // one. Recall that fixed point multiplication requires dividing by ONE_20.\n    let product = ONE_20;\n\n    if (x.gte(x2)) {\n        x = x.sub(x2);\n        product = product.mul(a2).div(ONE_20);\n    }\n    if (x.gte(x3)) {\n        x = x.sub(x3);\n        product = product.mul(a3).div(ONE_20);\n    }\n    if (x.gte(x4)) {\n        x = x.sub(x4);\n        product = product.mul(a4).div(ONE_20);\n    }\n    if (x.gte(x5)) {\n        x = x.sub(x5);\n        product = product.mul(a5).div(ONE_20);\n    }\n    if (x.gte(x6)) {\n        x = x.sub(x6);\n        product = product.mul(a6).div(ONE_20);\n    }\n    if (x.gte(x7)) {\n        x = x.sub(x7);\n        product = product.mul(a7).div(ONE_20);\n    }\n    if (x.gte(x8)) {\n        x = x.sub(x8);\n        product = product.mul(a8).div(ONE_20);\n    }\n    if (x.gte(x9)) {\n        x = x.sub(x9);\n        product = product.mul(a9).div(ONE_20);\n    }\n\n    // x10 and x11 are unnecessary here since we have high enough precision already.\n\n    // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n    // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n    let seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n    let term; // Each term in the sum, where the nth term is (x^n / n!).\n\n    // The first term is simply x.\n    term = x;\n    seriesSum = seriesSum.add(term);\n\n    // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n    // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n    term = term.mul(x).div(ONE_20).div(2);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(3);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(4);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(5);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(6);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(7);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(8);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(9);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(10);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(11);\n    seriesSum = seriesSum.add(term);\n\n    term = term.mul(x).div(ONE_20).div(12);\n    seriesSum = seriesSum.add(term);\n\n    // 12 Taylor terms are sufficient for 18 decimal precision.\n\n    // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n    // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n    // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n    // and then drop two digits to return an 18 decimal value.\n\n    return ((product.mul(seriesSum)).div(ONE_20).mul(firstAN)).div(100);\n}\n\n/**\n * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n */\nexport function log(arg: BigNumber, base: BigNumber): BigNumber {\n    // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n    // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n    // upscaling.\n\n    let logBase;\n    if (LN_36_LOWER_BOUND.lt(base) && base.lt(LN_36_UPPER_BOUND)) {\n        logBase = _ln_36(base);\n    } else {\n        logBase = _ln(base).mul(ONE_18);\n    }\n\n    let logArg;\n    if (LN_36_LOWER_BOUND.lt(arg) && arg.lt(LN_36_UPPER_BOUND)) {\n        logArg = _ln_36(arg);\n    } else {\n        logArg = _ln(arg).mul(ONE_18);\n    }\n\n    // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n    return logArg.mul(ONE_18).div(logBase);\n}\n\n/**\n * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n */\nexport function ln(a: BigNumber): BigNumber {\n    // The real natural logarithm is not defined for negative numbers or zero.\n\n    if (LN_36_LOWER_BOUND.lt(a) && a.lt(LN_36_UPPER_BOUND)) {\n        return _ln_36(a).div(ONE_18);\n    } else {\n        return _ln(a);\n    }\n}\n\n/**\n * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n */\nexport function _ln(a: BigNumber): BigNumber {\n    if (a.lt(ONE_18)) {\n        // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n        // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n        // Fixed point division requires multiplying by ONE_18.\n        return (_ln((ONE_18.mul(ONE_18)).div(a))).mul(-1);\n    }\n\n    // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n    // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n    // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n    // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n    // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n    // decomposition, which will be lower than the smallest a_n.\n    // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n    // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n    // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n    // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n    // ONE_18 to convert them to fixed point.\n    // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n    // by it and compute the accumulated sum.\n\n    let sum = ZERO;\n    if (a.gte(a0.mul(ONE_18))) {\n        a = a.div(a0); // Integer, not fixed point division\n        sum = sum.add(x0);\n    }\n\n    if (a.gte(a1.mul(ONE_18))) {\n        a = a.div(a1); // Integer, not fixed point division\n        sum = sum.add(x1);\n    }\n\n    // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n    sum = sum.mul(100);\n    a = a.mul(100);\n\n    // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n    if (a.gte(a2)) {\n        a = a.mul(ONE_20).div(a2);\n        sum = sum.add(x2);\n    }\n\n    if (a.gte(a3)) {\n        a = a.mul(ONE_20).div(a3);\n        sum = sum.add(x3);\n    }\n\n    if (a.gte(a4)) {\n        a = a.mul(ONE_20).div(a4);\n        sum = sum.add(x4);\n    }\n\n    if (a.gte(a5)) {\n        a = a.mul(ONE_20).div(a5);\n        sum = sum.add(x5);\n    }\n\n    if (a.gte(a6)) {\n        a = a.mul(ONE_20).div(a6);\n        sum = sum.add(x6);\n    }\n\n    if (a.gte(a7)) {\n        a = a.mul(ONE_20).div(a7);\n        sum = sum.add(x7);\n    }\n\n    if (a.gte(a8)) {\n        a = a.mul(ONE_20).div(a8);\n        sum = sum.add(x8);\n    }\n\n    if (a.gte(a9)) {\n        a = a.mul(ONE_20).div(a9);\n        sum = sum.add(x9);\n    }\n\n    if (a.gte(a10)) {\n        a = a.mul(ONE_20).div(a10);\n        sum = sum.add(x10);\n    }\n\n    if (a.gte(a11)) {\n        a = a.mul(ONE_20).div(a11);\n        sum = sum.add(x11);\n    }\n\n    // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n    // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n    // Let z = (a - 1) / (a + 1).\n    // ln(a) =2.mul((z + z^.div( 3) + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n    // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n    // division by ONE_20.\n    let z = ((a.sub(ONE_20)).mul(ONE_20)).div(a.add(ONE_20));\n    let z_squared = (z.mul(z)).div(ONE_20);\n\n    // num is the numerator of the series: the z^(2 * n + 1) term\n    let num = z;\n\n    // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n    let seriesSum = num;\n\n    // In each step, the numerator is multiplied by z^2\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(3));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(5));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(7));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(9));\n\n    num = num.mul(z_squared).div(ONE_20);\n    seriesSum = seriesSum.add(num.div(11));\n\n    // 6 Taylor terms are sufficient for 36 decimal precision.\n\n    // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n    seriesSum = seriesSum.mul(2);\n\n    // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n    // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n    // value.\n\n    return sum.add(seriesSum).div(100);\n}\n\n/**\n * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n * for x close to one.\n *\n * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n */\nexport function _ln_36(x: BigNumber): BigNumber {\n    // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n    // worthwhile.\n\n    // First, we transform x to a 36 digit fixed point value.\n    x = x.mul(ONE_18);\n\n    // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n    // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n    // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n    // division by ONE_36.\n    let z = x.sub(ONE_36).mul(ONE_36).div(x.add(ONE_36));\n    let z_squared = z.mul(z).div(ONE_36);\n\n    // num is the numerator of the series: the z^(2 * n + 1) term\n    let num = z;\n\n    // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n    let seriesSum = num;\n\n    // In each step, the numerator is multiplied by z^2\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(3));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(5));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(7));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(9));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(11));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(13));\n\n    num = num.mul(z_squared).div(ONE_36);\n    seriesSum = seriesSum.add(num.div(15));\n\n    // 8 Taylor terms are sufficient for 36 decimal precision.\n\n    // All that remains is multiplying by 2 (non fixed point).\n    return seriesSum.mul(2);\n}\n\n","\n// import invariant from 'tiny-invariant'\nimport { BigNumber } from '@ethersproject/bignumber'\n\n\nimport { pow, ZERO, ONE_18 } from \"./LogExpMath\";\n\nexport const ONE = ONE_18\n/* solhint-disable private-vars-leading-underscore */\n\n// const ONE = BigNumber.from(1e18); // 18 decimal places\nconst MAX_POW_RELATIVE_ERROR = BigNumber.from(10000); // 10^(-14)\n\n// Minimum base for the power function when the exponent is 'free' (larger than ONE).\nexport const MIN_POW_BASE_FREE_EXPONENT = BigNumber.from('700000000000000000');\n\n\nexport function mulDown(a: BigNumber, b: BigNumber): BigNumber {\n    const product = a.mul(b);\n\n    return product.div(ONE);\n}\n\nexport function mulUp(a: BigNumber, b: BigNumber): BigNumber {\n    const product = a.mul(b);\n\n    if (product.eq(0)) {\n        return BigNumber.from(0);\n    } else {\n        // The traditional divUp formula is:\n        // divUp(x, y) := (x + y - 1) / y\n        // To avoid intermediate overflow in the addition, we distribute the division and get:\n        // divUp(x, y) := (x - 1) / y + 1\n        // Note that this requires x != 0, which we already tested for.\n\n        return (product.sub(1).div(ONE)).add(1);\n    }\n}\n\nexport function divDown(a: BigNumber, b: BigNumber): BigNumber {\n\n    if (a.eq(ZERO)) {\n        return ZERO;\n    } else {\n        let aInflated = a.mul(ONE);\n        return aInflated.div(b);\n    }\n}\n\nexport function divUp(a: BigNumber, b: BigNumber): BigNumber {\n\n    if (a.eq(ZERO)) {\n        return ZERO;\n    } else {\n        let aInflated = a.mul(ONE);\n\n        // The traditional divUp formula is:\n        // divUp(x, y) := (x + y - 1) / y\n        // To avoid intermediate overflow in the addition, we distribute the division and get:\n        // divUp(x, y) := (x - 1) / y + 1\n        // Note that this requires x != 0, which we already tested for.\n\n        return aInflated.sub(1).div(b).add(1);\n    }\n}\n\n/**\n * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n * the true value (that is, the error function expected - actual is always positive).\n */\nexport function powDown(x: BigNumber, y: BigNumber): BigNumber {\n    let raw = pow(x, y);\n    let maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR).add(1);\n\n    if (raw.lt(maxError)) {\n        return ZERO;\n    } else {\n        return raw.sub(maxError);\n    }\n}\n\n/**\n * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n * the true value (that is, the error function expected - actual is always negative).\n */\nexport function powUp(x: BigNumber, y: BigNumber): BigNumber {\n    const raw = pow(x, y);\n    const maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR).add(1);\n\n    return raw.add(maxError);\n}\n\n/**\n * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\n *\n * Useful when computing the complement for values with some level of relative error, as it strips this error and\n * prevents intermediate negative values.\n */\nexport function complement(x: BigNumber): BigNumber {\n    return x.lt(ONE) ? ONE.sub(x) : ZERO;\n}\n\n\n/**\n * @dev Returns the largest of two numbers of 256 bits.\n */\nexport function max(a: BigNumber, b: BigNumber): BigNumber {\n    return a.gte(b) ? a : b;\n}\n\n/**\n * @dev Returns the smallest of two numbers of 256 bits.\n */\nexport function min(a: BigNumber, b: BigNumber): BigNumber {\n    return a.lt(b) ? a : b;\n}\n\n","\nimport { BigNumber } from '@ethersproject/bignumber'\nimport invariant from 'tiny-invariant'\nimport { mulDown, powUp, powDown, divUp, divDown, complement, ONE, mulUp, max, MIN_POW_BASE_FREE_EXPONENT } from './FixedPoint'\nimport { ZERO } from './LogExpMath';\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\n// should be fixed.\n// solhint-disable private-vars-leading-underscore\n\n\n\n// A minimum normalized weight imposes a maximum weight ratio. We need this due to limitations in the\n// implementation of the power function, as these ratios are often exponents.\n// const _MIN_WEIGHT = BigNumber.from(0.01e18);\n// Having a minimum normalized weight imposes a limit on the maximum number of tokens;\n// i.e., the largest possible pool is one where all tokens have exactly the minimum weight.\n// const _MAX_WEIGHTED_TOKENS = BigNumber.from(100);\n\n// Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\n// ratio).\n\n// Swap limits: amounts swapped may not be larger than this percentage of total balance.\nconst _MAX_IN_RATIO = BigNumber.from('300000000000000000'); //0.3e18\nconst _MAX_OUT_RATIO = BigNumber.from('300000000000000000'); //0.3e18\n\n// Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\nconst _MAX_INVARIANT_RATIO = BigNumber.from('3000000000000000000'); //3e18\n// Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\nconst _MIN_INVARIANT_RATIO = BigNumber.from('700000000000000000'); //0.7e18\n\n// About swap fees on joins and exits:\n// Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\n// equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\n// swap fees, it follows that (some) joins and exits should as well.\n// On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\n// is the one to which swap fees are applied.\n\n// Invariant is used to collect protocol swap fees by comparing its value between two times.\n// So we can round always to the same direction. It is also used to initiate the BPT amount\n// and, because there is a minimum BPT, we round down the invariant.\nexport function _calculateInvariant(normalizedWeights: BigNumber[], balances: BigNumber[]): BigNumber {\n    /**********************************************************************************************\n    // invariant               _____                                                             //\n    // wi = weight index i      | |      wi                                                      //\n    // bi = balance index i     | |  bi ^   = i                                                  //\n    // i = invariant                                                                             //\n    **********************************************************************************************/\n\n    let _invariant = ONE;\n    for (let i = 0; i < normalizedWeights.length; i++) {\n        _invariant = mulDown(_invariant, powUp(balances[i], normalizedWeights[i]));\n    }\n\n    invariant(_invariant.gt(0), \"ZERO_INVARIANT\");\n\n    return _invariant\n}\n\n\n\n// Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\n// current balances and weights.\nexport function _calcOutGivenIn(\n    balanceIn: BigNumber,\n    weightIn: BigNumber,\n    balanceOut: BigNumber,\n    weightOut: BigNumber,\n    amountIn: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n    // outGivenIn                                                                                //\n    // aO = amountOut                                                                            //\n    // bO = balanceOut                                                                           //\n    // bI = balanceIn              /      /            bI             \\    (wI / wO) \\           //\n    // aI = amountIn    aO = bO * |  1 - | --------------------------  | ^            |          //\n    // wI = weightIn               \\      \\       ( bI + aI )         /              /           //\n    // wO = weightOut                                                                            //\n    **********************************************************************************************/\n\n    // Amount out, so we round down overall.\n\n    // The multiplication rounds down, and the subtrahend (power) rounds up (so the base rounds up too).\n    // Because bI / (bI + aI) <= 1, the exponent rounds down.\n\n    // Cannot exceed maximum in ratio\n    invariant(amountIn.lte(mulDown(balanceIn, _MAX_IN_RATIO)), \"MAX_IN_RATIO\");\n\n    const denominator = balanceIn.add(amountIn);\n    const base = divUp(balanceIn, denominator);\n    const exponent = divDown(weightIn, weightOut);\n    const power = powUp(base, exponent);\n\n    return mulDown(balanceOut, complement(power));\n}\n\n// Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\n// current balances and weights.\nexport function _calcInGivenOut(\n    balanceIn: BigNumber,\n    weightIn: BigNumber,\n    balanceOut: BigNumber,\n    weightOut: BigNumber,\n    amountOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n    // inGivenOut                                                                                //\n    // aO = amountOut                                                                            //\n    // bO = balanceOut                                                                           //\n    // bI = balanceIn              /  /            bO             \\    (wO / wI)      \\          //\n    // aI = amountIn    aI = bI * |  | --------------------------  | ^            - 1  |         //\n    // wI = weightIn               \\  \\       ( bO - aO )         /                   /          //\n    // wO = weightOut                                                                            //\n    **********************************************************************************************/\n\n    // Amount in, so we round up overall.\n\n    // The multiplication rounds up, and the power rounds up (so the base rounds up too).\n    // Because b0 / (b0 - a0) >= 1, the exponent rounds up.\n\n    // Cannot exceed maximum out ratio\n    invariant(amountOut.lte(mulDown(balanceOut, _MAX_OUT_RATIO)), \"MAX_OUT_RATIO\");\n\n    const base = divUp(balanceOut, balanceOut.sub(amountOut));\n    const exponent = divUp(weightOut, weightIn);\n    const power = powUp(base, exponent);\n\n    // Because the base is larger than one (and the power rounds up), the power should always be larger than one, so\n    // the following subtraction should never revert.\n    const ratio = power.sub(ONE);\n\n    return mulUp(balanceIn, ratio);\n}\n\nexport function _calcLpOutGivenExactTokensIn(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsIn: BigNumber[],\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { lpOut: BigNumber, swapFees: BigNumber[] } {\n    // BPT out, so we round down overall.\n\n    let balanceRatiosWithFee = [];\n\n    let invariantRatioWithFees = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        balanceRatiosWithFee.push(divDown(balances[i].add(amountsIn[i]), balances[i]));\n        invariantRatioWithFees = invariantRatioWithFees.add(mulDown(balanceRatiosWithFee[i], normalizedWeights[i]));\n    }\n\n    const { invariantRatio, swapFees } = _computeJoinExactTokensInInvariantRatio(\n        balances,\n        normalizedWeights,\n        amountsIn,\n        balanceRatiosWithFee,\n        invariantRatioWithFees,\n        swapFeePercentage\n    );\n\n    const lpOut = invariantRatio.gt(ONE) ? mulDown(lpTotalSupply, invariantRatio.sub(ONE)) : ZERO;\n    return { lpOut, swapFees };\n}\n\n/**\n * @dev Intermediate function to avoid stack-too-deep \"\n */\nexport function _computeJoinExactTokensInInvariantRatio(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsIn: BigNumber[],\n    balanceRatiosWithFee: BigNumber[],\n    invariantRatioWithFees: BigNumber,\n    swapFeePercentage: BigNumber\n): { invariantRatio: BigNumber, swapFees: BigNumber[] } {\n    // Swap fees are charged on all tokens that are being added in a larger proportion than the overall invariant\n    // increase.\n    let swapFees = [];\n    let invariantRatio = ONE;\n\n    for (let i = 0; i < balances.length; i++) {\n        let amountInWithoutFee;\n\n        if (balanceRatiosWithFee[i].gt(invariantRatioWithFees)) {\n            const nonTaxableAmount = mulDown(balances[i], invariantRatioWithFees.sub(ONE));\n            const taxableAmount = amountsIn[i].sub(nonTaxableAmount);\n            const swapFee = mulUp(taxableAmount, swapFeePercentage);\n\n            amountInWithoutFee = nonTaxableAmount.add(taxableAmount.sub(swapFee));\n            swapFees[i] = swapFee;\n        } else {\n            amountInWithoutFee = amountsIn[i];\n        }\n\n        const balanceRatio = divDown(balances[i].add(amountInWithoutFee), balances[i]);\n\n        invariantRatio = mulDown(invariantRatio, powDown(balanceRatio, normalizedWeights[i]));\n    }\n\n    return { invariantRatio, swapFees }\n}\n\nexport function _calcTokenInGivenExactLpOut(\n    balance: BigNumber,\n    normalizedWeight: BigNumber,\n    lpAmountOut: BigNumber,\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { amountIn: BigNumber, swapFee: BigNumber } {\n    /******************************************************************************************\n    // tokenInForExactLpOut                                                                 //\n    // a = amountIn                                                                          //\n    // b = balance                      /  /    totalBPT + LpOut      \\    (1 / w)       \\  //\n    // LpOut = lpAmountOut   a = b * |  | --------------------------  | ^          - 1  |  //\n    // lp = totalBPT                   \\  \\       totalBPT            /                  /  //\n    // w = weight                                                                            //\n    ******************************************************************************************/\n\n    // Token in, so we round up overall.\n\n    // Calculate the factor by which the invariant will increase after minting BPTAmountOut\n    const invariantRatio = divUp(lpTotalSupply.add(lpAmountOut), lpTotalSupply);\n    invariant(invariantRatio.lte(_MAX_INVARIANT_RATIO), \"MAX_OUT_LP\");\n\n    // Calculate by how much the token balance has to increase to match the invariantRatio\n    const balanceRatio = powUp(invariantRatio, divUp(ONE, normalizedWeight));\n\n    const amountInWithoutFee = mulUp(balance, balanceRatio.sub(ONE));\n\n    // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\n    // accordingly.\n    const taxablePercentage = complement(normalizedWeight);\n    const taxableAmount = mulUp(amountInWithoutFee, taxablePercentage);\n    const nonTaxableAmount = amountInWithoutFee.sub(taxableAmount);\n\n    const taxableAmountPlusFees = divUp(taxableAmount, ONE.sub(swapFeePercentage));\n\n    return {\n        swapFee: taxableAmountPlusFees.sub(taxableAmount),\n        amountIn: nonTaxableAmount.add(taxableAmountPlusFees)\n    }\n}\n\nexport function _calcAllTokensInGivenExactLpOut(\n    balances: BigNumber[],\n    lpAmountOut: BigNumber,\n    totalBPT: BigNumber\n): BigNumber[] {\n    /************************************************************************************\n    // tokensInForExactLpOut                                                          //\n    // (per token)                                                                     //\n    // aI = amountIn                   /   LpOut   \\                                  //\n    // b = balance           aI = b * | ------------ |                                 //\n    // LpOut = lpAmountOut           \\  totalBPT  /                                  //\n    // lp = totalBPT                                                                  //\n    ************************************************************************************/\n\n    // Tokens in, so we round up overall.\n    const lpRatio = divUp(lpAmountOut, totalBPT);\n\n    let amountsIn = [];\n    for (let i = 0; i < balances.length; i++) {\n        amountsIn.push(mulUp(balances[i], lpRatio));\n    }\n\n    return amountsIn;\n}\n\nexport function _calcLpInGivenExactTokensOut(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsOut: BigNumber[],\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { lpIn: BigNumber, swapFees: BigNumber[] } {\n    // BPT in, so we round up overall.\n\n    let balanceRatiosWithoutFee = Array(balances.length);\n    let invariantRatioWithoutFees = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        balanceRatiosWithoutFee[i] = divUp(balances[i].sub(amountsOut[i]), balances[i]);\n        invariantRatioWithoutFees = invariantRatioWithoutFees.add(mulUp(balanceRatiosWithoutFee[i], normalizedWeights[i]));\n    }\n\n    const { invariantRatio, swapFees } = _computeExitExactTokensOutInvariantRatio(\n        balances,\n        normalizedWeights,\n        amountsOut,\n        balanceRatiosWithoutFee,\n        invariantRatioWithoutFees,\n        swapFeePercentage\n    );\n\n    const lpIn = mulUp(lpTotalSupply, complement(invariantRatio));\n    return { lpIn, swapFees };\n}\n\n/**\n * @dev Intermediate function to avoid stack-too-deep \"\n */\nexport function _computeExitExactTokensOutInvariantRatio(\n    balances: BigNumber[],\n    normalizedWeights: BigNumber[],\n    amountsOut: BigNumber[],\n    balanceRatiosWithoutFee: BigNumber[],\n    invariantRatioWithoutFees: BigNumber,\n    swapFeePercentage: BigNumber\n): { invariantRatio: BigNumber, swapFees: BigNumber[] } {\n    let swapFees = Array(balances.length);\n    let invariantRatio = ONE;\n\n    for (let i = 0; i < balances.length; i++) {\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n        // 'token out'. This results in slightly larger price impact.\n\n        let amountOutWithFee;\n        if (invariantRatioWithoutFees.gt(balanceRatiosWithoutFee[i])) {\n            const nonTaxableAmount = mulDown(balances[i], complement(invariantRatioWithoutFees));\n            const taxableAmount = amountsOut[i].sub(nonTaxableAmount);\n            const taxableAmountPlusFees = divUp(taxableAmount, ONE.sub(swapFeePercentage));\n\n            swapFees[i] = taxableAmountPlusFees.sub(taxableAmount);\n            amountOutWithFee = nonTaxableAmount.add(taxableAmountPlusFees);\n        } else {\n            amountOutWithFee = amountsOut[i];\n        }\n\n        const balanceRatio = divDown(balances[i].sub(amountOutWithFee), balances[i]);\n\n        invariantRatio = mulDown(invariantRatio, powDown(balanceRatio, normalizedWeights[i]));\n    }\n\n    return { invariantRatio, swapFees }\n}\n\nexport function _calcTokenOutGivenExactLpIn(\n    balance: BigNumber,\n    normalizedWeight: BigNumber,\n    lpAmountIn: BigNumber,\n    lpTotalSupply: BigNumber,\n    swapFeePercentage: BigNumber\n): { amountOut: BigNumber, swapFee: BigNumber } {\n    /*****************************************************************************************\n    // exactBPTInForTokenOut                                                                //\n    // a = amountOut                                                                        //\n    // b = balance                     /      /    totalBPT - lpIn       \\    (1 / w)  \\   //\n    // lpIn = lpAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\n    // lp = totalBPT                  \\      \\       totalBPT            /             /   //\n    // w = weight                                                                           //\n    *****************************************************************************************/\n\n    // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\n    // rounds up). Because (totalBPT - lpIn) / totalBPT <= 1, the exponent rounds down.\n\n    // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\n    const invariantRatio = divUp(lpTotalSupply.sub(lpAmountIn), lpTotalSupply);\n    invariant(invariantRatio >= _MIN_INVARIANT_RATIO, \"MIN_LP_IN\");\n\n    // Calculate by how much the token balance has to decrease to match invariantRatio\n    const balanceRatio = powUp(invariantRatio, divDown(ONE, normalizedWeight));\n\n    // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\n    const amountOutWithoutFee = mulDown(balance, complement(balanceRatio));\n\n    // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n    // in swap fees.\n    const taxablePercentage = complement(normalizedWeight);\n\n    // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n    // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n    const taxableAmount = mulUp(amountOutWithoutFee, taxablePercentage);\n    const nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n    const swapFee = mulUp(taxableAmount, swapFeePercentage)\n    return {\n        swapFee,\n        amountOut: nonTaxableAmount.add(taxableAmount.sub(swapFee))\n    }\n}\n\nexport function _calcTokensOutGivenExactLpIn(\n    balances: BigNumber[],\n    lpAmountIn: BigNumber,\n    totalBPT: BigNumber\n): BigNumber[] {\n    /**********************************************************************************************\n    // exactBPTInForTokensOut                                                                    //\n    // (per token)                                                                               //\n    // aO = amountOut                  /        lpIn         \\                                  //\n    // b = balance           a0 = b * | ---------------------  |                                 //\n    // lpIn = lpAmountIn             \\       totalBPT       /                                  //\n    // lp = totalBPT                                                                            //\n    **********************************************************************************************/\n\n    // Since we're computing an amount out, we round down overall. This means rounding down on both the\n    // multiplication and division.\n\n    const lpRatio = divDown(lpAmountIn, totalBPT);\n\n    let amountsOut = [];\n    for (let i = 0; i < balances.length; i++) {\n        amountsOut.push(mulDown(balances[i], lpRatio));\n    }\n\n    return amountsOut;\n}\n\nexport function _calcDueTokenProtocolSwapFeeAmount(\n    balance: BigNumber,\n    normalizedWeight: BigNumber,\n    previousInvariant: BigNumber,\n    currentInvariant: BigNumber,\n    protocolSwapFeePercentage: BigNumber\n): BigNumber {\n    /*********************************************************************************\n    /*  protocolSwapFeePercentage * balanceToken * ( 1 - (previousInvariant / currentInvariant) ^ (1 / weightToken))\n    *********************************************************************************/\n\n    if (currentInvariant.lte(previousInvariant)) {\n        // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\n        // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\n        return ZERO;\n    }\n\n    // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol\n    // fees to the Vault.\n\n    // Fee percentage and balance multiplications round down, while the subtrahend (power) rounds up (as does the\n    // base). Because previousInvariant / currentInvariant <= 1, the exponent rounds down.\n\n    let base = divUp(previousInvariant, currentInvariant);\n    const exponent = divDown(ONE, normalizedWeight);\n\n    // Because the exponent is larger than one, the base of the power function has a lower bound. We cap to this\n    // value to avoid numeric issues, which means in the extreme case (where the invariant growth is larger than\n    // 1 / min exponent) the Pool will pay less in protocol fees than it should.\n    base = max(base, MIN_POW_BASE_FREE_EXPONENT);\n\n    const power = powUp(base, exponent);\n\n    const tokenAccruedFees = mulDown(balance, complement(power));\n    return mulDown(tokenAccruedFees, protocolSwapFeePercentage);\n}\n\n","// SPDX-License-Identifier: MIT\n\nimport { WeightedSwapStorage } from \"./weightedSwapStorage\";\n\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { _calcAllTokensInGivenExactLpOut, _calcInGivenOut, _calcLpInGivenExactTokensOut, _calcLpOutGivenExactTokensIn, _calcOutGivenIn, _calcTokenOutGivenExactLpIn } from \"./WeightedMath\";\nimport { ONE_18, ZERO } from \"./LogExpMath\";\n\nconst FEE_DENOMINATOR = ONE_18\n\nexport function calculateRemoveLiquidityOneTokenExactIn(\n    self: WeightedSwapStorage,\n    outIndex: number,\n    lpAmount: BigNumber,\n    lpSupply:BigNumber,\n    tokenBalances: BigNumber[]\n): { amountOut: BigNumber, swapFee: BigNumber } {\n    return _calcTokenOutGivenExactLpIn(\n        tokenBalances[outIndex].mul(self.tokenMultipliers[outIndex]),\n        self.normalizedWeights[outIndex],\n        lpAmount,\n        lpSupply,\n        self.fee\n    );\n}\n\nexport function calculateRemoveLiquidityExactIn(\n    self: WeightedSwapStorage,\n    lpAmount: BigNumber,\n    lpSupply:BigNumber,\n     tokenBalances: BigNumber[]\n): BigNumber[] {\n\n    return _calcAllTokensInGivenExactLpOut(\n        _xp(tokenBalances, self.tokenMultipliers),\n        lpAmount,\n        lpSupply\n    );\n}\n\n/**\n * Estimate amount of LP token minted or burned at deposit or withdrawal\n */\nexport function calculateTokenAmount(\n    self: WeightedSwapStorage,\n    amounts: BigNumber[],\n    lpSupply:BigNumber,\n    deposit: boolean,\n    tokenBalances: BigNumber[]\n): BigNumber {\n    let lpTokenAmount = ZERO\n    if (deposit) {\n        const { lpOut } = _calcLpOutGivenExactTokensIn(\n            _xp(tokenBalances, self.tokenMultipliers),\n            self.normalizedWeights,\n            _xp(amounts, self.tokenMultipliers),\n            lpSupply,\n            self.fee\n        );\n        lpTokenAmount = lpOut\n    } else {\n        const { lpIn } = _calcLpInGivenExactTokensOut(\n            _xp(tokenBalances, self.tokenMultipliers),\n            self.normalizedWeights,\n            _xp(amounts, self.tokenMultipliers),\n            lpSupply,\n            self.fee\n        );\n        lpTokenAmount = lpIn\n    }\n\n    return lpTokenAmount\n}\n\nexport function calculateSwapGivenIn(self: WeightedSwapStorage, inIndex: number, outIndex: number, amountIn: BigNumber, tokenBalances: BigNumber[]): BigNumber {\n    // use in amount with fee alredy deducted\n    const amountInWithFee = amountIn.mul(self.tokenMultipliers[inIndex]).mul(FEE_DENOMINATOR.sub(self.fee));\n\n    // calculate out amount\n    let amountOut = _calcOutGivenIn(\n        tokenBalances[inIndex].mul(self.tokenMultipliers[inIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[inIndex],\n        tokenBalances[outIndex].mul(self.tokenMultipliers[outIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[outIndex],\n        amountInWithFee\n    );\n\n    // downscale out amount\n    return amountOut.div(FEE_DENOMINATOR).div(self.tokenMultipliers[outIndex]);\n\n}\n\n\nexport function calculateSwapGivenOut(self: WeightedSwapStorage, inIndex: number, outIndex: number, amountOut: BigNumber,tokenBalances: BigNumber[]): BigNumber {\n    // calculate in amount with upscaled balances\n    const amountIn = _calcInGivenOut(\n        tokenBalances[inIndex].mul(self.tokenMultipliers[inIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[inIndex],\n        tokenBalances[outIndex].mul(self.tokenMultipliers[outIndex]).mul(FEE_DENOMINATOR),\n        self.normalizedWeights[outIndex],\n        amountOut.mul(self.tokenMultipliers[outIndex]).mul(FEE_DENOMINATOR)\n    );\n    // adjust for fee and scale down - rounding up\n    return amountIn.div(FEE_DENOMINATOR.sub(self.fee)).div(self.tokenMultipliers[inIndex]).add(1);\n}\n\n\nexport function _xp(balances: BigNumber[], rates: BigNumber[]): BigNumber[] {\n    let result = []\n    for (let i = 0; i < balances.length; i++) {\n        result.push(rates[i].mul(balances[i]))\n    }\n    return result\n}","import invariant from 'tiny-invariant'\nimport { BigNumber } from '@ethersproject/bignumber'\n\nconst ZERO = BigNumber.from(0)\nconst ONE = BigNumber.from(1)\nconst TWO = BigNumber.from(2)\nconst TENK = BigNumber.from(10000)\nconst _256 = BigNumber.from('256')\nconst _128 = BigNumber.from('128')\nconst MIN_PRECISION = 32;\nconst MAX_PRECISION = 127;\n\nconst FIXED_1 = BigNumber.from('0x080000000000000000000000000000000')\nconst FIXED_2 = BigNumber.from('0x100000000000000000000000000000000')\nconst MAX_NUM = BigNumber.from('0x200000000000000000000000000000000')\n\nconst LN2_NUMERATOR = BigNumber.from('0x3f80fe03f80fe03f80fe03f80fe03f8')\nconst LN2_DENOMINATOR = BigNumber.from('0x5b9de1d10bf4103d647b0955897ba80')\n\nconst OPT_LOG_MAX_VAL = BigNumber.from('0x15bf0a8b1457695355fb8ac404e7a79e3')\nconst OPT_EXP_MAX_VAL = BigNumber.from('0x800000000000000000000000000000000')\n\n// const LAMBERT_CONV_RADIUS = BigNumber.from('0x002f16ac6c59de6f8d5d6f63c1482a7c86')\n// const LAMBERT_POS2_SAMPLE = BigNumber.from('0x0003060c183060c183060c183060c18306')\n// const LAMBERT_POS2_MAXVAL = BigNumber.from('0x01af16ac6c59de6f8d5d6f63c1482a7c80')\n// const LAMBERT_POS3_MAXVAL = BigNumber.from('0x6b22d43e72c326539cceeef8bb48f255ff')\n\n// const MAX_UNF_WEIGHT = BigNumber.from('0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9')\n\nconst maxExpArray = new Array<BigNumber>(128)\nmaxExpArray[32] = BigNumber.from('0x1c35fedd14ffffffffffffffffffffffff')\nmaxExpArray[33] = BigNumber.from('0x1b0ce43b323fffffffffffffffffffffff')\nmaxExpArray[34] = BigNumber.from('0x19f0028ec1ffffffffffffffffffffffff')\nmaxExpArray[35] = BigNumber.from('0x18ded91f0e7fffffffffffffffffffffff')\nmaxExpArray[36] = BigNumber.from('0x17d8ec7f0417ffffffffffffffffffffff')\nmaxExpArray[37] = BigNumber.from('0x16ddc6556cdbffffffffffffffffffffff')\nmaxExpArray[38] = BigNumber.from('0x15ecf52776a1ffffffffffffffffffffff')\nmaxExpArray[39] = BigNumber.from('0x15060c256cb2ffffffffffffffffffffff')\nmaxExpArray[40] = BigNumber.from('0x1428a2f98d72ffffffffffffffffffffff')\nmaxExpArray[41] = BigNumber.from('0x13545598e5c23fffffffffffffffffffff')\nmaxExpArray[42] = BigNumber.from('0x1288c4161ce1dfffffffffffffffffffff')\nmaxExpArray[43] = BigNumber.from('0x11c592761c666fffffffffffffffffffff')\nmaxExpArray[44] = BigNumber.from('0x110a688680a757ffffffffffffffffffff')\nmaxExpArray[45] = BigNumber.from('0x1056f1b5bedf77ffffffffffffffffffff')\nmaxExpArray[46] = BigNumber.from('0x0faadceceeff8bffffffffffffffffffff')\nmaxExpArray[47] = BigNumber.from('0x0f05dc6b27edadffffffffffffffffffff')\nmaxExpArray[48] = BigNumber.from('0x0e67a5a25da4107fffffffffffffffffff')\nmaxExpArray[49] = BigNumber.from('0x0dcff115b14eedffffffffffffffffffff')\nmaxExpArray[50] = BigNumber.from('0x0d3e7a392431239fffffffffffffffffff')\nmaxExpArray[51] = BigNumber.from('0x0cb2ff529eb71e4fffffffffffffffffff')\nmaxExpArray[52] = BigNumber.from('0x0c2d415c3db974afffffffffffffffffff')\nmaxExpArray[53] = BigNumber.from('0x0bad03e7d883f69bffffffffffffffffff')\nmaxExpArray[54] = BigNumber.from('0x0b320d03b2c343d5ffffffffffffffffff')\nmaxExpArray[55] = BigNumber.from('0x0abc25204e02828dffffffffffffffffff')\nmaxExpArray[56] = BigNumber.from('0x0a4b16f74ee4bb207fffffffffffffffff')\nmaxExpArray[57] = BigNumber.from('0x09deaf736ac1f569ffffffffffffffffff')\nmaxExpArray[58] = BigNumber.from('0x0976bd9952c7aa957fffffffffffffffff')\nmaxExpArray[59] = BigNumber.from('0x09131271922eaa606fffffffffffffffff')\nmaxExpArray[60] = BigNumber.from('0x08b380f3558668c46fffffffffffffffff')\nmaxExpArray[61] = BigNumber.from('0x0857ddf0117efa215bffffffffffffffff')\nmaxExpArray[62] = BigNumber.from('0x07ffffffffffffffffffffffffffffffff')\nmaxExpArray[63] = BigNumber.from('0x07abbf6f6abb9d087fffffffffffffffff')\nmaxExpArray[64] = BigNumber.from('0x075af62cbac95f7dfa7fffffffffffffff')\nmaxExpArray[65] = BigNumber.from('0x070d7fb7452e187ac13fffffffffffffff')\nmaxExpArray[66] = BigNumber.from('0x06c3390ecc8af379295fffffffffffffff')\nmaxExpArray[67] = BigNumber.from('0x067c00a3b07ffc01fd6fffffffffffffff')\nmaxExpArray[68] = BigNumber.from('0x0637b647c39cbb9d3d27ffffffffffffff')\nmaxExpArray[69] = BigNumber.from('0x05f63b1fc104dbd39587ffffffffffffff')\nmaxExpArray[70] = BigNumber.from('0x05b771955b36e12f7235ffffffffffffff')\nmaxExpArray[71] = BigNumber.from('0x057b3d49dda84556d6f6ffffffffffffff')\nmaxExpArray[72] = BigNumber.from('0x054183095b2c8ececf30ffffffffffffff')\nmaxExpArray[73] = BigNumber.from('0x050a28be635ca2b888f77fffffffffffff')\nmaxExpArray[74] = BigNumber.from('0x04d5156639708c9db33c3fffffffffffff')\nmaxExpArray[75] = BigNumber.from('0x04a23105873875bd52dfdfffffffffffff')\nmaxExpArray[76] = BigNumber.from('0x0471649d87199aa990756fffffffffffff')\nmaxExpArray[77] = BigNumber.from('0x04429a21a029d4c1457cfbffffffffffff')\nmaxExpArray[78] = BigNumber.from('0x0415bc6d6fb7dd71af2cb3ffffffffffff')\nmaxExpArray[79] = BigNumber.from('0x03eab73b3bbfe282243ce1ffffffffffff')\nmaxExpArray[80] = BigNumber.from('0x03c1771ac9fb6b4c18e229ffffffffffff')\nmaxExpArray[81] = BigNumber.from('0x0399e96897690418f785257fffffffffff')\nmaxExpArray[82] = BigNumber.from('0x0373fc456c53bb779bf0ea9fffffffffff')\nmaxExpArray[83] = BigNumber.from('0x034f9e8e490c48e67e6ab8bfffffffffff')\nmaxExpArray[84] = BigNumber.from('0x032cbfd4a7adc790560b3337ffffffffff')\nmaxExpArray[85] = BigNumber.from('0x030b50570f6e5d2acca94613ffffffffff')\nmaxExpArray[86] = BigNumber.from('0x02eb40f9f620fda6b56c2861ffffffffff')\nmaxExpArray[87] = BigNumber.from('0x02cc8340ecb0d0f520a6af58ffffffffff')\nmaxExpArray[88] = BigNumber.from('0x02af09481380a0a35cf1ba02ffffffffff')\nmaxExpArray[89] = BigNumber.from('0x0292c5bdd3b92ec810287b1b3fffffffff')\nmaxExpArray[90] = BigNumber.from('0x0277abdcdab07d5a77ac6d6b9fffffffff')\nmaxExpArray[91] = BigNumber.from('0x025daf6654b1eaa55fd64df5efffffffff')\nmaxExpArray[92] = BigNumber.from('0x0244c49c648baa98192dce88b7ffffffff')\nmaxExpArray[93] = BigNumber.from('0x022ce03cd5619a311b2471268bffffffff')\nmaxExpArray[94] = BigNumber.from('0x0215f77c045fbe885654a44a0fffffffff')\nmaxExpArray[95] = BigNumber.from('0x01ffffffffffffffffffffffffffffffff')\nmaxExpArray[96] = BigNumber.from('0x01eaefdbdaaee7421fc4d3ede5ffffffff')\nmaxExpArray[97] = BigNumber.from('0x01d6bd8b2eb257df7e8ca57b09bfffffff')\nmaxExpArray[98] = BigNumber.from('0x01c35fedd14b861eb0443f7f133fffffff')\nmaxExpArray[99] = BigNumber.from('0x01b0ce43b322bcde4a56e8ada5afffffff')\nmaxExpArray[100] = BigNumber.from('0x019f0028ec1fff007f5a195a39dfffffff')\nmaxExpArray[101] = BigNumber.from('0x018ded91f0e72ee74f49b15ba527ffffff')\nmaxExpArray[102] = BigNumber.from('0x017d8ec7f04136f4e5615fd41a63ffffff')\nmaxExpArray[103] = BigNumber.from('0x016ddc6556cdb84bdc8d12d22e6fffffff')\nmaxExpArray[104] = BigNumber.from('0x015ecf52776a1155b5bd8395814f7fffff')\nmaxExpArray[105] = BigNumber.from('0x015060c256cb23b3b3cc3754cf40ffffff')\nmaxExpArray[106] = BigNumber.from('0x01428a2f98d728ae223ddab715be3fffff')\nmaxExpArray[107] = BigNumber.from('0x013545598e5c23276ccf0ede68034fffff')\nmaxExpArray[108] = BigNumber.from('0x01288c4161ce1d6f54b7f61081194fffff')\nmaxExpArray[109] = BigNumber.from('0x011c592761c666aa641d5a01a40f17ffff')\nmaxExpArray[110] = BigNumber.from('0x0110a688680a7530515f3e6e6cfdcdffff')\nmaxExpArray[111] = BigNumber.from('0x01056f1b5bedf75c6bcb2ce8aed428ffff')\nmaxExpArray[112] = BigNumber.from('0x00faadceceeff8a0890f3875f008277fff')\nmaxExpArray[113] = BigNumber.from('0x00f05dc6b27edad306388a600f6ba0bfff')\nmaxExpArray[114] = BigNumber.from('0x00e67a5a25da41063de1495d5b18cdbfff')\nmaxExpArray[115] = BigNumber.from('0x00dcff115b14eedde6fc3aa5353f2e4fff')\nmaxExpArray[116] = BigNumber.from('0x00d3e7a3924312399f9aae2e0f868f8fff')\nmaxExpArray[117] = BigNumber.from('0x00cb2ff529eb71e41582cccd5a1ee26fff')\nmaxExpArray[118] = BigNumber.from('0x00c2d415c3db974ab32a51840c0b67edff')\nmaxExpArray[119] = BigNumber.from('0x00bad03e7d883f69ad5b0a186184e06bff')\nmaxExpArray[120] = BigNumber.from('0x00b320d03b2c343d4829abd6075f0cc5ff')\nmaxExpArray[121] = BigNumber.from('0x00abc25204e02828d73c6e80bcdb1a95bf')\nmaxExpArray[122] = BigNumber.from('0x00a4b16f74ee4bb2040a1ec6c15fbbf2df')\nmaxExpArray[123] = BigNumber.from('0x009deaf736ac1f569deb1b5ae3f36c130f')\nmaxExpArray[124] = BigNumber.from('0x00976bd9952c7aa957f5937d790ef65037')\nmaxExpArray[125] = BigNumber.from('0x009131271922eaa6064b73a22d0bd4f2bf')\nmaxExpArray[126] = BigNumber.from('0x008b380f3558668c46c91c49a2f8e967b9')\nmaxExpArray[127] = BigNumber.from('0x00857ddf0117efa215952912839f6473e6')\n\nfunction leftShift(num: BigNumber, shift: BigNumber) {\n    return num.mul(TWO.pow(shift))\n}\n\nfunction signedRightShift(num: BigNumber, shift: BigNumber) {\n    return num.div(TWO.pow(shift))\n}\n\n/**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\nexport function power(\n    _baseN: BigNumber,\n    _baseD: BigNumber,\n    _expN: BigNumber,\n    _expD: BigNumber\n): [BigNumber, number] {\n    invariant(_baseN.gt(_baseD), \"not support _baseN < _baseD\");\n    invariant(_baseN.lt(MAX_NUM))\n\n    let baseLog;\n    let base = (_baseN.mul(FIXED_1)).div(_baseD);\n    if (base.lt(OPT_LOG_MAX_VAL)) {\n        baseLog = optimalLog(base);\n    } else {\n        baseLog = generalLog(base);\n    }\n\n    let baseLogTimesExp = (baseLog.mul(_expN)).div(_expD);\n    if (baseLogTimesExp.lt(OPT_EXP_MAX_VAL)) {\n        return [optimalExp(baseLogTimesExp), MAX_PRECISION]\n    } else {\n        let precision = findPositionInMaxExpArray(baseLogTimesExp);\n        return [generalExp(signedRightShift(baseLogTimesExp, BigNumber.from(MAX_PRECISION - precision)), BigNumber.from(precision)), precision]\n    }\n}\n\n/**\n * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n */\nfunction floorLog2(_n: BigNumber): BigNumber {\n    let res = ZERO;\n    if (_n.lt(_256)) {\n        // At most 8 iterations\n        while (_n.gt(ONE)) {\n            _n = signedRightShift(_n, ONE);\n            res = res.add(ONE);\n        }\n    } else {\n        // Exactly 8 iterations\n        for (let s = _128; s.gt(ZERO); s = signedRightShift(s, ONE)) {\n            if (_n.gt(leftShift(ONE, s))) {\n                _n = signedRightShift(_n, s)\n                res = res.or(s);\n            }\n        }\n    }\n\n    return res;\n}\n\n/**\n * @dev computes log(x / FIXED_1) * FIXED_1.\n * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n */\nexport function generalLog(x: BigNumber): BigNumber {\n    let res = ZERO;\n    // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n    if (x.gte(FIXED_2)) {\n        const count = floorLog2(x.div(FIXED_1));\n        x = signedRightShift(x, count);\n        // now x < 2\n        res = count.mul(FIXED_1);\n    }\n\n    // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n    if (x.gt(FIXED_1)) {\n        for (let i = MAX_PRECISION; i > 0; --i) {\n            x = (x.mul(x)).div(FIXED_1);\n            // now 1 < x < 4\n            if (x.gte(FIXED_2)) {\n                x = signedRightShift(x, ONE);\n                // now 1 < x < 2\n                res = res.add(leftShift(ONE, BigNumber.from(i - 1)));\n            }\n        }\n    }\n\n    return (res.mul(LN2_NUMERATOR)).div(LN2_DENOMINATOR)\n}\n\n/**\n    * @dev computes log(x / FIXED_1) * FIXED_1\n    * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\n    * Auto-generated via \"PrintFunctionOptimalLog.py\"\n    * Detailed description:\n    * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n    * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n    * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n    * - The natural logarithm of the input is calculated by summing up the intermediate results above\n    * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n    */\nexport function optimalLog(x: BigNumber): BigNumber {\n    let res = ZERO;\n\n    let y;\n    let z;\n    let w;\n\n    if (x.gte('0xd3094c70f034de4b96ff7d5b6f99fcd8')) {\n        res = res.add(BigNumber.from('0x40000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0xd3094c70f034de4b96ff7d5b6f99fcd8'));\n    }\n    // add 1 / 2^1\n    if (x.gte('0xa45af1e1f40c333b3de1db4dd55f29a7')) {\n        res = res.add(BigNumber.from('0x20000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0xa45af1e1f40c333b3de1db4dd55f29a7'));\n    }\n    // add 1 / 2^2\n    if (x.gte('0x910b022db7ae67ce76b441c27035c6a1')) {\n        res = res.add(BigNumber.from('0x10000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x910b022db7ae67ce76b441c27035c6a1'));\n    }\n    // add 1 / 2^3\n    if (x.gte('0x88415abbe9a76bead8d00cf112e4d4a8')) {\n        res = res.add(BigNumber.from('0x08000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x88415abbe9a76bead8d00cf112e4d4a8'));\n    }\n    // add 1 / 2^4\n    if (x.gte('0x84102b00893f64c705e841d5d4064bd3')) {\n        res = res.add(BigNumber.from('0x04000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x84102b00893f64c705e841d5d4064bd3'));\n    }\n    // add 1 / 2^5\n    if (x.gte('0x8204055aaef1c8bd5c3259f4822735a2')) {\n        res = res.add(BigNumber.from('0x02000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x8204055aaef1c8bd5c3259f4822735a2'));\n    }\n    // add 1 / 2^6\n    if (x.gte('0x810100ab00222d861931c15e39b44e99')) {\n        res = res.add(BigNumber.from('0x01000000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x810100ab00222d861931c15e39b44e99'));\n    }\n    // add 1 / 2^7\n    if (x.gte('0x808040155aabbbe9451521693554f733')) {\n        res = res.add(BigNumber.from('0x00800000000000000000000000000000'));\n        x = (x.mul(FIXED_1)).div(BigNumber.from('0x808040155aabbbe9451521693554f733'));\n    }\n    // add 1 / 2^8\n\n    z = y = x.sub(FIXED_1);\n    w = (y.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x100000000000000000000000000000000').sub(y)).div(BigNumber.from('0x100000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^01 / 01 - y^02 / 02\n    res = res.add(z.mul(BigNumber.from('0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa').sub(y)).div(BigNumber.from('0x200000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^03 / 03 - y^04 / 04\n    res = res.add(z.mul(BigNumber.from('0x099999999999999999999999999999999').sub(y)).div(BigNumber.from('0x300000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^05 / 05 - y^06 / 06\n    res = res.add(z.mul(BigNumber.from('0x092492492492492492492492492492492').sub(y)).div(BigNumber.from('0x400000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^07 / 07 - y^08 / 08\n    res = res.add(z.mul(BigNumber.from('0x08e38e38e38e38e38e38e38e38e38e38e').sub(y)).div(BigNumber.from('0x500000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^09 / 09 - y^10 / 10\n    res = res.add(z.mul(BigNumber.from('0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b').sub(y)).div(BigNumber.from('0x600000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^11 / 11 - y^12 / 12\n    res = res.add(z.mul(BigNumber.from('0x089d89d89d89d89d89d89d89d89d89d89').sub(y)).div(BigNumber.from('0x700000000000000000000000000000000')));\n    z = (z.mul(w)).div(FIXED_1);\n    // add y^13 / 13 - y^14 / 14\n    res = res.add(z.mul(BigNumber.from('0x088888888888888888888888888888888').sub(y)).div(BigNumber.from('0x800000000000000000000000000000000')));\n    // add y^15 / 15 - y^16 / 16\n\n    return res;\n}\n\nexport function optimalExp(x: BigNumber): BigNumber {\n    let res = ZERO;\n\n    let y;\n    let z;\n\n    z = y = x.mod(BigNumber.from('0x10000000000000000000000000000000'));\n    // get the input modulo 2^(-3)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x10e1b3be415a0000')));\n    // add y^02 * (20! / 02!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x05a0913f6b1e0000')));\n    // add y^03 * (20! / 03!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0168244fdac78000')));\n    // add y^04 * (20! / 04!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x004807432bc18000')));\n    // add y^05 * (20! / 05!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000c0135dca04000')));\n    // add y^06 * (20! / 06!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0001b707b1cdc000')));\n    // add y^07 * (20! / 07!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000036e0f639b800')));\n    // add y^08 * (20! / 08!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x00000618fee9f800')));\n    // add y^09 * (20! / 09!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000009c197dcc00')));\n    // add y^10 * (20! / 10!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000e30dce400')));\n    // add y^11 * (20! / 11!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000000012ebd1300')));\n    // add y^12 * (20! / 12!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000017499f00')));\n    // add y^13 * (20! / 13!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000001a9d480')));\n    // add y^14 * (20! / 14!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x00000000001c6380')));\n    // add y^15 * (20! / 15!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000000000001c638')));\n    // add y^16 * (20! / 16!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000000001ab8')));\n    // add y^17 * (20! / 17!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x000000000000017c')));\n    // add y^18 * (20! / 18!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000000000014')));\n    // add y^19 * (20! / 19!)\n    z = (z.mul(y)).div(FIXED_1);\n    res = res.add(z.mul(BigNumber.from('0x0000000000000001')));\n    // add y^20 * (20! / 20!)\n    res = res.div(BigNumber.from('0x21c3677c82b40000')).add(y).add(FIXED_1);\n    // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n    if (!(x.and(BigNumber.from('0x010000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x1c3d6a24ed82218787d624d3e5eba95f9'))).div(BigNumber.from('0x18ebef9eac820ae8682b9793ac6d1e776'));\n    // multiply by e^2^(-3)\n    if (!(x.and(BigNumber.from('0x020000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x18ebef9eac820ae8682b9793ac6d1e778'))).div(BigNumber.from('0x1368b2fc6f9609fe7aceb46aa619baed4'));\n    // multiply by e^2^(-2)\n    if (!(x.and(BigNumber.from('0x040000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x1368b2fc6f9609fe7aceb46aa619baed5'))).div(BigNumber.from('0x0bc5ab1b16779be3575bd8f0520a9f21f'));\n    // multiply by e^2^(-1)\n    if (!(x.and(BigNumber.from('0x080000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x0bc5ab1b16779be3575bd8f0520a9f21e'))).div(BigNumber.from('0x0454aaa8efe072e7f6ddbab84b40a55c9'));\n    // multiply by e^2^(+0)\n    if (!(x.and(BigNumber.from('0x100000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x0454aaa8efe072e7f6ddbab84b40a55c5'))).div(BigNumber.from('0x00960aadc109e7a3bf4578099615711ea'));\n    // multiply by e^2^(+1)\n    if (!(x.and(BigNumber.from('0x200000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x00960aadc109e7a3bf4578099615711d7'))).div(BigNumber.from('0x0002bf84208204f5977f9a8cf01fdce3d'));\n    // multiply by e^2^(+2)\n    if (!(x.and(BigNumber.from('0x400000000000000000000000000000000')).isZero())) res = (res.mul(BigNumber.from('0x0002bf84208204f5977f9a8cf01fdc307'))).div(BigNumber.from('0x0000003c6ab775dd0b95b4cbee7e65d11'));\n    // multiply by e^2^(+3)\n\n    return res;\n}\n\n/**\n   * @dev this function can be auto-generated by the script \"PrintFunctionGeneralExp.py\".\n   * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n   * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n   * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n   * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n   */\nexport function generalExp(_x: BigNumber, _precision: BigNumber) {\n    let xi = _x;\n    let res = ZERO;\n\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x3442c4e6074a82f1797f72ac0000000'));\n    // add x^02 * (33! / 02!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x116b96f757c380fb287fd0e40000000'));\n    // add x^03 * (33! / 03!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x045ae5bdd5f0e03eca1ff4390000000'));\n    // add x^04 * (33! / 04!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00defabf91302cd95b9ffda50000000'));\n    // add x^05 * (33! / 05!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x002529ca9832b22439efff9b8000000'));\n    // add x^06 * (33! / 06!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00054f1cf12bd04e516b6da88000000'));\n    // add x^07 * (33! / 07!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000a9e39e257a09ca2d6db51000000'));\n    // add x^08 * (33! / 08!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000012e066e7b839fa050c309000000'));\n    // add x^09 * (33! / 09!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000001e33d7d926c329a1ad1a800000'));\n    // add x^10 * (33! / 10!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000002bee513bdb4a6b19b5f800000'));\n    // add x^11 * (33! / 11!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000003a9316fa79b88eccf2a00000'));\n    // add x^12 * (33! / 12!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000048177ebe1fa812375200000'));\n    // add x^13 * (33! / 13!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000005263fe90242dcbacf00000'));\n    // add x^14 * (33! / 14!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000057e22099c030d94100000'));\n    // add x^15 * (33! / 15!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000057e22099c030d9410000'));\n    // add x^16 * (33! / 16!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000052b6b54569976310000'));\n    // add x^17 * (33! / 17!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000004985f67696bf748000'));\n    // add x^18 * (33! / 18!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000003dea12ea99e498000'));\n    // add x^19 * (33! / 19!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000031880f2214b6e000'));\n    // add x^20 * (33! / 20!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000000025bcff56eb36000'));\n    // add x^21 * (33! / 21!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000000001b722e10ab1000'));\n    // add x^22 * (33! / 22!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000001317c70077000'));\n    // add x^23 * (33! / 23!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000cba84aafa00'));\n    // add x^24 * (33! / 24!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000082573a0a00'));\n    // add x^25 * (33! / 25!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000005035ad900'));\n    // add x^26 * (33! / 26!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x000000000000000000000002f881b00'));\n    // add x^27 * (33! / 27!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000001b29340'));\n    // add x^28 * (33! / 28!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x00000000000000000000000000efc40'));\n    // add x^29 * (33! / 29!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000007fe0'));\n    // add x^30 * (33! / 30!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000000420'));\n    // add x^31 * (33! / 31!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000000021'));\n    // add x^32 * (33! / 32!)\n    xi = signedRightShift(xi.mul(_x), _precision);\n    res = res.add(xi.mul('0x0000000000000000000000000000001'));\n    // add x^33 * (33! / 33!)\n\n\n    return (res.div(BigNumber.from('0x688589cc0e9505e2f2fee5580000000'))).add(_x).add(leftShift(ONE, _precision));\n    // divide by 33! and then add x^1 / 1! + x^0 / 0!\n}\n\n/**\n    * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n    * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n    * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n    */\nexport function findPositionInMaxExpArray(_x: BigNumber): number {\n    let lo = MIN_PRECISION;\n    let hi = MAX_PRECISION;\n\n    while (lo + 1 < hi) {\n        let mid = (lo + hi) / 2;\n        if (maxExpArray[mid].gte(_x)) lo = mid;\n        else hi = mid;\n    }\n\n    if (maxExpArray[hi].gte(_x)) return hi;\n    if (maxExpArray[lo].gte(_x)) return lo;\n\n    invariant(false);\n}\n\n/**\n * @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset,\n *\n * Formula:\n * return = reserveOut * (1 - (reserveIn * 10000 / (reserveIn * 10000 + amountIn * (10000 - swapFee))) ^ (tokenWeightIn / tokenWeightOut))\n *\n * @param amountIn                  source reserve amount\n * @param reserveIn    source reserve balance\n * @param reserveOut    target reserve balance\n * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n * @param swapFee                  swap fee of the conversion\n *\n * @return amountOut\n */\nexport function getAmountOut(\n    amountIn: BigNumber,\n    reserveIn: BigNumber,\n    reserveOut: BigNumber,\n    tokenWeightIn: BigNumber,\n    tokenWeightOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    // validate input\n    invariant(amountIn.gt(ZERO), \"RequiemFormula: INSUFFICIENT_INPUT_AMOUNT\");\n    // if (amountIn.lte(ZERO) || amountIn.eq(ZERO))\n    //     return ZERO\n\n    invariant(reserveIn.gt(ZERO) && reserveOut.gt(ZERO), \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n    const amountInWithFee = amountIn.mul(TENK.sub(swapFee))\n    // special case for equal weights\n    if (tokenWeightIn.eq(tokenWeightOut)) {\n        return (reserveOut.mul(amountInWithFee)).div(reserveIn.mul(TENK).add(amountInWithFee));\n    }\n\n    // let result;\n    // let precision: number;\n    const baseN = (reserveIn.mul(TENK)).add(amountInWithFee)\n    const [result, precision] = power(baseN, reserveIn.mul(TENK), tokenWeightIn, tokenWeightOut);\n\n    const temp1 = reserveOut.mul(result);\n    const temp2 = leftShift(reserveOut, BigNumber.from(precision));\n\n    return (temp1.sub(temp2)).div(result)\n}\n\n/**\n * @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n *\n * Formula:\n * return = reserveIn * ( (reserveOut / (reserveOut - amountOut)) ^ (tokenWeightOut / tokenWeightIn) - 1) * (10000/ (10000 - swapFee)\n *\n * @param amountOut     target reserve amount\n * @param reserveIn    source reserve balance\n * @param reserveOut    target reserve balance\n * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n * @param swapFee                  swap fee of the conversion\n *\n * @return amountIn\n */\nexport function getAmountIn(\n    amountOut: BigNumber,\n    reserveIn: BigNumber,\n    reserveOut: BigNumber,\n    tokenWeightIn: BigNumber,\n    tokenWeightOut: BigNumber,\n    swapFee: BigNumber\n) {\n    // validate input\n    invariant(amountOut.gt(ZERO), \"RequiemFormula: INSUFFICIENT_OUTPUT_AMOUNT\");\n\n    // if (amountOut.gte(ZERO) || amountOut.eq(ZERO))\n    //     return ZERO\n\n    invariant(reserveIn.gt(ZERO) && reserveOut.gt(ZERO), \"RequiemFormula: INSUFFICIENT_LIQUIDITY\");\n    // special case for equal weights\n    if (tokenWeightIn.eq(tokenWeightOut)) {\n        const numerator = reserveIn.mul(amountOut).mul(TENK);\n        const denominator = reserveOut.sub(amountOut).mul(TENK.sub(swapFee));\n        return (numerator.div(denominator)).add(1);\n    }\n\n    const baseD = reserveOut.sub(amountOut);\n    const [result, precision] = power(reserveOut, baseD, tokenWeightOut, tokenWeightIn);\n    const baseReserveIn = reserveIn.mul(TENK);\n    const temp1 = baseReserveIn.mul(result);\n    const temp2 = leftShift(baseReserveIn, BigNumber.from(precision));\n    return (signedRightShift(temp1.sub(temp2), BigNumber.from(precision)).div(TENK.sub(swapFee))).add(1);\n}\n\n","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\nimport { Token } from '../token'\nimport { Price, TokenAmount } from '../fractions'\n\n// const ZERO = BigNumber.from(0)\n\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport abstract class Pool {\n\n    // the index-token map \n    public abstract readonly tokens: Token[]\n    public abstract readonly liquidityToken: Token\n    public abstract tokenBalances: BigNumber[]\n    public abstract readonly address: string\n    public abstract _name: string\n\n    /**\n     * Returns true if the token is either token0 or token1\n     * @param token to check\n     */\n    public involvesToken(token: Token): boolean {\n        let res = false\n        for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n            res || token.equals(this.tokens[i])\n        }\n\n        return res\n    }\n\n    // maps the index to the token in the stablePool\n    public tokenFromIndex(index: number): Token {\n        return this.tokens[index]\n    }\n\n    public indexFromToken(token: Token): number {\n        for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n            if (token.equals(this.tokens[index])) {\n                return index\n            }\n        }\n        throw new Error('token not in pool');\n    }\n\n    public getBalances(): BigNumber[] {\n        return Object.keys(this.tokens).map((_, index) => (this.tokenBalances[index]))\n    }\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public abstract calculateSwapGivenIn(\n        tokenIn: Token,\n        tokenOut: Token,\n        inAmount: BigNumber): BigNumber;\n\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public abstract calculateSwapGivenOut(\n        tokenIn: Token,\n        tokenOut: Token,\n        outAmount: BigNumber): BigNumber;\n\n    /**\n     * Returns the chain ID of the tokens in the pair.\n     */\n    public get chainId(): number {\n        return this.tokens[0].chainId\n    }\n\n    public token(index: number): Token {\n        return this.tokens[index]\n    }\n\n    public reserveOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n            if (token.equals(this.tokens[i]))\n                return this.tokenBalances[i]\n        }\n        return BigNumber.from(0)\n    }\n\n    public set name(value: string) {\n        this._name = value\n    }\n\n    public get name(): string {\n        return this._name\n    }\n\n\n    public setBalanceValueByIndex(index: number, newBalance: BigNumber) {\n        this.tokenBalances[index] = newBalance\n    }\n\n    public getTokenAmounts(): TokenAmount[] {\n        return this.tokens.map((t, i) => new TokenAmount(t, this.tokenBalances[i]))\n    }\n\n    public setTokenBalances(tokenBalances: BigNumber[]) {\n        this.tokenBalances = tokenBalances\n    }\n\n    public subtractBalanceValue(tokenAmount: TokenAmount) {\n        let newBalances = [] // safe way for replacement\n        for (let i = 0; i < this.tokenBalances.length; i++) {\n            newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].sub(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n        }\n        this.setTokenBalances(newBalances)\n    }\n\n    public abstract poolPrice(tokenIn: Token, tokenOut: Token): Price;\n\n    public abstract poolPriceBases(tokenIn: Token, tokenOut: Token): {\n        priceBaseIn: BigNumber\n        priceBaseOut: BigNumber\n    };\n\n    // function that adjusts pool for swap  amounts if routed through more than once\n    public abstract adjustForSwap(amountIn: TokenAmount, amountOut: TokenAmount): void;\n\n    // function that adjusts pool for swap  amounts if routed through more than once\n    public abstract clone(): Pool;\n\n}\n\n\nexport enum PoolType {\n    Pair = 'Pair',\n    StablePairWrapper = 'StablePairWrapper',\n    AmplifiedWeightedPair = 'AmplifiedWeightedPair',\n    PoolPairWrapper = 'PoolPairWrapper',\n}\n\nexport type PoolDictionary = { [id: string]: Pool }\n\nexport type PoolHops = {\n    [tokenAddress: string]: Set<Token>; // the set of pool ids\n}","import { BigNumber } from \"ethers\"\nimport { ZERO } from \"./LogExpMath\"\n\nexport class WeightedSwapStorage {\n    public readonly tokenMultipliers: BigNumber[]\n    public readonly normalizedWeights: BigNumber[]\n    public readonly fee: BigNumber\n    public readonly adminFee: BigNumber\n    constructor(\n        tokenMultipliers: BigNumber[],\n        normalizedWeights: BigNumber[],\n        fee: BigNumber,\n        adminFee: BigNumber,\n    ) {\n        this.tokenMultipliers = tokenMultipliers\n        this.normalizedWeights = normalizedWeights\n        this.fee = fee\n        this.adminFee = adminFee\n\n    }\n\n    public static mock(): WeightedSwapStorage {\n        return new WeightedSwapStorage([ZERO], [ZERO], ZERO, ZERO)\n    }\n\n}","import { BigNumber } from \"ethers\"\n\nexport class StableSwapStorage {\n    public readonly tokenMultipliers: BigNumber[]\n    public readonly fee: BigNumber\n    public readonly adminFee: BigNumber\n    public readonly initialA: BigNumber\n    public readonly futureA: BigNumber\n    public readonly initialATime: BigNumber\n    public readonly futureATime: BigNumber\n    public readonly lpAddress: string\n\n    constructor(tokenMultipliers: BigNumber[],\n        fee: BigNumber,\n        adminFee: BigNumber,\n        initialA: BigNumber,\n        futureA: BigNumber,\n        initialATime: BigNumber,\n        futureATime: BigNumber,\n        lpAddress: string) {\n        this.lpAddress = lpAddress\n        this.tokenMultipliers = tokenMultipliers\n        this.fee = fee\n        this.adminFee = adminFee\n        this.initialA = initialA\n        this.futureA = futureA\n        this.initialATime = initialATime\n        this.futureATime = futureATime\n    }\n\n    public static mock(): StableSwapStorage {\n        const dummy = BigNumber.from(0)\n        return new StableSwapStorage([dummy], dummy, dummy, dummy, dummy, dummy, dummy, '')\n    }\n\n}","import { Price } from '../../fractions/price'\nimport { TokenAmount } from '../../fractions/tokenAmount'\nimport invariant from 'tiny-invariant'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport {\n    BigintIsh,\n    MINIMUM_LIQUIDITY,\n    ZERO,\n    // ONE,\n    FIVE,\n    // _100,\n    // FEES_NUMERATOR,\n    // FEES_DENOMINATOR,\n    FACTORY_ADDRESS,\n    TENK,\n} from '../../../constants'\nimport { sqrt, parseBigintIsh } from '../../../helperUtils'\nimport {\n    // InsufficientReservesError,\n    InsufficientInputAmountError, InsufficientReservesError\n} from '../../../errors'\nimport { Token } from '../../token'\nimport { getAmountOut, getAmountIn } from '../../calculators/weightedPairCalc'\nimport { PoolType, Pool } from '../pool'\n// import { getAmountIn, getAmountOut } from 'entities/calculators/weightedPairCalc'\nimport { ethers } from 'ethers'\nimport { ChainId } from '../../currency'\n\nconst _100 = BigNumber.from(100)\n\nlet PAIR_ADDRESS_CACHE: {\n    [token0Address: string]: {\n        [token1Address: string]: {\n            [weight0: string]: string\n        }\n    }\n} = {}\n\nconst PAIR_HASH: { [chainId: number]: string } = {\n    [ChainId.AVAX_TESTNET]: '0x9054fb12bf026c7ef2c6d1f68fbbead8f68cdbfa477faca7f9d8ec63173f87ff',\n    [ChainId.BSC_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.AVAX_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.OASIS_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.OASIS_TESTNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.BSC_TESTNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.MATIC_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.MATIC_TESTNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.QUARKCHAIN_DEV_S0]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.ARBITRUM_TETSNET_RINKEBY]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84',\n    [ChainId.ARBITRUM_MAINNET]: '0x623d9ad8b6787321d0dff55d4f864a7cfdedfb1802a561c75cd01c62a079bc84'\n}\n\nexport class AmplifiedWeightedPair extends Pool {\n    public readonly address: string\n    public readonly tokens: Token[]\n    public tokenBalances: BigNumber[]\n    public virtualReserves: BigNumber[]\n    public readonly liquidityToken: Token\n    private readonly weights: BigNumber[]\n    private readonly fee: BigNumber\n    private readonly ampBPS: BigNumber\n    public readonly type: PoolType\n    public _name: string\n\n    public static getAddress(tokenA: Token, tokenB: Token, weightA: BigNumber): string {\n        const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n        const weights = tokenA.sortsBefore(tokenB) ? [weightA.toString(), _100.sub(weightA).toString()] : [_100.sub(weightA).toString(), weightA.toString()] // does safety checks\n        if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address]?.[`${weights[0]}`] === undefined) {\n            PAIR_ADDRESS_CACHE = {\n                ...PAIR_ADDRESS_CACHE,\n                [tokens[0].address]: {\n                    ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\n                    [tokens[1].address]: {\n                        ...PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address],\n                        [`${weights[0]}`]: getCreate2Address(\n                            FACTORY_ADDRESS[tokens[0].chainId],\n                            keccak256(\n                                ['bytes'],\n                                [pack(\n                                    ['address', 'address', 'uint32'],\n                                    [tokens[0].address, tokens[1].address, weights[0]]\n                                )]\n                            ),\n                            PAIR_HASH[tokens[0].chainId]\n                        )\n                    },\n                },\n            }\n        }\n\n        return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address][`${weights[0]}`]\n    }\n\n    public constructor(tokens: Token[], tokenBalances: BigNumber[], virtualReserves: BigNumber[], weightA: BigNumber, fee: BigNumber, amp: BigNumber, address?: string) {\n        super()\n\n        this.tokenBalances = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? tokenBalances\n            : [tokenBalances[1], tokenBalances[0]]\n        this.tokens = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? tokens\n            : [tokens[1], tokens[0]]\n\n        this.ampBPS = amp\n        this.weights = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? [weightA, _100.sub(weightA)]\n            : [_100.sub(weightA), weightA]\n\n        this.virtualReserves = tokens[0].sortsBefore(tokens[1]) // does safety checks\n            ? virtualReserves\n            : [virtualReserves[1], virtualReserves[0]]\n\n\n        this.fee = fee\n        this.liquidityToken = new Token(\n            tokens[0].chainId,\n            address ? ethers.utils.getAddress(address) : AmplifiedWeightedPair.getAddress(this.tokens[0], this.tokens[1], this.weights[0]),\n            18,\n            'Requiem-LP',\n            'Requiem LPs'\n        )\n        this.type = PoolType.AmplifiedWeightedPair\n        this.address = !address ? AmplifiedWeightedPair.getAddress(this.token0, this.token1, this.weight0) : address\n\n        this._name = tokens.map(t => t.symbol).join('-')\n    }\n\n    public static fromBigIntish(tokens: Token[], tokenBalances: BigintIsh[], virtualReserves: BigintIsh[], weightA: BigintIsh, fee: BigintIsh, amp: BigintIsh, address?: string): AmplifiedWeightedPair {\n        return new AmplifiedWeightedPair(\n            tokens,\n            tokenBalances.map(b => BigNumber.from(b)),\n            virtualReserves.map(b => BigNumber.from(b)),\n            BigNumber.from(weightA),\n            BigNumber.from(fee),\n            BigNumber.from(amp),\n            address\n        )\n    }\n\n    public getAddressForRouter(): string {\n        return this.liquidityToken.address\n    }\n\n    /**\n     * Returns true if the token is either token0 or token1\n     * @param token to check\n     */\n    public involvesToken(token: Token): boolean {\n        return token.equals(this.token0) || token.equals(this.token1)\n    }\n\n    public get amp(): BigNumber {\n        return this.ampBPS\n    }\n\n    /**\n     * Returns the current mid price of the pair in terms of token0 in virtual reserves\n     */\n    public get token0Price(): Price {\n        return new Price(\n            this.token0,\n            this.token1,\n            this.virtualReserves[0].mul(this.weights[1]),\n            this.virtualReserves[1].mul(this.weights[0])\n        )\n    }\n\n    /**\n     * Returns the current mid price of the pair in terms of token1 in virtual reserves\n     */\n    public get token1Price(): Price {\n        return new Price(\n            this.token1,\n            this.token0,\n            this.virtualReserves[1].mul(this.weights[0]),\n            this.virtualReserves[0].mul(this.weights[1])\n        )\n    }\n\n    public poolPrice(tokenIn: Token, _: Token): Price {\n        return tokenIn.equals(this.token0) ? this.token0Price : this.token1Price\n    }\n\n    public get fee0(): BigNumber {\n        return this.fee\n    }\n\n    public poolPriceBases(tokenIn: Token, _: Token): { priceBaseIn: BigNumber; priceBaseOut: BigNumber; } {\n        if (tokenIn.equals(this.token0)) {\n            return {\n                priceBaseIn: this.virtualReserves[0].mul(this.weights[1]),\n                priceBaseOut: this.virtualReserves[1].mul(this.weights[0])\n            }\n        } else {\n            return {\n                priceBaseIn: this.virtualReserves[1].mul(this.weights[0]),\n                priceBaseOut: this.virtualReserves[0].mul(this.weights[1])\n            }\n        }\n    }\n\n    /**\n     * Return the price of the given token in terms of the other token in the pair.\n     * @param token token to return price of\n     */\n    public priceOf(token: Token): Price {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.token0Price : this.token1Price\n    }\n\n    /**\n     * Returns the chain ID of the tokens in the pair.\n     */\n    public get chainId(): ChainId {\n        return this.token0.chainId\n    }\n\n    public get token0(): Token {\n        return this.tokens[0]\n    }\n\n    public get token1(): Token {\n        return this.tokens[1]\n    }\n\n    public get reserve0(): TokenAmount {\n        return new TokenAmount(this.tokens[0], this.tokenBalances[0])\n    }\n\n    public get reserve1(): TokenAmount {\n        return new TokenAmount(this.tokens[1], this.tokenBalances[1])\n    }\n\n    public get virtualReserve0(): TokenAmount {\n        return new TokenAmount(this.tokens[0], this.virtualReserves[0])\n    }\n\n    public get virtualReserve1(): TokenAmount {\n        return new TokenAmount(this.tokens[1], this.virtualReserves[1])\n    }\n\n    public get weight0(): BigNumber {\n        return this.weights[0]\n    }\n\n    public get weight1(): BigNumber {\n        return this.weights[1]\n    }\n\n\n    public reserveOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.reserve0.raw : this.reserve1.raw\n    }\n\n\n    public virtualReserveOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.virtualReserve0.raw : this.virtualReserve1.raw\n    }\n\n    public weightOf(token: Token): BigNumber {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.weight0 : this.weight1\n    }\n\n\n    public getLiquidityMinted(\n        totalSupply: TokenAmount,\n        tokenAmountA: TokenAmount,\n        tokenAmountB: TokenAmount\n    ): TokenAmount {\n        invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n        const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n            ? [tokenAmountA, tokenAmountB]\n            : [tokenAmountB, tokenAmountA]\n        invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n        let liquidity: BigNumber\n        if (totalSupply.raw.eq(ZERO)) {\n            liquidity = sqrt(tokenAmounts[0].raw.mul(tokenAmounts[1].raw)).sub(MINIMUM_LIQUIDITY)\n        } else {\n            const amount0 = tokenAmounts[0].raw.mul(totalSupply.raw).div(this.reserve0.raw)\n            const amount1 = tokenAmounts[1].raw.mul(totalSupply.raw).div(this.reserve1.raw)\n            liquidity = amount0.lte(amount1) ? amount0 : amount1\n        }\n        if (!liquidity.gt(ZERO)) {\n            throw new InsufficientInputAmountError()\n        }\n        return new TokenAmount(this.liquidityToken, liquidity)\n    }\n\n    public getLiquidityValue(\n        token: Token,\n        totalSupply: TokenAmount,\n        liquidity: TokenAmount,\n        feeOn: boolean = false,\n        kLast?: BigintIsh\n    ): TokenAmount {\n        invariant(this.involvesToken(token), 'TOKEN')\n        invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n        invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n        invariant(liquidity.raw.lte(totalSupply.raw), 'LIQUIDITY')\n\n        let totalSupplyAdjusted: TokenAmount\n        if (!feeOn) {\n            totalSupplyAdjusted = totalSupply\n        } else {\n            invariant(!!kLast, 'K_LAST')\n            const kLastParsed = parseBigintIsh(kLast)\n            if (!kLastParsed.eq(ZERO)) {\n                const rootK = sqrt(this.reserve0.raw.mul(this.reserve1.raw))\n                const rootKLast = sqrt(kLastParsed)\n                if (rootK.gt(rootKLast)) {\n                    const numerator = totalSupply.raw.mul(rootK.sub(rootKLast))\n                    const denominator = rootK.mul(FIVE).add(rootKLast)\n                    const feeLiquidity = numerator.div(denominator)\n                    totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n                } else {\n                    totalSupplyAdjusted = totalSupply\n                }\n            } else {\n                totalSupplyAdjusted = totalSupply\n            }\n        }\n\n        return new TokenAmount(\n            token,\n            liquidity.raw.mul(this.reserveOf(token)).div(totalSupplyAdjusted.raw)\n        )\n    }\n\n    // these are only supposed to be used for liquidity calculations\n    /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n    public get token0PriceRaw(): Price {\n        return new Price(this.token0, this.token1, this.tokenBalances[0], this.tokenBalances[1])\n    }\n\n    /**\n     * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n     */\n    public get token1PriceRaw(): Price {\n        return new Price(this.token1, this.token0, this.tokenBalances[1], this.tokenBalances[0])\n    }\n\n    /**\n     * Return the price of the given token in terms of the other token in the pair.\n     * @param token token to return price of\n     */\n    public priceRatioOf(token: Token): Price {\n        invariant(this.involvesToken(token), 'TOKEN')\n        return token.equals(this.token0) ? this.token0PriceRaw : this.token1PriceRaw\n    }\n\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public calculateSwapGivenIn(\n        tokenIn: Token,\n        tokenOut: Token,\n        inAmount: BigNumber): BigNumber {\n        if (\n            inAmount.gte(this.reserveOf(tokenIn))\n        ) {\n            throw new InsufficientReservesError()\n        }\n        const inputReserve = this.virtualReserveOf(tokenIn)\n        const outputReserve = this.virtualReserveOf(tokenOut)\n\n        const inputWeight = this.weightOf(tokenIn)\n        const outputWeight = this.weightOf(tokenOut)\n\n        return getAmountOut(\n            inAmount,\n            inputReserve,\n            outputReserve,\n            inputWeight,\n            outputWeight,\n            this.fee\n        )\n    }\n\n\n    // calculates the swap output amount without\n    // pinging the blockchain for data\n    public calculateSwapGivenOut(\n        tokenIn: Token,\n        tokenOut: Token,\n        outAmount: BigNumber): BigNumber {\n        if (\n            outAmount.gte(this.reserveOf(tokenOut))\n        ) {\n            throw new InsufficientReservesError()\n        }\n\n        const outputReserve = this.virtualReserveOf(tokenOut)\n        const inputReserve = this.virtualReserveOf(tokenIn)\n\n        const outputWeight = this.weightOf(tokenOut)\n        const inputWeight = this.weightOf(tokenIn)\n\n\n        return getAmountIn(\n            outAmount,\n            inputReserve,\n            outputReserve,\n            inputWeight,\n            outputWeight,\n            this.fee\n        )\n\n    }\n\n    public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pool] {\n        invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n        if (this.reserve0.raw.eq(ZERO) || this.reserve1.raw.eq(ZERO)) {\n            throw new InsufficientReservesError()\n        }\n        const inputReserve = this.virtualReserveOf(inputAmount.token)\n        const outputReserve = this.virtualReserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n        const inputWeight = this.weightOf(inputAmount.token)\n        const outputWeight = this.weightOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n\n        const outputAmount = new TokenAmount(\n            inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n\n            getAmountOut(\n                inputAmount.toBigNumber(),\n                inputReserve,\n                outputReserve,\n                inputWeight,\n                outputWeight,\n                this.fee\n            )\n        )\n        // console.log(\"OA\", outputAmount.raw.toString())\n        if (outputAmount.raw.eq(ZERO)) {\n            throw new InsufficientInputAmountError()\n        }\n\n        return [\n            outputAmount,\n            new AmplifiedWeightedPair(\n                [inputAmount.token, inputAmount.token.equals(this.token0) ? this.token1 : this.token0], // tokens\n                [this.reserveOf(inputAmount.token).add(inputAmount.raw), this.reserveOf(outputAmount.token).sub(outputAmount.raw)], // reserves\n                [inputReserve.add(inputAmount.raw), outputReserve.sub(outputAmount.raw)], // virtual reserves\n                inputWeight,\n                this.ampBPS,\n                this.fee\n            )\n        ]\n    }\n\n    public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pool] {\n        invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n        console.log(\"-- this 0\", this.reserve0.raw, \"1\", this.reserve1.raw, \"out\", outputAmount.raw)\n        if (\n            this.reserve0.raw.eq(ZERO) ||\n            this.reserve1.raw.eq(ZERO) ||\n            outputAmount.raw.gte(this.reserveOf(outputAmount.token))\n        ) {\n            throw new Error(\"insufficcient reserves\")\n        }\n\n        const outputReserve = this.virtualReserveOf(outputAmount.token)\n        const inputReserve = this.virtualReserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n        const outputWeight = this.weightOf(outputAmount.token)\n        const inputWeight = this.weightOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n\n        const inputAmount = new TokenAmount(\n            outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n            getAmountIn(\n                outputAmount.toBigNumber(),\n                inputReserve,\n                outputReserve,\n                inputWeight,\n                outputWeight,\n                this.fee\n            )\n        )\n\n        return [\n            inputAmount,\n            new AmplifiedWeightedPair(\n                [inputAmount.token, outputAmount.token],\n                [this.reserveOf(inputAmount.token).add(inputAmount.raw), this.reserveOf(outputAmount.token).sub(outputAmount.raw)],\n                [inputReserve.add(inputAmount.raw), outputReserve.sub(outputAmount.raw)],\n                inputWeight,\n                this.ampBPS,\n                this.fee\n            )\n        ]\n    }\n\n    public adjustForSwap(amountIn: TokenAmount, amountOut: TokenAmount) {\n        this.virtualReserves[this.indexFromToken(amountIn.token)] = this.virtualReserves[this.indexFromToken(amountIn.token)].add(amountIn.raw.mul(this.amp).div(TENK))\n        this.virtualReserves[this.indexFromToken(amountOut.token)] = this.virtualReserves[this.indexFromToken(amountOut.token)].sub(amountOut.raw.mul(this.amp).div(TENK))\n    };\n\n    public clone(): AmplifiedWeightedPair {\n        return new AmplifiedWeightedPair(this.tokens, this.tokenBalances, this.virtualReserves, this.weight0, this.fee0, this.amp, this.address)\n    }\n}\n\n\n","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\n\nimport { Contract } from '@ethersproject/contracts'\nimport { ethers } from 'ethers'\nimport { WeightedSwapStorage } from '../../calculators/weightedSwapStorage'\nimport {\n  BigintIsh,\n} from '../../../constants'\nimport weightedPoolABI from '../../../abis/WeightedPool.json'\nimport { Token } from '../../token'\nimport { TokenAmount } from '../../fractions/tokenAmount'\nimport { ZERO } from '../../calculators/LogExpMath'\nimport { calculateRemoveLiquidityExactIn, calculateRemoveLiquidityOneTokenExactIn, calculateSwapGivenIn, calculateSwapGivenOut, calculateTokenAmount } from '../../calculators/WeightedPoolLib'\nimport { Pool } from '../pool'\nimport { Price } from '../../fractions'\nimport { ChainId } from '../../currency'\n// const ZERO = BigNumber.from(0)\n\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport class WeightedPool extends Pool {\n  public readonly address: string\n  // the only LP token\n  public readonly liquidityToken: Token\n  // the index-token map \n  public readonly tokens: Token[]\n  public tokenBalances: BigNumber[]\n  public swapStorage: WeightedSwapStorage\n  public _name: string\n\n  public lpTotalSupply: BigNumber\n\n  public constructor(\n    poolAddress: string,\n    tokens: Token[],\n    tokenBalances: BigNumber[],\n    swapStorage: WeightedSwapStorage,\n    lpTotalSupply: BigNumber,\n    lpAddress?: string\n  ) {\n    super()\n    this.tokens = tokens\n    this.tokenBalances = tokenBalances\n    this.address = ethers.utils.getAddress(poolAddress)\n    this.lpTotalSupply = lpTotalSupply\n    this.swapStorage = swapStorage\n    this.tokens = tokens\n    this.tokenBalances = tokenBalances\n    this.liquidityToken = new Token(\n      tokens[0].chainId,\n      lpAddress ?? '0x0000000000000000000000000000000000000001',\n      18,\n      'Requiem-LP',\n      'Requiem Swap LPs'\n    )\n\n    for (let i = 0; i < Object.values(this.tokens).length; i++) {\n      invariant(tokens[i].address != ethers.constants.AddressZero, \"invalidTokenAddress\");\n      invariant(tokens[i].decimals <= 18, \"invalidDecimals\");\n      invariant(tokens[i].chainId === tokens[0].chainId, 'INVALID TOKENS')\n    }\n\n    this._name = 'Weighted Pool'\n  }\n\n  public static mock() {\n    return new WeightedPool('', [new Token(1, '0x0000000000000000000000000000000000000001', 6, 'Mock USDC', 'MUSDC')], [ZERO], WeightedSwapStorage.mock(), ZERO)\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    let res = false\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      res || token.equals(this.tokens[i])\n    }\n\n    return res\n  }\n\n  // maps the index to the token in the stablePool\n  public tokenFromIndex(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public indexFromToken(token: Token): number {\n    for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n      if (token.equals(this.tokens[index])) {\n        return index\n      }\n    }\n    throw new Error('token not in pool');\n  }\n\n  // calculates the output amount usingn the input for the swableSwap\n  // requires the view on a contract as manual calculation on the frontend would\n  // be inefficient\n  public async calculateSwapViaPing(\n    inToken: Token,\n    outToken: Token,\n    inAmount: BigNumber | BigintIsh,\n    // chainId: number,\n    provider: ethers.Signer | ethers.providers.Provider): Promise<BigintIsh> {\n\n    const outAmount: BigintIsh = await new Contract(\n      '0xCc62754F15f7F35E4c58Ce6aD5608fA575C5583E',\n      new ethers.utils.Interface(weightedPoolABI as any),\n      provider\n    ).calculateSwapGivenIn(inToken.address, outToken.address, inAmount)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenIn(\n    tokenIn: Token,\n    tokenOut: Token,\n    inAmount: BigNumber): BigNumber {\n\n    const outAmount: BigNumber = calculateSwapGivenIn(\n      this.swapStorage,\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      inAmount,\n      this.tokenBalances\n    )\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenOut(\n    tokenIn: Token,\n    tokenOut: Token,\n    outAmount: BigNumber): BigNumber {\n\n    const inAmount: BigNumber = calculateSwapGivenOut(\n      this.swapStorage,\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      outAmount,\n      this.tokenBalances,\n    )\n\n    return inAmount\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount, tokenOut: Token): TokenAmount {\n    const swap = this.calculateSwapGivenIn(inputAmount.token, tokenOut, inputAmount.raw)\n    return new TokenAmount(tokenOut, swap)\n  }\n\n  public getInputAmount(outputAmount: TokenAmount, tokenIn: Token): TokenAmount {\n    const swap = this.calculateSwapGivenOut(tokenIn, outputAmount.token, outputAmount.raw)\n    return new TokenAmount(tokenIn, swap.toBigInt())\n  }\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.tokens[0].chainId\n  }\n\n  public token(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public reserveOf(token: Token): BigNumber {\n    invariant(this.involvesToken(token), 'TOKEN')\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      if (token.equals(this.tokens[i]))\n        return this.tokenBalances[i]\n    }\n    return BigNumber.from(0)\n  }\n\n  public calculateRemoveLiquidity(amountLp: BigNumber): BigNumber[] {\n    return calculateRemoveLiquidityExactIn(\n      this.swapStorage,\n      amountLp,\n      this.lpTotalSupply,\n      this.tokenBalances\n    ).map((x, i) => x.div(this.swapStorage.tokenMultipliers[i]))\n  }\n\n  public calculateRemoveLiquidityOneToken(amount: BigNumber, index: number): { amountOut: BigNumber, swapFee: BigNumber } {\n    const { amountOut, swapFee } = calculateRemoveLiquidityOneTokenExactIn(\n      this.swapStorage,\n      index,\n      amount,\n      this.lpTotalSupply,\n      this.tokenBalances\n    )\n    return {\n      amountOut: amountOut.div(this.swapStorage.tokenMultipliers[index]),\n      swapFee\n    }\n  }\n\n  public getLiquidityAmount(amounts: BigNumber[], deposit: boolean) {\n    return calculateTokenAmount(\n      this.swapStorage,\n      amounts,\n      this.lpTotalSupply,\n      deposit,\n      this.tokenBalances,\n    )\n  }\n\n  public getLiquidityValue(outIndex: number, userBalances: BigNumber[]): TokenAmount {\n    let amount = BigNumber.from(0)\n    for (let i = 0; i < userBalances.length; i++) {\n      if (i !== outIndex)\n        amount = amount.add(this.calculateSwapGivenIn(this.tokens[i], this.tokens[outIndex], userBalances[i]))\n    }\n    amount = amount.add(userBalances[outIndex])\n    return new TokenAmount(this.tokens[outIndex], amount)\n  }\n\n  public setSwapStorage(swapStorage: WeightedSwapStorage) {\n    this.swapStorage = swapStorage\n  }\n\n  public setTokenBalances(tokenBalances: BigNumber[]) {\n    this.tokenBalances = tokenBalances\n  }\n\n  public setLpTotalSupply(totalSupply: BigNumber) {\n    this.lpTotalSupply = totalSupply\n  }\n\n  public setBalanceValueByIndex(index: number, newBalance: BigNumber) {\n    this.tokenBalances[index] = newBalance\n  }\n\n  public setBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? tokenAmount.toBigNumber() : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public addBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].add(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public subtractBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].sub(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public clone(): WeightedPool {\n    return new WeightedPool(\n      this.address,\n      this.tokens,\n      this.tokenBalances,\n      this.swapStorage,\n      this.lpTotalSupply\n    )\n  }\n\n  public poolPrice(tokenIn: Token, tokenOut: Token): Price {\n    const inIndex = this.indexFromToken(tokenIn)\n    const outIndex = this.indexFromToken(tokenOut)\n    return new Price(\n      tokenIn,\n      tokenOut,\n      this.swapStorage.normalizedWeights[outIndex].mul(this.tokenBalances[inIndex]),\n      this.swapStorage.normalizedWeights[inIndex].mul(this.tokenBalances[outIndex])\n    )\n  }\n\n  public poolPriceBases(tokenIn: Token, tokenOut: Token): { priceBaseIn: BigNumber; priceBaseOut: BigNumber; } {\n    const inIndex = this.indexFromToken(tokenIn)\n    const outIndex = this.indexFromToken(tokenOut)\n    return {\n      priceBaseIn: this.swapStorage.normalizedWeights[outIndex].mul(this.tokenBalances[inIndex]),\n      priceBaseOut: this.swapStorage.normalizedWeights[inIndex].mul(this.tokenBalances[outIndex])\n    }\n  }\n\n  public adjustForSwap(amountIn: TokenAmount, amountOut: TokenAmount) {\n    this.tokenBalances[this.indexFromToken(amountIn.token)] = this.tokenBalances[this.indexFromToken(amountIn.token)].add(amountIn.raw)\n    this.tokenBalances[this.indexFromToken(amountOut.token)] = this.tokenBalances[this.indexFromToken(amountOut.token)].sub(amountOut.raw)\n  };\n  \n}\n","import { BigNumber } from 'ethers'\nimport invariant from 'tiny-invariant'\nimport { ONE_18 } from './LogExpMath'\nimport { StableSwapStorage } from './stableSwapStorage'\n\nconst MAX_ITERATION = 256\nexport const A_PRECISION = BigNumber.from(1000)\nconst FEE_DENOMINATOR = ONE_18\nconst ONE = BigNumber.from(1)\n\nexport function _xp(balances: BigNumber[], rates: BigNumber[]): BigNumber[] {\n    let result = []\n    for (let i = 0; i < balances.length; i++) {\n        result.push(rates[i].mul(balances[i]))\n    }\n    return result\n}\n\n\nexport function _getAPrecise(blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage\n): BigNumber {\n    if (blockTimestamp.gte(swapStorage.futureATime)) {\n        return swapStorage.futureA;\n    }\n\n    if (swapStorage.futureA.gt(swapStorage.initialA)) {\n        return swapStorage.initialA.add(\n            swapStorage.futureA.sub(swapStorage.initialA).mul(blockTimestamp.sub(swapStorage.initialATime)).div(\n                swapStorage.futureATime.sub(swapStorage.initialATime)))\n    }\n\n    return swapStorage.initialA.sub(swapStorage.initialA.sub(swapStorage.futureA).mul(blockTimestamp.sub(swapStorage.initialATime))).div(\n        swapStorage.futureATime.sub(swapStorage.initialATime))\n}\n\nexport function _sumOf(x: BigNumber[]): BigNumber {\n    let sum = BigNumber.from(0);\n    for (let i = 0; i < x.length; i++) {\n        sum = sum.add(x[i])\n    }\n    return sum\n}\n\n\nexport function _distance(x: BigNumber, y: BigNumber): BigNumber {\n    return x.gt(y) ? x.sub(y) : y.sub(x)\n}\n\n/**\n * Calculate D for *NORMALIZED* balances of each tokens\n * @param xp normalized balances of token\n */\nexport function _getD(xp: BigNumber[], amp: BigNumber): BigNumber {\n    const nCoins = xp.length;\n    let sum = _sumOf(xp)\n    if (sum.eq(0)) {\n        return BigNumber.from(0)\n    }\n\n    let Dprev = BigNumber.from(0)\n    let D = sum;\n    let Ann = amp.mul(nCoins)\n\n    for (let i = 0; i < MAX_ITERATION; i++) {\n        let D_P = D;\n        for (let j = 0; j < xp.length; j++) {\n            D_P = D_P.mul(D).div(xp[j].mul(nCoins))\n        }\n\n        Dprev = D;\n        D = ((Ann.mul(sum)).div(A_PRECISION).add(D_P.mul(nCoins)).mul(D)).div(\n            ((Ann.sub(A_PRECISION)).mul(D).div(A_PRECISION)).add(D_P.mul(nCoins + 1)))\n\n        if (_distance(D, Dprev).lte(1)) {\n            return D;\n        }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    invariant(\"invariantCalculationFailed\");\n    return D\n}\n\nexport function _getY(\n    inIndex: number,\n    outIndex: number,\n    inBalance: BigNumber,\n    // self, shoudl be replaced with swapStorage object\n    blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage,\n    normalizedBalances: BigNumber[]\n\n): BigNumber {\n    invariant(inIndex != outIndex, \"sameToken\");\n    const nCoins = normalizedBalances.length;\n    invariant(inIndex < nCoins && outIndex < nCoins, \"indexOutOfRange\");\n\n    let amp = _getAPrecise(blockTimestamp, swapStorage);\n    let Ann = amp.mul(nCoins)\n    let D = _getD(normalizedBalances, amp);\n    let sum = BigNumber.from(0) // sum of new balances except output token\n    let c = D;\n    for (let i = 0; i < nCoins; i++) {\n        if (i == outIndex) {\n            continue;\n        }\n\n        let x = i == inIndex ? inBalance : normalizedBalances[i];\n        sum = sum.add(x)\n        c = (c.mul(D)).div(x.mul(nCoins))\n    }\n\n    c = c.mul(D.mul(A_PRECISION)).div(Ann.mul(nCoins))\n    let b = sum.add(D.mul(A_PRECISION).div(Ann))\n\n    let lastY = BigNumber.from(0)\n    let y = D;\n    for (let index = 0; index < MAX_ITERATION; index++) {\n        lastY = y;\n        y = ((y.mul(y)).add(c)).div(y.mul(2).add(b).sub(D))\n        if (_distance(lastY, y).lte(1)) {\n            return y;\n        }\n    }\n\n    invariant(\"yCalculationFailed\")\n    return BigNumber.from(0)\n}\n\nexport function calculateSwapGivenIn(inIndex: number, outIndex: number, inAmount: BigNumber, // standard fields\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage\n): BigNumber {\n    let normalizedBalances = _xp(balances, swapStorage.tokenMultipliers)\n    let newInBalance = normalizedBalances[inIndex].add(inAmount.mul(swapStorage.tokenMultipliers[inIndex]))\n    let outBalance = _getY(\n        inIndex,\n        outIndex,\n        newInBalance,\n        blockTimestamp,\n        swapStorage,\n        normalizedBalances\n    )\n\n    let outAmount = ((normalizedBalances[outIndex].sub(outBalance)).sub(ONE)).div(swapStorage.tokenMultipliers[outIndex])\n    let _fee = swapStorage.fee.mul(outAmount).div(FEE_DENOMINATOR)\n    return outAmount.sub(_fee)\n}\n\nexport function calculateSwapGivenOut(inIndex: number, outIndex: number, outAmount: BigNumber, // standard fields\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    swapStorage: StableSwapStorage\n): BigNumber {\n\n    let normalizedBalances = _xp(balances, swapStorage.tokenMultipliers)\n\n    let _amountOutInclFee = outAmount.mul(FEE_DENOMINATOR).div(FEE_DENOMINATOR.sub(swapStorage.fee));\n    let newOutBalance = normalizedBalances[outIndex].sub(_amountOutInclFee.mul(swapStorage.tokenMultipliers[outIndex]));\n\n    let inBalance = _getY(\n        outIndex,\n        inIndex,\n        newOutBalance,\n        blockTimestamp,\n        swapStorage,\n        normalizedBalances\n    )\n\n    const inAmount = ((inBalance.sub(normalizedBalances[inIndex]).sub(ONE)).div(swapStorage.tokenMultipliers[inIndex])).add(ONE)\n    return inAmount;\n}\n\n// function to calculate the amounts of stables from the amounts of LP\nexport function _calculateRemoveLiquidity(\n    amount: BigNumber,\n    swapStorage: StableSwapStorage,\n    totalSupply: BigNumber,\n    currentWithdrawFee: BigNumber,\n    balances: BigNumber[]\n): BigNumber[] {\n\n    invariant(amount.lte(totalSupply), \"Cannot exceed total supply\");\n\n    let feeAdjustedAmount = amount.mul(FEE_DENOMINATOR.sub(currentWithdrawFee)).div(\n        FEE_DENOMINATOR)\n\n    let amounts = []\n\n    for (let i = 0; i < swapStorage.tokenMultipliers.length; i++) {\n        amounts.push((balances[i].mul(feeAdjustedAmount)).div(totalSupply))\n    }\n    return amounts;\n}\n\n\nfunction _getYD(\n    A: BigNumber,\n    index: number,\n    xp: BigNumber[],\n    D: BigNumber\n): BigNumber {\n    let nCoins = xp.length;\n    invariant(index < nCoins, \"INDEX\");\n    let Ann = A.mul(nCoins)\n    let c = D;\n    let s = BigNumber.from(0)\n    let _x = BigNumber.from(0)\n    let yPrev = BigNumber.from(0)\n\n    for (let i = 0; i < nCoins; i++) {\n        if (i == index) {\n            continue;\n        }\n        _x = xp[i];\n        s = s.add(_x)\n        c = (c.mul(D)).div(_x.mul(nCoins))\n    }\n\n    c = (c.mul(D).mul(A_PRECISION)).div(Ann.mul(nCoins))\n    let b = s.add(D.mul(A_PRECISION).div(Ann))\n    let y = D;\n\n    for (let i = 0; i < MAX_ITERATION; i++) {\n        yPrev = y;\n        y = ((y.mul(y)).add(c)).div(((y.mul(2)).add(b)).sub(D))\n        if (_distance(yPrev, y).lt(1)) {\n            return y;\n        }\n    }\n    invariant(\"invariantCalculationFailed\")\n    return BigNumber.from(0)\n}\n\nfunction _feePerToken(swapStorage: StableSwapStorage): BigNumber {\n    let nCoins = swapStorage.tokenMultipliers.length;\n    return (swapStorage.fee.mul(nCoins)).div(4 * (nCoins - 1));\n}\n\n\nexport function _calculateRemoveLiquidityOneToken(\n    swapStorage: StableSwapStorage,\n    tokenAmount: BigNumber,\n    index: number,\n    blockTimestamp: BigNumber,\n    balances: BigNumber[],\n    totalSupply: BigNumber,\n    currentWithdrawFee: BigNumber\n): { [returnVal: string]: BigNumber }// {dy:BigNumber, fee:BigNumber} \n{\n    invariant(index < swapStorage.tokenMultipliers.length, \"indexOutOfRange\")\n\n    let amp = _getAPrecise(blockTimestamp, swapStorage)\n    let xp = _xp(balances, swapStorage.tokenMultipliers)\n    let D0 = _getD(xp, amp);\n    let D1 = D0.sub((tokenAmount.mul(D0)).div(totalSupply))\n    let newY = _getYD(amp, index, xp, D1);\n    let reducedXP = xp;\n    let _fee = _feePerToken(swapStorage);\n\n    for (let i = 0; i < swapStorage.tokenMultipliers.length; i++) {\n        let expectedDx = BigNumber.from(0)\n        if (i == index) {\n            expectedDx = ((xp[i].mul(D1)).div(D0)).sub(newY)\n        } else {\n            expectedDx = xp[i].sub(xp[i].mul(D1).div(D0))\n        }\n        reducedXP[i] = reducedXP[i].sub(_fee.mul(expectedDx).div(FEE_DENOMINATOR))\n    }\n\n    let dy = reducedXP[index].sub(_getYD(amp, index, reducedXP, D1))\n    dy = (dy.sub(1)).div(swapStorage.tokenMultipliers[index])\n    let fee = ((xp[index].sub(newY)).div(swapStorage.tokenMultipliers[index])).sub(dy)\n    dy = dy.mul(FEE_DENOMINATOR.sub(currentWithdrawFee)).div(FEE_DENOMINATOR)\n    return { \"dy\": dy, \"fee\": fee }\n}\n\n\n/**\n * Estimate amount of LP token minted or burned at deposit or withdrawal\n * without taking fees into account\n */\nexport function _calculateTokenAmount(\n    swapStorage: StableSwapStorage,\n    amounts: BigNumber[],\n    deposit: boolean,\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    totalSupply: BigNumber\n): BigNumber {\n    let nCoins = swapStorage.tokenMultipliers.length;\n    invariant(amounts.length == nCoins, \"invalidAmountsLength\");\n    let amp = _getAPrecise(blockTimestamp, swapStorage);\n    let D0 = _getD(_xp(balances, swapStorage.tokenMultipliers), amp);\n\n    let newBalances = balances;\n    for (let i = 0; i < nCoins; i++) {\n        if (deposit) {\n            newBalances[i] = newBalances[i].add(amounts[i])\n        } else {\n            newBalances[i] = newBalances[i].sub(amounts[i])\n        }\n    }\n\n    let D1 = _getD(_xp(newBalances, swapStorage.tokenMultipliers), amp);\n\n\n    if (totalSupply.eq(0)) {\n        return D1; // first depositor take it all\n    }\n\n    let diff = deposit ? D1.sub(D0) : D0.sub(D1)\n    return (diff.mul(totalSupply)).div(D0)\n}","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\nimport {\n  _getAPrecise,\n  calculateSwapGivenIn,\n  _calculateRemoveLiquidity,\n  _calculateRemoveLiquidityOneToken,\n  _calculateTokenAmount,\n  calculateSwapGivenOut\n} from '../../calculators/stableCalc'\nimport { Contract } from '@ethersproject/contracts'\nimport { ethers } from 'ethers'\nimport { StableSwapStorage } from '../../calculators/stableSwapStorage'\nimport {\n  BigintIsh,\n  STABLE_POOL_ADDRESS\n} from '../../../constants'\nimport StableSwap from '../../../abis/RequiemStableSwap.json'\nimport { Token } from '../../token'\nimport { TokenAmount } from '../../fractions/tokenAmount'\nimport { Pool } from '../pool'\nimport { Price } from '../../fractions'\n\n// const ZERO = BigNumber.from(0)\n\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport class StablePool extends Pool {\n  public readonly address: string\n  // the only LP token\n  public readonly liquidityToken: Token\n  // the index-token map \n  public readonly tokens: Token[]\n  public tokenBalances: BigNumber[]\n  public _A: BigNumber\n  public swapStorage: StableSwapStorage\n  // public readonly rates: BigNumber[]\n  public blockTimestamp: BigNumber\n\n  public lpTotalSupply: BigNumber\n  public currentWithdrawFee: BigNumber\n  public _name: string\n\n  public constructor(\n    tokens: Token[],\n    tokenBalances: BigNumber[],\n    _A: BigNumber,\n    swapStorage: StableSwapStorage,\n    blockTimestamp: number,\n    lpTotalSupply: BigNumber,\n    currentWithdrawFee: BigNumber,\n    poolAddress: string,\n    lpAddress?: string\n  ) {\n    super()\n    this.tokens = tokens\n    this.currentWithdrawFee = currentWithdrawFee\n    this.lpTotalSupply = lpTotalSupply\n    this.swapStorage = swapStorage\n    this.blockTimestamp = BigNumber.from(blockTimestamp)\n    this.tokenBalances = tokenBalances\n    this._A = _A\n    this.liquidityToken = new Token(\n      tokens[0].chainId,\n      lpAddress ?? '0x0000000000000000000000000000000000000001',\n      18,\n      'RequiemStable-LP',\n      'Requiem StableSwap LPs'\n    )\n    this.address = ethers.utils.getAddress(poolAddress)\n\n    for (let i = 0; i < Object.values(this.tokens).length; i++) {\n      invariant(tokens[i].address != ethers.constants.AddressZero, \"invalidTokenAddress\");\n      invariant(tokens[i].decimals <= 18, \"invalidDecimals\");\n      invariant(tokens[i].chainId === tokens[0].chainId, 'INVALID TOKENS')\n    }\n\n    this._name = 'Stable Pool'\n  }\n\n  public static mock() {\n    const dummy = BigNumber.from(0)\n    return new StablePool([new Token(1, '0x0000000000000000000000000000000000000001', 6, 'Mock USDC', 'MUSDC')], [dummy], dummy, StableSwapStorage.mock(), 0, dummy, dummy, '0x0000000000000000000000000000000000000001')\n  }\n\n  public getAddressForRouter(): string {\n    return STABLE_POOL_ADDRESS[this.tokens[0].chainId]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    let res = false\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      res || token.equals(this.tokens[i])\n    }\n\n    return res\n  }\n\n  public set setCurrentWithdrawFee(feeToSet: BigNumber) {\n    this.currentWithdrawFee = feeToSet\n  }\n\n  // maps the index to the token in the stablePool\n  public tokenFromIndex(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public indexFromToken(token: Token): number {\n    for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n      if (token.equals(this.tokens[index])) {\n        return index\n      }\n    }\n    throw new Error('token not in pool');\n  }\n\n  public getBalances(): BigNumber[] {\n    return Object.keys(this.tokens).map((_, index) => (this.tokenBalances[index]))\n  }\n\n  // calculates the output amount usingn the input for the swableSwap\n  // requires the view on a contract as manual calculation on the frontend would\n  // be inefficient\n  public async calculateSwapViaPing(\n    inToken: Token,\n    outToken: Token,\n    inAmount: BigNumber | BigintIsh,\n    provider: ethers.Signer | ethers.providers.Provider): Promise<BigintIsh> {\n\n    const outAmount: BigintIsh = await new Contract(this.address, new ethers.utils.Interface(StableSwap), provider).calculateSwap(inToken.address, outToken.address, inAmount)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenIn(\n    tokenIn: Token,\n    tokenOut: Token,\n    inAmount: BigNumber): BigNumber {\n\n    // if (this.getBalances()[inIndex].lte(inAmount)) // || inAmount.eq(ZERO))\n    //   return ZERO\n\n    const outAmount: BigNumber = calculateSwapGivenIn(\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      inAmount,\n      this.tokenBalances,\n      this.blockTimestamp,\n      this.swapStorage)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwapGivenOut(\n    tokenIn: Token,\n    tokenOut: Token,\n    outAmount: BigNumber): BigNumber {\n\n    // if (this.getBalances()[outIndex].lte(outAmount)) // || outAmount.eq(ZERO))\n    //   return ZERO\n\n    const inAmount: BigNumber = calculateSwapGivenOut(\n      this.indexFromToken(tokenIn),\n      this.indexFromToken(tokenOut),\n      outAmount,\n      this.tokenBalances,\n      this.blockTimestamp,\n      this.swapStorage)\n\n    return inAmount\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount, tokenOut: Token): TokenAmount {\n    const swap = this.calculateSwapGivenIn(inputAmount.token, tokenOut, inputAmount.toBigNumber())\n    return new TokenAmount(tokenOut, swap.toBigInt())\n  }\n\n  public getInputAmount(outputAmount: TokenAmount, tokenIn: Token): TokenAmount {\n    const swap = this.calculateSwapGivenOut(tokenIn, outputAmount.token, outputAmount.toBigNumber())\n    return new TokenAmount(tokenIn, swap)\n  }\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): number {\n    return this.tokens[0].chainId\n  }\n\n  public token(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public reserveOf(token: Token): BigNumber {\n    invariant(this.involvesToken(token), 'TOKEN')\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      if (token.equals(this.tokens[i]))\n        return this.tokenBalances[i]\n    }\n    return BigNumber.from(0)\n  }\n\n  public calculateRemoveLiquidity(amountLp: BigNumber): BigNumber[] {\n    return _calculateRemoveLiquidity(\n      amountLp,\n      this.swapStorage,\n      this.lpTotalSupply,\n      this.currentWithdrawFee,\n      this.getBalances()\n    )\n  }\n\n  public calculateRemoveLiquidityOneToken(amount: BigNumber, index: number): { [returnVal: string]: BigNumber } {\n    return _calculateRemoveLiquidityOneToken(\n      this.swapStorage,\n      amount,\n      index,\n      this.blockTimestamp,\n      this.getBalances(),\n      this.lpTotalSupply,\n      this.currentWithdrawFee\n    )\n  }\n\n  public getLiquidityAmount(amounts: BigNumber[], deposit: boolean) {\n    return _calculateTokenAmount(\n      this.swapStorage,\n      amounts,\n      deposit,\n      this.getBalances(),\n      this.blockTimestamp,\n      this.lpTotalSupply\n    )\n  }\n\n  public getLiquidityValue(outIndex: number, userBalances: BigNumber[]): TokenAmount {\n    let amount = BigNumber.from(0)\n    for (let i = 0; i < userBalances.length; i++) {\n      if (i !== outIndex)\n        amount = amount.add(this.calculateSwapGivenIn(this.tokens[i], this.tokens[outIndex], userBalances[i]))\n    }\n    amount = amount.add(userBalances[outIndex])\n    return new TokenAmount(this.tokens[outIndex], amount.toBigInt())\n  }\n\n  public setSwapStorage(swapStorage: StableSwapStorage) {\n    this.swapStorage = swapStorage\n  }\n\n  public setTokenBalances(tokenBalances: BigNumber[]) {\n    this.tokenBalances = tokenBalances\n  }\n\n  public setBlockTimestamp(blockTimestamp: BigNumber) {\n    this.blockTimestamp = blockTimestamp\n  }\n\n  public setLpTotalSupply(totalSupply: BigNumber) {\n    this.lpTotalSupply = totalSupply\n  }\n\n  public setBalanceValueByIndex(index: number, newBalance: BigNumber) {\n    this.tokenBalances[index] = newBalance\n  }\n\n  public setBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? tokenAmount.toBigNumber() : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public addBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].add(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public subtractBalanceValue(tokenAmount: TokenAmount) {\n    let newBalances = [] // safe way for replacement\n    for (let i = 0; i < this.tokenBalances.length; i++) {\n      newBalances.push(this.indexFromToken(tokenAmount.token) === i ? this.tokenBalances[i].sub(tokenAmount.toBigNumber()) : this.tokenBalances[i])\n    }\n    this.setTokenBalances(newBalances)\n  }\n\n  public clone(): StablePool {\n    return new StablePool(\n      this.tokens, this.tokenBalances, this._A, this.swapStorage, this.blockTimestamp.toNumber(), this.lpTotalSupply, this.currentWithdrawFee, this.address\n    )\n  }\n\n  public poolPrice(tokenIn: Token, tokenOut: Token): Price {\n    const virtualIn = BigNumber.from(this.tokenBalances[this.indexFromToken(tokenIn)]).div(10000)\n    return new Price(tokenIn, tokenOut, virtualIn, this.calculateSwapGivenIn(tokenIn, tokenOut, virtualIn))\n  }\n\n\n  public poolPriceBases(tokenIn: Token, tokenOut: Token): { priceBaseIn: BigNumber; priceBaseOut: BigNumber; } {\n    const virtualIn = this.tokenBalances[this.indexFromToken(tokenIn)].div(10000)\n    return {\n      priceBaseIn: virtualIn,\n      priceBaseOut: this.calculateSwapGivenIn(tokenIn, tokenOut, virtualIn)\n    }\n  }\n\n  public adjustForSwap(amountIn: TokenAmount, amountOut: TokenAmount) {\n    this.tokenBalances[this.indexFromToken(amountIn.token)] = this.tokenBalances[this.indexFromToken(amountIn.token)].add(amountIn.raw)\n    this.tokenBalances[this.indexFromToken(amountOut.token)] = this.tokenBalances[this.indexFromToken(amountOut.token)].sub(amountOut.raw)\n  };\n} \n","import { BigNumber } from \"ethers\";\nimport invariant from \"tiny-invariant\";\nimport { ChainId } from \"../currency\";\nimport { TokenAmount } from \"../fractions\";\nimport { Token } from \"../token\";\nimport { Pool, PoolDictionary } from \"./pool\";\n\nexport interface SwapReturn {\n    amount: TokenAmount;\n    pool: { [id: string]: Pool };\n}\n\n// class that stores data for a Pair to swap through\n// does not store any pricing or calculation functions - these are used through the poolId which is taken from a pool dictionary\n// these pools are then used for pricing\nexport class SwapData {\n\n    public readonly tokenIn: Token\n    public readonly tokenOut: Token\n    public readonly poolRef: string\n    public pool: Pool | null\n\n    // these are for saving the pool price with not using the price class as it would store the token object twice\n    public priceBaseIn: BigNumber | undefined\n    public priceBaseOut: BigNumber | undefined\n\n    constructor(tokenIn: Token, tokenOut: Token, poolRef: string) {\n        // invariant(!tokenIn.equals(tokenOut), 'TOKEN')\n        this.tokenIn = tokenIn\n        this.tokenOut = tokenOut\n        this.poolRef = poolRef\n        this.pool = null;\n\n    }\n\n    public calculateSwapGivenOut(\n        tokenOutAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        return new TokenAmount(this.tokenIn, poolDict[this.poolRef].calculateSwapGivenOut(this.tokenIn, tokenOutAmount.token, tokenOutAmount.raw))\n    }\n\n    public calculateSwapGivenIn(\n        tokenInAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        return new TokenAmount(this.tokenOut, poolDict[this.poolRef].calculateSwapGivenIn(tokenInAmount.token, this.tokenOut, tokenInAmount.raw))\n    }\n\n\n    public calculateSwapGivenOutAmendingPool(\n        tokenOutAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        // const poolDictCopy = { ...poolDict }\n        const refPool: Pool = Object.assign({}, poolDict[this.poolRef]);\n        const amount = new TokenAmount(this.tokenIn, refPool.calculateSwapGivenOut(this.tokenIn, tokenOutAmount.token, tokenOutAmount.raw))\n        poolDict[this.poolRef] = refPool;\n        return amount\n    }\n\n    public calculateSwapGivenInAmendingPool(\n        tokenInAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        // const poolDictCopy = { ...poolDict }\n        const refPool: Pool = Object.assign({}, poolDict[this.poolRef]);\n        const amount = new TokenAmount(this.tokenOut, refPool.calculateSwapGivenIn(tokenInAmount.token, this.tokenOut, tokenInAmount.raw))\n        refPool.adjustForSwap(tokenInAmount, amount)\n        poolDict[this.poolRef] = refPool;\n        return amount\n\n    }\n\n    public get chainId(): ChainId { return this.tokenIn.chainId }\n\n    public involvesToken(token: Token) {\n        return this.tokenIn.address === token.address || this.tokenOut.address === token.address\n    }\n\n    /**\n     *  Calculate the mid price for a pool - if possible\n     * @param tokenIn in token for price\n     * @param tokenOut out/ quote token for price\n     * @param poolDict pool dictionary to fetch the underlying pool from\n     * @returns price object\n     */\n    public poolPrice(poolDict: { [id: string]: Pool }) {\n        return poolDict[this.poolRef].poolPrice(this.tokenIn, this.tokenOut)\n    }\n\n\n    /**\n * @param pool input pool to generate pair from\n * @returns pair route\n */\n    public static singleDataFromPool(tokenIn: Token, tokenOut: Token, pool: Pool): SwapData {\n        invariant(pool.tokens.includes(tokenIn) && pool.tokens.includes(tokenOut))\n        const data = new SwapData(tokenIn, tokenOut, pool.address)\n        data.pool = pool\n        return data;\n\n    }\n\n    public fetchPoolPrice(poolDict: PoolDictionary) {\n        const { priceBaseIn, priceBaseOut } = poolDict[this.poolRef].poolPriceBases(this.tokenIn, this.tokenOut)\n        this.priceBaseIn = priceBaseIn\n        this.priceBaseOut = priceBaseOut\n    }\n\n    public setPool(pool: Pool) {\n        this.pool = pool;\n    }\n\n}","import { ChainId } from \"../currency\";\nimport { TokenAmount } from \"../fractions\";\nimport { Token } from \"../token\";\nimport { Pool } from \"./pool\";\nimport { SwapData } from \"./swapData\";\n\n\n// class that stores data for a Pair to swap through\n// does not store any pricing or calculation functions - these are used through the poolId which is taken from a pool dictionary\n// these pools are then used for pricing\nexport class PairData {\n\n    public readonly token0: Token\n    public readonly token1: Token\n    public readonly poolRef: string\n    constructor(token0: Token, token1: Token, poolRef: string) {\n        this.token0 = token0\n        this.token1 = token1\n        this.poolRef = poolRef\n\n    }\n\n    public calculateSwapGivenOut(\n        tokenOutAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        const tokenIn = tokenOutAmount.token.equals(this.token0) ? this.token1 : this.token0\n        return new TokenAmount(tokenIn, poolDict[this.poolRef].calculateSwapGivenOut(tokenIn, tokenOutAmount.token, tokenOutAmount.raw))\n    }\n\n    public calculateSwapGivenIn(\n        tokenInAmount: TokenAmount,\n        poolDict: { [id: string]: Pool }\n    ): TokenAmount {\n        const tokenOut = tokenInAmount.token.equals(this.token0) ? this.token1 : this.token0\n        return new TokenAmount(tokenOut, poolDict[this.poolRef].calculateSwapGivenIn(tokenInAmount.token, tokenOut, tokenInAmount.raw))\n    }\n\n    public get chainId(): ChainId { return this.token0.chainId }\n\n    public involvesToken(token: Token) {\n        return this.token0.address === token.address || this.token1.address === token.address\n    }\n\n    /**\n     *  Calculate the mid price for a pool - if possible\n     * @param tokenIn in token for price\n     * @param tokenOut out/ quote token for price\n     * @param poolDict pool dictionary to fetch the underlying pool from\n     * @returns price object\n     */\n    public poolPrice(tokenIn: Token, tokenOut: Token, poolDict: { [id: string]: Pool }) {\n        return poolDict[this.poolRef].poolPrice(tokenIn, tokenOut)\n    }\n\n    /**\n     * Pools with n > 2 tokens generate (n^2-n)/2 possible pair routes to trade\n     * The fubnction creates these pair routes\n     * @param pool input pool to generate pairs from\n     * @returns pair routes\n     */\n    public static dataFromPool(pool: Pool): PairData[] {\n        let pairData = []\n\n        for (let i = 0; i < pool.tokenBalances.length; i++) {\n            for (let j = 0; j < i; j++) {\n                pairData.push(new PairData(pool.tokens[i], pool.tokens[j], pool.address))\n            }\n        }\n        return pairData\n    }\n\n    /**\n     * @param pool input pool to generate pair from\n     * @returns pair route\n     */\n    public static singleDataFromPool(index0: number, index1: number, pool: Pool): PairData {\n        return new PairData(pool.tokens[index0], pool.tokens[index1], pool.address)\n    }\n\n    /**\n     * Pools with n > 2 tokens generate (n^2-n)/2 possible pair routes to trade\n     * The fubnction creates these pair routes\n     * @param pool input pool to generate pairs from\n     * @returns pair routes\n     */\n    public static dataFromPools(pools: Pool[]): PairData[] {\n        let pairData = []\n        for (let k = 0; k < pools.length; k++) {\n            const pool = pools[k]\n            for (let i = 0; i < pool.tokenBalances.length; i++) {\n                for (let j = 0; j < i; j++) {\n                    pairData.push(new PairData(pool.tokens[i], pool.tokens[j], pool.address))\n                }\n            }\n        }\n        return pairData\n    }\n\n    /**\n     * Converts unordered pair to directioned swap pair\n     * @param tokenIn in token, the other will be tokenOut\n     * @returns SwapData object\n     */\n    public toSwapDataFrom(tokenIn: Token): SwapData {\n        return new SwapData(tokenIn, this.token0.equals(tokenIn) ? this.token1 : this.token0, this.poolRef)\n    }\n\n    /**\n    * Converts unordered pair to directioned swap pair\n    * @param tokenIn in token, the other will be tokenOut\n    * @returns SwapData object\n    */\n    public toSwapDataTo(tokenOut: Token): SwapData {\n        return new SwapData(this.token0.equals(tokenOut) ? this.token1 : this.token0, tokenOut, this.poolRef)\n    }\n\n    /**\n     * Converts unordered swap pairs to swap route\n     * @param pairData input pair array - has to be a route to make sense\n     * @param tokenIn \n     * @returns \n     */\n    public static toSwapArrayFrom(pairData: PairData[], tokenIn: Token): SwapData[] {\n        let swaps = []\n        let currentIn = tokenIn\n        for (let i = 0; i < pairData.length; i++) {\n            const swap = pairData[i].toSwapDataFrom(currentIn)\n            swaps.push(swap)\n            currentIn = swap.tokenOut\n        }\n        return swaps\n    }\n\n    /**\n * Converts unordered swap pairs to swap route\n * @param pairData input pair array - has to be a route to make sense\n * @param tokenIn \n * @returns \n */\n    public static toSwapArrayTo(pairData: PairData[], tokenOut: Token): SwapData[] {\n        let swaps = new Array(pairData.length)\n        let currentOut = tokenOut\n        for (let i = pairData.length - 1; i >= 0; i--) {\n            const swap = pairData[i].toSwapDataTo(currentOut)\n            swaps[i] = swap\n            currentOut = swap.tokenIn\n        }\n        return swaps\n    }\n\n\n}","import { BigNumber } from 'ethers'\nimport { Token } from '../token';\nimport {  AmplifiedWeightedPair } from '../pools/weightedPair';\n\nconst ONE = BigNumber.from(1)\nconst TEN = BigNumber.from(10)\nconst TWO = BigNumber.from(2)\nconst SQRT2x100 = BigNumber.from('141421356237309504880');\nconst ONE_E18 = BigNumber.from('1000000000000000000')\n\n\nexport function sqrrt(a: BigNumber): BigNumber {\n    let c = ONE\n    if (a.gt(3)) {\n        c = a;\n        let b = a.div(TWO).add(ONE);\n        while (b < c) {\n            c = b;\n            b = (a.div(b).add(b)).div(TWO);\n        }\n    } else if (!a.eq(0)) {\n        c = ONE;\n    }\n    return c\n}\n\nexport function getTotalValue(pair: AmplifiedWeightedPair, payoutToken: Token): BigNumber {\n    const reserve0 = pair.reserve0\n    const reserve1 = pair.reserve1\n\n    const [reservesOther, weightPayoutToken, weightOther] = payoutToken.equals(pair.token0)\n        ? [reserve1, pair.weight0, pair.weight1]\n        : [reserve0, pair.weight1, pair.weight0]\n\n    return SQRT2x100.mul(reservesOther.toBigNumber()).div(\n        sqrrt(weightOther.mul(weightOther).add(weightPayoutToken.add(weightPayoutToken))\n        )).div(ONE_E18)\n}\n\n/**\n* - calculates the value in payoutToken of the input LP amount provided\n* @param _pair general pair that has the RequiemSwap interface implemented\n* @param amount_ the amount of LP to price in REQT\n*  - is consistent with the uniswapV2-type case \n*/\nexport function valuation(pair: AmplifiedWeightedPair, totalSupply: BigNumber, amount: BigNumber, payoutToken: Token) {\n    const totalValue = getTotalValue(pair, payoutToken);\n    return totalValue.mul(amount).div(totalSupply);\n}\n\n\n\n// markdown function for bond valuation\nexport function markdown(pair: AmplifiedWeightedPair, payoutToken: Token): BigNumber {\n    const [reservesOther, weightOther, weightPayoutToken] = payoutToken.equals(pair.token0)\n        ? [pair.reserve1.toBigNumber(), BigNumber.from(pair.weight1.toString()), BigNumber.from(pair.weight0.toString())]\n        : [pair.reserve0.toBigNumber(), BigNumber.from(pair.weight0.toString()), BigNumber.from(pair.weight1.toString())];\n\n    // adjusted markdown scaling up the reserve as the trading mechnism allows\n    // higher or lower valuation for payoutToken reserve\n    return reservesOther.add(\n        weightOther.mul(reservesOther).div(weightPayoutToken)).mul(\n            TEN.pow(BigNumber.from((payoutToken.decimals))).div(\n                getTotalValue(pair, payoutToken)\n            )\n        )\n}","\n\nimport { BigNumber } from 'ethers'\nimport invariant from 'tiny-invariant';\n\nconst RESOLUTION = BigNumber.from(112);\nconst resPrec = BigNumber.from(2).pow(RESOLUTION)\nconst ZERO = BigNumber.from(0)\n// const Q112 = BigNumber.from('0x10000000000000000000000000000');\n// const Q224 = BigNumber.from('0x100000000000000000000000000000000000000000000000000000000');\n// const LOWER_MASK = BigNumber.from('0xffffffffffffffffffffffffffff'); // decimal of UQ*x112 (lower 112 bits)\n\nexport function decode(x: BigNumber) {\n    return x.div(RESOLUTION);\n}\n\nexport function decode112with18(x: BigNumber) {\n    return x.div(BigNumber.from('5192296858534827'))\n}\n\nexport function fraction(numerator: BigNumber, denominator: BigNumber) {\n\n    invariant(denominator.gt(ZERO), \"FixedPoint::fraction: division by zero\");\n    if (numerator.isZero()) return ZERO;\n\n    // if (numerator.lte(BigNumber.) <= type(uint144).max) {\n    const result = (numerator.mul(resPrec)).div(denominator)\n    //   require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n    return result;\n    // } else {\n    //    return numerator.mul(Q112).div(denominator);\n    // }\n}","import { BigNumber } from 'ethers'\nimport { Token } from '../token';\nimport {  AmplifiedWeightedPair } from '../pools/weightedPair';\nimport { valuation } from './bondCalculator';\n// import JSBI from 'jsbi';\nimport { fraction, decode112with18 } from './fixedPoint';\n\nconst ONE_E16 = BigNumber.from('10000000000000000')\nconst ONE_E18 = BigNumber.from('10000000000000000')\nconst ONE_E9 = BigNumber.from('1000000000')\n\nexport interface BondTerms {\n    controlVariable: BigNumber; // scaling variable for price\n    vesting: BigNumber; // in blocks\n    maxPayout: BigNumber; // in thousandths of a %. i.e. 500 = 0.5%\n    maxDebt: BigNumber;\n}\n\nexport function payoutFor(value: BigNumber, bondPrice: BigNumber): BigNumber {\n    return value.mul(ONE_E18.mul(ONE_E18)).div(bondPrice).div(ONE_E18)\n}\n\n\nexport function fullPayoutFor(\n    pair: AmplifiedWeightedPair,\n    currentDebt: BigNumber,\n    totalSupply: BigNumber,\n    amount: BigNumber,\n    payoutToken: Token,\n    terms: BondTerms\n): BigNumber {\n    const value = valuation(pair, totalSupply, amount, payoutToken)\n    const bondPrice_ = bondPrice(terms.controlVariable, totalSupply, currentDebt)\n    return payoutFor(value, bondPrice_)\n}\n\n\n/**\n *  @notice calculate current ratio of debt to REQT supply\n *  @return debtRatio_ uint\n */\nexport function debtRatio(totalSupply: BigNumber, currentDebt: BigNumber): BigNumber {\n\n    return decode112with18(fraction(currentDebt.mul(ONE_E9), totalSupply)).div(\n        ONE_E18);\n}\n\n\n/**\n *  @notice calculate current bond premium\n *  @return price_ uint\n */\nexport function bondPrice(controlVariable: BigNumber, totalSupply: BigNumber, currentDebt: BigNumber): BigNumber {\n    let price_ = (controlVariable.mul(debtRatio(totalSupply, currentDebt)).add(ONE_E18)).div(ONE_E16);\n    return price_\n}\n\n\n/**\n *  @notice calculate current bond premium\n *  @return price_ uint\n */\nexport function bondPriceUsingDebtRatio(controlVariable: BigNumber, debtRatio: BigNumber): BigNumber {\n    return controlVariable.mul(debtRatio).div(ONE_E18);\n\n}\n\nexport function fullPayoutForUsingDebtRatio(\n    pair: AmplifiedWeightedPair,\n    debtRatio: BigNumber,\n    totalSupply: BigNumber,\n    amount: BigNumber,\n    payoutToken: Token,\n    terms: BondTerms\n): BigNumber {\n    const value = valuation(pair, totalSupply, amount, payoutToken)\n    const bondPrice_ = bondPriceUsingDebtRatio(terms.controlVariable, debtRatio)\n    return payoutFor(value, bondPrice_)\n}","import invariant from 'tiny-invariant'\nimport { Pool, PoolDictionary } from './pools/pool'\nimport { ChainId, Currency, NETWORK_CCY } from './currency'\nimport { Token, WRAPPED_NETWORK_TOKENS } from './token'\nimport { Price } from './fractions/price'\nimport { PairData } from './pools/pairData'\n\n\n/**\n * \n * @param pools pools to generate pairData with, i.e. a 3-Pool generating the respective 6 pairs\n * @returns an array of the pairData\n */\nexport function pairDataFromPools(pools: Pool[]): PairData[] {\n  let pairData = PairData.dataFromPool(pools[0])\n  for (let i = 1; i < pools.length; i++) {\n    pairData = pairData.concat(PairData.dataFromPool(pools[i]))\n  }\n\n  return pairData\n}\n\n// new version of the route \n// the first verion to include the stable pool for less friction\nexport class Route {\n  public readonly pairData: PairData[]\n  public readonly path: Token[]\n  public readonly input: Currency\n  public readonly output: Currency\n  public readonly midPrice: Price\n\n  public constructor(poolDict: PoolDictionary, pairData: PairData[], input: Currency, output?: Currency) {\n    invariant(pairData.length > 0, 'pairData')\n\n    invariant(\n      (input instanceof Token && pairData[0].involvesToken(input)) ||\n      (input === NETWORK_CCY[pairData[0].chainId] && pairData[0].involvesToken(WRAPPED_NETWORK_TOKENS[pairData[0].chainId])),\n      'INPUT'\n    )\n    invariant(\n      typeof output === 'undefined' ||\n      (output instanceof Token && pairData[pairData.length - 1].involvesToken(output)) ||\n      (output === NETWORK_CCY[pairData[0].chainId] && pairData[pairData.length - 1].involvesToken(WRAPPED_NETWORK_TOKENS[pairData[0].chainId])),\n      'OUTPUT'\n    )\n    const path: Token[] = [input instanceof Token ? input : WRAPPED_NETWORK_TOKENS[pairData[0].chainId]]\n    for (const [i, pool] of pairData.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pool.token0) || currentInput.equals(pool.token1), 'PATH')\n      const output = currentInput.equals(pool.token0) ? pool.token1 : pool.token0\n      path.push(output)\n    }\n\n    this.pairData = pairData\n    this.path = path\n    this.midPrice = Price.fromRoute(this, poolDict)\n    this.input = input\n    this.output = output ?? path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.pairData[0].chainId\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { ONE, ZERO } from '../constants'\n// import { sortedInsert } from '../helperUtils'\nimport { ChainId, NETWORK_CCY } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount, InputOutput } from './fractions/tokenAmount'\nimport { currencyEquals, WRAPPED_NETWORK_TOKENS } from './token'\nimport {\n  PoolDictionary\n} from './pools/pool'\nimport { SwapRoute } from './swapRoute'\nimport * as _ from \"lodash\";\n// import { SwapRoute } from './swapRoute'\n// import { SwapData } from './pools/swapData'\n\nexport enum SwapType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\n// function computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n//   const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n//   // calculate slippage := (exactQuote - outputAmount) / exactQuote\n//   const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n//   return new Percent(slippage.numerator, slippage.denominator)\n// }\n\n// function computePriceImpactWeightedPair(pair: WeightedPair, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n//   const artificialMidPrice = new Price(\n//     inputAmount.currency,\n//     outputAmount.currency,\n//     pair.reserveOf(wrappedCurrency(inputAmount.currency, pair.chainId)).raw,\n//     pair.reserveOf(wrappedCurrency(outputAmount.currency, pair.chainId)).raw)\n//   const exactQuote = artificialMidPrice.raw.multiply(inputAmount.raw)\n//   // calculate slippage := (exactQuote - outputAmount) / exactQuote\n//   const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n//   return new Percent(slippage.numerator, slippage.denominator)\n// }\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Swap, b: Swap) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // // consider lowest slippage next, since these are less likely to fail\n  // if (a.priceImpact.lessThan(b.priceImpact)) {\n  //   return -1\n  // } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n  //   return 1\n  // }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === NETWORK_CCY[chainId]) return new TokenAmount(WRAPPED_NETWORK_TOKENS[chainId], currencyAmount.raw)\n  invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Swap {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: SwapRoute\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: SwapType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly swapAmounts: TokenAmount[]\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: TokenAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: TokenAmount\n\n  public readonly isValid: boolean\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  // public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: SwapRoute, amountIn: TokenAmount, poolDict: PoolDictionary): Swap {\n    return new Swap(route, amountIn, SwapType.EXACT_INPUT, poolDict)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: SwapRoute, amountOut: TokenAmount, poolDict: PoolDictionary): Swap {\n    return new Swap(route, amountOut, SwapType.EXACT_OUTPUT, poolDict)\n  }\n\n  public constructor(route: SwapRoute, amount: TokenAmount, tradeType: SwapType, poolDict: PoolDictionary) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    let _isValid = true\n    if (tradeType === SwapType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      let poolDictCopy: PoolDictionary = _.cloneDeep(poolDict);\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.swapData[i]\n        try {\n          const outputAmount = pair.calculateSwapGivenIn(amounts[i], poolDictCopy);\n          // clone pool and adjust it for the swapped amount\n          const pool = _.cloneDeep(poolDictCopy[pair.poolRef]);\n          pool.adjustForSwap(amounts[i], outputAmount)\n          // assign to cloned pool\n          poolDictCopy[pair.poolRef] = pool;\n          amounts[i + 1] = outputAmount;\n        } catch {\n          _isValid = false\n          break;\n        }\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      let poolDictCopy: PoolDictionary = _.cloneDeep(poolDict);\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.swapData[i - 1]\n        try {\n          const inputAmount = pair.calculateSwapGivenOut(amounts[i], poolDictCopy)\n          // clone pool and adjust it for the swapped amount\n          const pool = _.cloneDeep(poolDictCopy[pair.poolRef]);\n          pool.adjustForSwap(inputAmount, amounts[i])\n          // assign to cloned pool\n          poolDictCopy[pair.poolRef] = pool;\n          amounts[i - 1] = inputAmount\n        } catch {\n          _isValid = false\n          break;\n        }\n      }\n    }\n    this.isValid = _isValid\n    this.route = route\n    this.tradeType = tradeType\n    this.swapAmounts = amounts\n    if (this.isValid) {\n      this.inputAmount = tradeType === SwapType.EXACT_INPUT ? amount : amounts[0]\n      this.outputAmount = tradeType === SwapType.EXACT_OUTPUT ? amount : amounts[amounts.length - 1]\n    } else { // default\n      this.inputAmount = tradeType === SwapType.EXACT_INPUT ? amount : new TokenAmount(this.route.swapData[0].tokenIn, '0')\n      this.outputAmount = tradeType === SwapType.EXACT_OUTPUT ? amount : new TokenAmount(this.route.swapData[this.route.swapData.length - 1].tokenIn, '0')\n    }\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    // this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): TokenAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === SwapType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): TokenAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === SwapType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n    }\n  }\n  /**\n   * \n   * @param swapRoutes input routes - should already not include duplicates\n   * @param swapType determines in which direction the swap will be calculated\n   * @param poolDict dictionary used to price the trade routes\n   * @returns trades in an array\n   */\n  public static PriceRoutes(swapRoutes: SwapRoute[], amount: TokenAmount, swapType: SwapType, poolDict: PoolDictionary): Swap[] {\n    const swaps: Swap[] = []\n    for (let i = 0; i < swapRoutes.length; i++) {\n      const swap = new Swap(swapRoutes[i], amount, swapType, poolDict)\n      if (swap.isValid)\n        swaps.push(swap)\n    }\n    if (swapType === SwapType.EXACT_INPUT)\n      return swaps.sort((a, b) => (a.outputAmount.raw.lt(b.outputAmount.raw) ? 1 : -1))\n    else\n      return swaps.sort((a, b) => (a.inputAmount.raw.lt(b.inputAmount.raw)) ? 1 : -1)\n  }\n\n}\n\n\n\n\n\n\n\n","import { ChainId } from './currency'\nimport { Token } from './token'\nimport { SwapData } from './pools/swapData'\n\n\n\n// new version of the route \n// the first verion to include the stable pool for less friction\nexport class SwapRoute {\n  public readonly swapData: SwapData[]\n  public readonly path: Token[]\n  public readonly input: Token\n  public readonly output: Token\n  public readonly identifier: string\n  // public readonly midPrice: Price\n\n  public constructor(swapData: SwapData[]) {\n\n    const path: Token[] = [swapData[0].tokenIn]\n\n    // it can happen that the pool is traded through consecutively, we want to remove this case \n    const swapDataAggregated = []\n    for (let i = 0; i < swapData.length; i++) {\n      let currentSwap = swapData[i]\n      const tokenIn = currentSwap.tokenIn\n      let relevantOut = currentSwap.tokenOut\n      for (let j = i + 1; j < swapData.length; j++) {\n        if (swapData[j].poolRef === currentSwap.poolRef) {\n          currentSwap = swapData[j]\n          relevantOut = currentSwap.tokenOut\n          i++\n        } else {\n          break;\n        }\n      }\n      const swap = new SwapData(tokenIn, relevantOut, currentSwap.poolRef)\n      swapDataAggregated.push(swap)\n      // const currentInput = path[i]\n      // invariant(currentInput.equals(currentSwap.tokenIn), 'PATH')\n      const output = currentSwap.tokenOut\n      path.push(output)\n    }\n\n\n    this.swapData = swapDataAggregated\n\n    this.identifier = swapDataAggregated.map(x => x.poolRef).join('') + path.map(p => p.address).join('')\n    this.path = path\n    // this.midPrice = Price.fromRoute(this, poolDict)\n    this.input = path[0]\n    this.output = path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.swapData[0].chainId\n  }\n\n  public equals(otherRoute: SwapRoute): boolean {\n    for (let i = 0; i < this.swapData.length; i++) {\n      if (!this.swapData[i].tokenIn.equals(otherRoute.swapData[i].tokenIn) && !this.swapData[i].tokenOut.equals(otherRoute.swapData[i].tokenOut) && !(this.swapData[i].poolRef === otherRoute.swapData[i].poolRef))\n        return false\n    }\n    return true\n  }\n\n  public static cleanRoutes(swapRoutes: SwapRoute[]): SwapRoute[] {\n    var routeIds: string[] = []\n    var routes: SwapRoute[] = []\n    for (var i = 0; i < swapRoutes.length; i++) {\n      if (!routeIds.includes(swapRoutes[i].identifier)) {\n        routeIds.push(swapRoutes[i].identifier)\n        routes.push(swapRoutes[i])\n      }\n    }\n    return routes\n  }\n\n}\n","\n\n// import { SwapData } from \"entities/pools/SwapData\";\n// import { BigNumber } from \"ethers\";\n// import { Pool, PoolDictionary, PoolHops, Token, ZERO } from \".\";\n\nimport { PairData } from \"./entities/pools/pairData\"\nimport { SwapData } from \"./entities/pools/swapData\"\nimport { SwapRoute } from \"./entities/swapRoute\"\nimport invariant from \"tiny-invariant\"\nimport { ChainId, Currency, NETWORK_CCY, Token, WRAPPED_NETWORK_TOKENS } from \"./entities\"\n\n\nexport function wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n    if (currency instanceof Token) return currency\n    if (currency === NETWORK_CCY[chainId]) return WRAPPED_NETWORK_TOKENS[chainId]\n    invariant(false, 'CURRENCY')\n  }\n\nexport class RouteProvider {\n\n  /**\n  * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n  * amount to an output token, making at most `maxHops` hops.\n  * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n  * the amount in among multiple routes.\n  * @param pairs the pairs to consider in finding the best trade\n  * @param currencyAmountIn exact amount of input currency to spend\n  * @param currencyOut the desired currency out\n  * @param maxNumResults maximum number of results to return\n  * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n  * @param currentPairs used in recursion; the current list of pairs\n  * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n  * @param bestTrades used in recursion; the current list of best trades\n  */\n   public static getRouteIteration(\n    pairData: PairData[],\n    tokenIn: Token,\n    tokenOut: Token,\n    maxHops = 3,\n    // used in recursion.\n    lastPool:string='',\n    currentpools: SwapData[] = [],\n    originalCurrencyIn: Token = tokenIn,\n    bestRoutes: SwapRoute[] = []\n  ): SwapRoute[] {\n    invariant(pairData.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalCurrencyIn === tokenIn || currentpools.length > 0, 'INVALID_RECURSION')\nconst relevantPairs = pairData.filter(p=>p.poolRef !== lastPool)\n    for (let i = 0; i < relevantPairs.length; i++) {\n      let pair = relevantPairs[i]\n      // filters for valid connection\n      const inIs0 = pair.token0.equals(tokenIn)\n      if (!inIs0 && !pair.token1.equals(tokenIn)) continue;\n      \n      const tokenOutNew: Token = inIs0 ? pair.token1 : pair.token0\n      \n      let swap:SwapData\n      // const lastSwap:SwapData = currentpools[currentpools.length -1]\n\n      // if(lastSwap?.poolRef === pair.poolRef)\n      // {\n        // swap =  new SwapData(lastSwap.tokenIn, tokenOutNew, pair.poolRef)\n      //   currentpools.splice(currentpools.length -1,1)\n      // } else\n      // {\n        swap = new SwapData(tokenIn, tokenOutNew, pair.poolRef)\n      // }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (tokenOutNew.equals(tokenOut)) {\n        bestRoutes.push(new SwapRoute([...currentpools, swap]))\n      } else if (maxHops > 1 && relevantPairs.length > 1) {\n        // const poolsExcludingThispool = pairData.slice(0, i).concat(pairData.slice(i + 1, pairData.length)) // pairData.filter(data => data.poolRef !== pair.poolRef)\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        RouteProvider.getRouteIteration(\n          // poolsExcludingThispool,\n          pairData,\n          tokenOutNew,\n          tokenOut,\n          maxHops - 1,\n          pair.poolRef,\n          [...currentpools, swap],\n          originalCurrencyIn,\n          bestRoutes\n        )\n      }\n\n    }\n    return bestRoutes\n  }\n\n  public static getRoutes(\n    pairData: PairData[],\n    currencyIn: Token,\n    currencyOut: Token,\n    maxHops = 3\n  ): SwapRoute[] {\n    return this.getRouteIteration(\n      pairData,\n      currencyIn,\n      currencyOut,\n      maxHops,\n      '',\n      [],\n      currencyIn,\n      []\n    )\n  }\n}\n\n\n// export enum SwapTypes {\n//     SwapExactIn,\n//     SwapExactOut,\n// }\n\n// export interface SwapOptions {\n//     gasPrice: BigNumber;\n//     swapGas: BigNumber;\n//     timestamp: number;\n//     maxPools: number;\n//     poolTypeFilter: PoolFilter;\n//     forceRefresh: boolean;\n// }\n\n\n// export enum PoolFilter {\n//     All = 'All',\n//     Weighted = 'Weighted',\n//     Stable = 'Stable',\n//     MetaStable = 'MetaStable',\n//     LBP = 'LiquidityBootstrapping',\n//     Investment = 'Investment',\n//     Element = 'Element',\n//     AaveLinear = 'AaveLinear',\n//     StablePhantom = 'StablePhantom',\n//     ERC4626Linear = 'ERC4626Linear',\n// }\n\n\n// /*\n// The purpose of this function is to build dictionaries of direct pools \n// and plausible hop pools.\n// */\n// export function filterPoolsOfInterest(\n//     allPools: PoolDictionary,\n//     tokenIn: Token,\n//     tokenOut: Token,\n//     maxPools: number\n// ): [PoolDictionary, PoolHops, PoolHops] {\n//     const directPools: PoolDictionary = {};\n//     const hopsIn: PoolHops = {};\n//     const hopsOut: PoolHops = {};\n\n//     Object.keys(allPools).forEach((id) => {\n//         const pool = allPools[id];\n//         const tokenListSet = new Set(pool.tokens);\n//         const containsTokenIn = tokenListSet.has(tokenIn);\n//         const containsTokenOut = tokenListSet.has(tokenOut);\n\n//         // This is a direct pool as has both tokenIn and tokenOut\n//         if (containsTokenIn && containsTokenOut) {\n//             directPools[pool.address] = pool;\n//             return;\n//         }\n\n//         if (maxPools > 1) {\n//             if (containsTokenIn && !containsTokenOut) {\n//                 for (const hopToken of tokenListSet) {\n//                     if (!hopsIn[hopToken.address]) hopsIn[hopToken.address] = new Set([]);\n//                     hopsIn[hopToken.address].add(pool.address);\n//                 }\n//             } else if (!containsTokenIn && containsTokenOut) {\n//                 for (const hopToken of [...tokenListSet]) {\n//                     if (!hopsOut[hopToken.address]) hopsOut[hopToken.address] = new Set([]);\n//                     hopsOut[hopToken.address].add(pool.address);\n//                 }\n//             }\n//         }\n//     });\n//     return [directPools, hopsIn, hopsOut];\n// }\n\n\n\n// export function searchConnectionsTo(\n//     token: Token,\n//     poolsDict: { [id: string]: Pool },\n//     toToken: Token\n//   ): Path[] {\n//     // this assumes that every pool in poolsDict contains toToken\n//     const connections: Path[] = [];\n//     for (const id in poolsDict) {\n//       const pool = poolsDict[id];\n//       if (pool.involvesToken(token)) {\n//         const connection = createPath([token, toToken], [pool]);\n//         connections.push(connection);\n//       }\n//     }\n//     return connections;\n//   }\n  \n//   export interface Path {\n//     id: string; // pool address if direct path, contactenation of pool addresses if multihop\n//     swaps: Swap[];\n//   }\n  \n//   export interface Swap {\n//     pool: string;\n//     tokenIn: Token;\n//     tokenOut: Token;\n//     swapAmount?: BigNumber;\n//   }\n  \n//   // Creates a path with pools.length hops\n//   // i.e. tokens[0]>[Pool0]>tokens[1]>[Pool1]>tokens[2]>[Pool2]>tokens[3]\n//   export function createPath(tokens: Token[], pools: Pool[]): Path {\n//     let tI: Token, tO: Token;\n//     const swaps: Swap[] = [];\n//     // const poolPairData: PairData[] = [];\n//     let id = '';\n  \n//     for (let i = 0; i < pools.length; i++) {\n//       tI = tokens[i];\n//       tO = tokens[i + 1];\n//       // const poolPair = pools[i].parsePoolPairData(tI, tO);\n//       // poolPairData.push(poolPair);\n  \n//       const swap: Swap = {\n//         pool: pools[i].address,\n//         tokenIn: tI,\n//         tokenOut: tO,\n//       };\n  \n//       swaps.push(swap);\n//     }\n  \n//     const path: Path = {\n//       id,\n//       swaps,\n//     };\n  \n//     return path;\n//   }\n  \n  \n  \n\n\n// export function producePaths(\n//     tokenIn: Token,\n//     tokenOut: Token,\n//     directPools: PoolDictionary,\n//     hopsIn: PoolHops,\n//     hopsOut: PoolHops,\n//     pools: PoolDictionary\n// ): Path[] {\n//     const paths: Path[] = [];\n\n//     // Create direct paths\n//     for (const id in directPools) {\n//         const path = createPath([tokenIn, tokenOut], [pools[id]]);\n//         paths.push(path);\n//     }\n\n//     for (const hopToken in hopsIn) {\n//         if (hopsOut[hopToken]) {\n//             let highestNormalizedLiquidityFirst = ZERO; // Aux variable to find pool with most liquidity for pair (tokenIn -> hopToken)\n//             let highestNormalizedLiquidityFirstPoolId: string | undefined; // Aux variable to find pool with most liquidity for pair (tokenIn -> hopToken)\n//             let highestNormalizedLiquiditySecond = ZERO; // Aux variable to find pool with most liquidity for pair (hopToken -> tokenOut)\n//             let highestNormalizedLiquiditySecondPoolId: string | undefined; // Aux variable to find pool with most liquidity for pair (hopToken -> tokenOut)\n//             for (const poolInId of [...hopsIn[hopToken]]) {\n//                 const poolIn = pools[poolInId.address];\n//                 const poolPairData = SwapData.singleDataFromPool(\n//                     tokenIn,\n//                     hopToken,\n//                     poolIn\n//                 );\n     \n//                 // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n//                 if (\n//                     normalizedLiquidity.isGreaterThanOrEqualTo(\n//                         highestNormalizedLiquidityFirst\n//                     )\n//                 ) {\n//                     highestNormalizedLiquidityFirst = normalizedLiquidity;\n//                     highestNormalizedLiquidityFirstPoolId = poolIn.id;\n//                 }\n//             }\n//             for (const poolOutId of [...hopsOut[hopToken]]) {\n//                 const poolOut = pools[poolOutId.address];\n//                 const poolPairData = poolOut.parsePoolPairData(\n//                     hopToken,\n//                     tokenOut\n//                 );\n//                 const normalizedLiquidity =\n//                     poolOut.getNormalizedLiquidity(poolPairData);\n//                 // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n//                 if (\n//                     normalizedLiquidity.isGreaterThanOrEqualTo(\n//                         highestNormalizedLiquiditySecond\n//                     )\n//                 ) {\n//                     highestNormalizedLiquiditySecond = normalizedLiquidity;\n//                     highestNormalizedLiquiditySecondPoolId = poolOut.address;\n//                 }\n//             }\n//             if (\n//                 highestNormalizedLiquidityFirstPoolId &&\n//                 highestNormalizedLiquiditySecondPoolId\n//             ) {\n//                 const path = createPath(\n//                     [tokenIn, hopToken, tokenOut],\n//                     [\n//                         pools[highestNormalizedLiquidityFirstPoolId],\n//                         pools[highestNormalizedLiquiditySecondPoolId],\n//                     ]\n//                 );\n//                 paths.push(path);\n//             }\n//         }\n//     }\n//     return paths;\n// }\n\n\n// export class RouteProvider {\n//     cache: Record<string, { paths: Path[] }> = {};\n\n//     // constructor(private readonly config: SorConfig) {}\n\n//     /**\n//      * Given a list of pools and a desired input/output, returns a set of possible paths to route through\n//      */\n//     getCandidatePaths(\n//         tokenIn: Token,\n//         tokenOut: Token,\n//         swapType: SwapTypes,\n//         poolsAllDict: PoolDictionary,\n//         swapOptions: SwapOptions\n//     ): Path[] {\n//         if (!poolsAllDict) return [];\n\n//         // If token pair has been processed before that info can be reused to speed up execution\n//         const cache =\n//             this.cache[\n//             `${tokenIn.address}${tokenOut.address}${swapType}${swapOptions.timestamp}`\n//             ];\n\n//         // forceRefresh can be set to force fresh processing of paths/prices\n//         if (!swapOptions.forceRefresh && !!cache) {\n//             // Using pre-processed data from cache\n//             return cache.paths;\n//         }\n\n//         const [directPools, hopsIn, hopsOut] = filterPoolsOfInterest(\n//             poolsAllDict,\n//             tokenIn,\n//             tokenOut,\n//             swapOptions.maxPools\n//         );\n\n//         const pathData = producePaths(\n//             tokenIn,\n//             tokenOut,\n//             directPools,\n//             hopsIn,\n//             hopsOut,\n//             poolsAllDict\n//         );\n\n//         const boostedPaths = getBoostedPaths(\n//             tokenIn,\n//             tokenOut,\n//             poolsAllDict,\n//             this.config\n//         );\n\n//         const pathsUsingStaBal = getPathsUsingStaBalPool(\n//             tokenIn,\n//             tokenOut,\n//             poolsAllDict,\n//             poolsAllDict,\n//             this.config\n//         );\n\n//         const combinedPathData = pathData\n//             .concat(...boostedPaths)\n//             .concat(...pathsUsingStaBal);\n//         const [paths] = calculatePathLimits(combinedPathData, swapType);\n\n//         this.cache[`${tokenIn}${tokenOut}${swapType}${swapOptions.timestamp}`] =\n//         {\n//             paths: paths,\n//         };\n\n//         return paths;\n//     }\n\n//     /**\n//      * Given a pool dictionary and a desired input/output, returns a set of possible paths to route through.\n//      * @param {string} tokenIn - Address of tokenIn\n//      * @param {string} tokenOut - Address of tokenOut\n//      * @param {SwapTypes} swapType - SwapExactIn where the amount of tokens in (sent to the Pool) is known or SwapExactOut where the amount of tokens out (received from the Pool) is known.\n//      * @param {PoolDictionary} poolsAllDict - Dictionary of pools.\n//      * @param {number }maxPools - Maximum number of pools to hop through.\n//      * @returns {NewPath[]} Array of possible paths sorted by liquidity.\n//      */\n//     getCandidatePathsFromDict(\n//         tokenIn: string,\n//         tokenOut: string,\n//         swapType: SwapTypes,\n//         poolsAllDict: PoolDictionary,\n//         maxPools: number\n//     ): NewPath[] {\n//         if (Object.keys(poolsAllDict).length === 0) return [];\n\n//         const [directPools, hopsIn, hopsOut] = filterPoolsOfInterest(\n//             poolsAllDict,\n//             tokenIn,\n//             tokenOut,\n//             maxPools\n//         );\n\n//         const pathData = producePaths(\n//             tokenIn,\n//             tokenOut,\n//             directPools,\n//             hopsIn,\n//             hopsOut,\n//             poolsAllDict\n//         );\n\n//         const boostedPaths = getBoostedPaths(\n//             tokenIn,\n//             tokenOut,\n//             poolsAllDict,\n//             this.config\n//         );\n\n//         const combinedPathData = pathData.concat(...boostedPaths);\n//         const [paths] = calculatePathLimits(combinedPathData, swapType);\n//         return paths;\n//     }\n// }\n","\nimport invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from './helperUtils'\nimport { CurrencyAmount, Percent, Swap, SwapType } from './entities'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n\n  /**\n   * Whether we swap through multiple routers / pair types\n   */\n  multiSwap?: boolean\n\n  /**\n   * Checks whether the networkccy is used in in- or output: helps us to avoid checks in route calculations\n   */\n  etherIn: boolean\n  etherOut: boolean\n}\n\nexport interface SwapOptionsDeadline extends Omit<SwapOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[] | string[][])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount) {\n  return currencyAmount.raw.toHexString()\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Router, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() { }\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(trade: Swap, options: SwapOptions | SwapOptionsDeadline): SwapParameters {\n    const etherIn = options.etherIn\n    const etherOut = options.etherOut\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n\n\n    let methodName: string\n\n    let args: (string | string[] | string[][])[] = []\n    let value: string\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    if (!options.multiSwap) {\n      const path: string[] = trade.route.path.map((token) => token.address)\n      const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n      switch (trade.tradeType) {\n        case SwapType.EXACT_INPUT:\n          if (etherIn) {\n            methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n            // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n            args = [amountOut, path, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n            // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n            args = [amountIn, amountOut, path, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = useFeeOnTransfer\n              ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n              : 'swapExactTokensForTokens'\n            // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n            args = [amountIn, amountOut, path, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n        case SwapType.EXACT_OUTPUT:\n          invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n          if (etherIn) {\n            methodName = 'swapETHForExactTokens'\n            // (uint amountOut, address[] calldata path, address to, uint deadline)\n            args = [amountOut, path, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = 'swapTokensForExactETH'\n            // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n            args = [amountOut, amountIn, path, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = 'swapTokensForExactTokens'\n            // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n            args = [amountOut, amountIn, path, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n      }\n    } else {\n      const path = trade.route.path.map(token => token.address)\n      const pairData = trade.route.swapData.map(p => p.poolRef)\n\n      switch (trade.tradeType) {\n        case SwapType.EXACT_INPUT:\n          if (etherIn) {\n            methodName = 'onSwapExactETHForTokens'\n            // function multiSwapExactETHForTokens( address[][] calldata path, uint256[] memory routerId,\n            // uint256 amountOutMin, uint256 deadline )\n            args = [pairData, path, amountOut, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = 'onSwapExactTokensForETH'\n            // multiSwapExactTokensForETH( address[][] calldata path, uint256[] memory pools, uint256 amountIn,\n            // uint256 amountOutMin, uint256 deadline )\n            args = [pairData, path, amountIn, amountOut, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = 'onSwapExactTokensForTokens'\n            // function onSwapExactTokensForTokens(\n            //   address[] memory pools,\n            //   address[] memory tokens,\n            //   uint256 amountIn,\n            //   uint256 amountOutMin,\n            //   address to,\n            //   uint256 deadline\n            args = [pairData, path, amountIn, amountOut, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n        case SwapType.EXACT_OUTPUT:\n          if (etherIn) {\n            methodName = 'onSwapETHForExactTokens'\n            // multiSwapETHForExactTokens( address[][] calldata path, uint256[] memory pools, uint256 amountOut, uint256 deadline )\n            args = [pairData, path, amountOut, to, deadline]\n            value = amountIn\n          } else if (etherOut) {\n            methodName = 'onSwapTokensForExactETH'\n            // multiSwapTokensForExactETH( address[][] calldata path, uint256[] memory pools,\n            // uint256 amountOut, uint256 amountInMax, uint256 deadline )\n            args = [pairData, path, amountOut, amountIn, to, deadline]\n            value = ZERO_HEX\n          } else {\n            methodName = 'onSwapTokensForExactTokens'\n            // multiSwapTokensForExactTokens( address[][] calldata path, uint256[] memory pools, \n            // uint256 amountOut, uint256 amountInMax,  uint256 deadline )\n            args = [pairData, path, amountOut, amountIn, to, deadline]\n            value = ZERO_HEX\n          }\n          break\n      }\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n"],"names":["TradeType","SolidityType","FACTORY_ADDRESS","56","97","80001","43113","STABLE_POOL_ADDRESS","42261","110001","MINIMUM_LIQUIDITY","BigNumber","from","ZERO","ONE","TWO","THREE","FIVE","TEN","TENK","_100","SOLIDITY_TYPE_MAXIMA","uint8","uint256","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","_this","name","constructor","setPrototypeOf","prototype","_inheritsLoose","Error","InsufficientInputAmountError","_this2","validateSolidityTypeInstance","value","solidityType","gte","invariant","lte","validateAndParseAddress","address","getAddress","error","parseBigintIsh","bigintIsh","toString","sqrt","y","x","z","gt","div","add","lt","eq","ChainId","Currency","chainId","decimals","symbol","this","NETWORK_CCY","BSC_MAINNET","BSC_TESTNET","ARBITRUM_MAINNET","ARBITRUM_TETSNET_RINKEBY","AVAX_MAINNET","AVAX_TESTNET","MATIC_MAINNET","MATIC_TESTNET","OASIS_MAINNET","OASIS_TESTNET","QUARKCHAIN_DEV_S0","Token","projectLink","_proto","equals","other","sortsBefore","toLowerCase","currencyEquals","currencyA","currencyB","Rounding","WETH","WRAPPED_NETWORK_TOKENS","STABLECOINS","0","STABLES_INDEX_MAP","1","2","3","STABLES_LP_TOKEN","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","numerator","denominator","invert","otherParsed","mul","subtract","sub","lessThan","equalTo","greaterThan","multiply","divide","toSignificant","significantDigits","format","rounding","groupSeparator","Number","isInteger","set","precision","quotient","toSignificantDigits","decimalPlaces","toFixed","DP","RM","_createClass","key","get","mod","_100_PERCENT","Percent","CurrencyAmount","currency","amount","parsedAmount","pow","networkCCYAmount","raw","toExact","toBigNumber","TokenAmount","token","Price","baseCurrency","quoteCurrency","scalar","fromRoute","route","poolDict","prices","pairData","entries","i","price","poolPrice","path","push","slice","reduce","accumulator","currentValue","fraction","quote","currencyAmount","_Fraction","adjusted","ONE_18","ONE_20","ONE_36","LN_36_LOWER_BOUND","LN_36_UPPER_BOUND","x0","a0","x1","a1","x2","a2","x3","a3","x4","a4","x5","a5","x6","a6","x7","a7","x8","a8","x9","a9","x10","a10","x11","a11","logx_times_y","x_int256","y_int256","ln_36_x","_ln_36","_ln","exp","firstAN","product","term","seriesSum","a","sum","z_squared","num","MAX_POW_RELATIVE_ERROR","MIN_POW_BASE_FREE_EXPONENT","mulDown","b","mulUp","divDown","divUp","powDown","maxError","powUp","complement","max","_MAX_IN_RATIO","_MAX_OUT_RATIO","_MAX_INVARIANT_RATIO","_MIN_INVARIANT_RATIO","_calcOutGivenIn","balanceIn","weightIn","balanceOut","weightOut","amountIn","_calcInGivenOut","amountOut","_calcLpOutGivenExactTokensIn","balances","normalizedWeights","amountsIn","lpTotalSupply","swapFeePercentage","balanceRatiosWithFee","invariantRatioWithFees","length","_computeJoinExactTokensInInvariantRatio","invariantRatio","swapFees","lpOut","amountInWithoutFee","nonTaxableAmount","taxableAmount","swapFee","_calcAllTokensInGivenExactLpOut","lpAmountOut","totalBPT","lpRatio","_calcLpInGivenExactTokensOut","amountsOut","balanceRatiosWithoutFee","Array","invariantRatioWithoutFees","_computeExitExactTokensOutInvariantRatio","lpIn","amountOutWithFee","taxableAmountPlusFees","_calcTokenOutGivenExactLpIn","balance","normalizedWeight","lpAmountIn","amountOutWithoutFee","FEE_DENOMINATOR","calculateRemoveLiquidityOneTokenExactIn","self","outIndex","lpAmount","lpSupply","tokenBalances","tokenMultipliers","fee","calculateRemoveLiquidityExactIn","_xp","calculateTokenAmount","amounts","deposit","calculateSwapGivenIn","inIndex","amountInWithFee","calculateSwapGivenOut","rates","result","_256","_128","FIXED_1","FIXED_2","MAX_NUM","LN2_NUMERATOR","LN2_DENOMINATOR","OPT_LOG_MAX_VAL","OPT_EXP_MAX_VAL","maxExpArray","leftShift","shift","signedRightShift","power","_baseN","_baseD","_expN","_expD","base","baseLogTimesExp","optimalLog","generalLog","optimalExp","findPositionInMaxExpArray","generalExp","res","count","_n","s","or","floorLog2","w","and","isZero","_x","_precision","xi","lo","hi","mid","getAmountOut","reserveIn","reserveOut","tokenWeightIn","tokenWeightOut","temp1","temp2","getAmountIn","baseD","baseReserveIn","PoolType","WeightedSwapStorage","adminFee","mock","StableSwapStorage","initialA","futureA","initialATime","futureATime","lpAddress","dummy","Pool","involvesToken","keys","tokens","tokenFromIndex","index","indexFromToken","getBalances","map","_","reserveOf","setBalanceValueByIndex","newBalance","getTokenAmounts","t","setTokenBalances","subtractBalanceValue","tokenAmount","newBalances","_name","PAIR_ADDRESS_CACHE","PAIR_HASH","AmplifiedWeightedPair","virtualReserves","weightA","amp","ampBPS","weights","liquidityToken","ethers","utils","type","token0","token1","weight0","join","tokenA","tokenB","undefined","_PAIR_ADDRESS_CACHE2","_PAIR_ADDRESS_CACHE3","_PAIR_ADDRESS_CACHE3$","getCreate2Address","keccak256","pack","fromBigIntish","getAddressForRouter","tokenIn","token0Price","token1Price","poolPriceBases","priceBaseIn","priceBaseOut","priceOf","reserve0","reserve1","virtualReserveOf","virtualReserve0","virtualReserve1","weightOf","weight1","getLiquidityMinted","totalSupply","tokenAmountA","tokenAmountB","liquidity","tokenAmounts","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","priceRatioOf","token0PriceRaw","token1PriceRaw","tokenOut","inAmount","outAmount","outputReserve","inputReserve","outputWeight","getOutputAmount","inputAmount","inputWeight","outputAmount","getInputAmount","console","log","adjustForSwap","clone","fee0","WeightedPool","poolAddress","swapStorage","values","constants","AddressZero","calculateSwapViaPing","inToken","outToken","provider","Contract","Interface","weightedPoolABI","swap","toBigInt","calculateRemoveLiquidity","amountLp","calculateRemoveLiquidityOneToken","getLiquidityAmount","userBalances","setSwapStorage","setLpTotalSupply","setBalanceValue","addBalanceValue","A_PRECISION","_getAPrecise","blockTimestamp","_distance","_getD","xp","nCoins","_sumOf","Dprev","D","Ann","D_P","j","_getY","inBalance","normalizedBalances","c","_getYD","A","StablePool","_A","currentWithdrawFee","StableSwap","calculateSwap","outBalance","_fee","_amountOutInclFee","feeAdjustedAmount","_calculateRemoveLiquidity","D0","D1","newY","reducedXP","_feePerToken","expectedDx","dy","_calculateRemoveLiquidityOneToken","_calculateTokenAmount","setBlockTimestamp","toNumber","virtualIn","feeToSet","SwapData","poolRef","pool","tokenOutAmount","tokenInAmount","calculateSwapGivenOutAmendingPool","refPool","assign","calculateSwapGivenInAmendingPool","singleDataFromPool","includes","data","fetchPoolPrice","setPool","PairData","dataFromPool","index0","index1","dataFromPools","pools","k","toSwapDataFrom","toSwapDataTo","toSwapArrayFrom","swaps","currentIn","toSwapArrayTo","currentOut","SQRT2x100","ONE_E18","sqrrt","getTotalValue","pair","payoutToken","weightPayoutToken","weightOther","valuation","RESOLUTION","resPrec","decode112with18","ONE_E16","ONE_E9","payoutFor","bondPrice","debtRatio","currentDebt","controlVariable","bondPriceUsingDebtRatio","SwapType","Route","input","output","currentInput","midPrice","inputOutputComparator","wrappedAmount","Swap","tradeType","_isValid","EXACT_INPUT","poolDictCopy","swapData","isValid","swapAmounts","EXACT_OUTPUT","executionPrice","exactIn","exactOut","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","PriceRoutes","swapRoutes","swapType","sort","SwapRoute","swapDataAggregated","currentSwap","relevantOut","identifier","p","otherRoute","cleanRoutes","routeIds","routes","RouteProvider","getRouteIteration","maxHops","lastPool","currentpools","originalCurrencyIn","bestRoutes","relevantPairs","filter","inIs0","tokenOutNew","getRoutes","currencyIn","currencyOut","toHex","toHexString","SwapRouter","swapCallParameters","trade","options","etherIn","etherOut","ttl","methodName","to","recipient","allowedSlippage","args","deadline","Math","floor","Date","getTime","multiSwap","useFeeOnTransfer","Boolean","feeOnTransfer","previousInvariant","currentInvariant","protocolSwapFeePercentage","exponent","tokenAccruedFees","_invariant","terms","arg","logBase","reservesOther","concat","ioComp"],"mappings":"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IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,IAAMxS,YAAUC,KAAK,wCACjCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,KAAOxS,YAAUC,KAAK,wCAClCuS,GAAY,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"}