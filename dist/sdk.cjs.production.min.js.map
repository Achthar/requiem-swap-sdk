{"version":3,"file":"sdk.cjs.production.min.js","sources":["../src/constants.ts","../src/errors.ts","../src/utils.ts","../src/entities/currency.ts","../src/entities/token.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/currencyAmount.ts","../src/entities/fractions/tokenAmount.ts","../src/entities/fractions/price.ts","../src/entities/pair.ts","../src/entities/stableCalc.ts","../src/entities/swapStorage.ts","../src/entities/stablePool.ts","../src/entities/fractions/percent.ts","../src/entities/routeV3.ts","../src/entities/tradeV3.ts","../src/entities/stables.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/router.ts","../src/fetcher.ts","../src/stablesFetcher.ts"],"sourcesContent":["import JSBI from 'jsbi'\n// exports for external consumption\nexport type BigintIsh = JSBI | bigint | string\n\nexport enum ChainId {\n  BSC_MAINNET = 56,\n  BSC_TESTNET = 97,\n  AVAX_MAINNET = 43114,\n  AVAX_TESTNET = 43113,\n  ARBITRUM_MAINNET = 42161,\n  ARBITRUM_TETSNET_RINKEBY = 421611,\n  MATIC_MAINNET = 137,\n  MATIC_TESTNET = 80001,\n}\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nexport const FACTORY_ADDRESS: { [chainId: number]: string } = {\n  56: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n  97: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n  80001: '0xf10Bd0dA1f0e69c3334D7F8116C9082746EBC1B4',\n  43113: '0xC07098cdCf93b2dc5c20E749cDd1ba69cB9AcEBe',\n}\n\n// export const INIT_CODE_HASH = '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5'\n\n\nexport const INIT_CODE_HASH: { [chainId: number]: string } = {\n  56: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',\n  97: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',\n  80001: '0xc2b3644608b464a0df0eb711ce9c6ce7535d1bd4d0154b8389738a3e7fbb1a61',\n  43113: '0x197a29e2e90d809812f533e62529432f8e2741455e49d25365a66b4be2a453dd',\n}\n\n\nexport const STABLE_POOL_ADDRESS: { [chainId: number]: string } = {\n  43113: '0x9067e2C2bf8531283AB97C34EaA74599E0004842',\n}\n\nexport const STABLE_POOL_LP_ADDRESS: { [chainId: number]: string } = {\n  43113: '0xDf65aC8079A71f5174A35dE3D29e5458d03D5787'\n}\n\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\n\n// exports for internal consumption\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\nexport const TWO = JSBI.BigInt(2)\nexport const THREE = JSBI.BigInt(3)\nexport const FIVE = JSBI.BigInt(5)\nexport const TEN = JSBI.BigInt(10)\nexport const _100 = JSBI.BigInt(100)\nexport const FEES_NUMERATOR = JSBI.BigInt(9975)\nexport const FEES_DENOMINATOR = JSBI.BigInt(10000)\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: JSBI.BigInt('0xff'),\n  [SolidityType.uint256]: JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}\n","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport JSBI from 'jsbi'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\n\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\n  return bigintIsh instanceof JSBI\n    ? bigintIsh\n    : typeof bigintIsh === 'bigint'\n    ? JSBI.BigInt(bigintIsh.toString())\n    : JSBI.BigInt(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: JSBI): JSBI {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: JSBI = ZERO\n  let x: JSBI\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\n    while (JSBI.lessThan(x, z)) {\n      z = x\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n","import JSBI from 'jsbi'\nimport { ChainId } from '..'\n\nimport { SolidityType } from '../constants'\nimport { validateSolidityTypeInstance } from '../utils'\n\n/**\n * A currency is any fungible financial instrument on Ethereum, including Ether and all ERC20 tokens.\n *\n * The only instance of the base class `Currency` is Ether.\n */\nexport class Currency {\n  public readonly decimals: number\n  public readonly symbol?: string\n  public readonly name?: string\n\n  /**\n   * The only instance of the base class `Currency`.\n   */\n  public static readonly ETHER: Currency = new Currency(18, 'BNB', 'BNB')\n\n  public static readonly NETWORK_CCY: {[chainId in ChainId]:Currency} ={\n    [ChainId.BSC_MAINNET]: new Currency(18, 'BNB', 'BNB'),\n    [ChainId.BSC_TESTNET]: new Currency(18, 'BNB', 'BNB'),\n    [ChainId.ARBITRUM_MAINNET]: new Currency(18, 'ETH', 'ETH'),\n    [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Currency(18, 'ETH', 'ETH'),\n    [ChainId.AVAX_MAINNET]: new Currency(18, 'AVAX', 'AVAX'),\n    [ChainId.AVAX_TESTNET]: new Currency(18, 'AVAX', 'AVAX'),\n    [ChainId.MATIC_MAINNET]: new Currency(18, 'MATIC', 'MATIC'),\n    [ChainId.MATIC_TESTNET]: new Currency(18, 'MATIC', 'MATIC')\n  }\n  /**\n   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.ETHER`.\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  protected constructor(decimals: number, symbol?: string, name?: string) {\n    validateSolidityTypeInstance(JSBI.BigInt(decimals), SolidityType.uint8)\n\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n  }\n}\n\nconst NETWORK_CCY = Currency.NETWORK_CCY\nconst ETHER = Currency.ETHER\nexport { ETHER, NETWORK_CCY }\n","import invariant from 'tiny-invariant'\nimport { ChainId } from '../constants'\nimport { validateAndParseAddress } from '../utils'\nimport { Currency } from './currency'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token extends Currency {\n  public readonly chainId: ChainId\n  public readonly address: string\n  public readonly projectLink?: string\n\n  public constructor(\n    chainId: ChainId,\n    address: string,\n    decimals: number,\n    symbol?: string,\n    name?: string,\n    projectLink?: string\n  ) {\n    super(decimals, symbol, name)\n    this.chainId = chainId\n    this.address = validateAndParseAddress(address)\n    this.projectLink = projectLink\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Token): boolean {\n    // short circuit on reference equality\n    if (this === other) {\n      return true\n    }\n    return this.chainId === other.chainId && this.address === other.address\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n}\n\n/**\n * Compares two currencies for equality\n */\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB)\n  } else if (currencyA instanceof Token) {\n    return false\n  } else if (currencyB instanceof Token) {\n    return false\n  } else {\n    return currencyA === currencyB\n  }\n}\n\nexport const WETH = {\n  [ChainId.BSC_MAINNET]: new Token(\n    ChainId.BSC_MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.BSC_TESTNET]: new Token(\n    ChainId.BSC_TESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_MAINNET]: new Token(\n    ChainId.ARBITRUM_MAINNET,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped ETH',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Token(\n    ChainId.ARBITRUM_TETSNET_RINKEBY,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_MAINNET]: new Token(\n    ChainId.AVAX_MAINNET,\n    '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_TESTNET]: new Token(\n    ChainId.AVAX_TESTNET,\n    '0xd00ae08403B9bbb9124bB305C09058E32C39A48c',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_MAINNET]: new Token(\n    ChainId.MATIC_MAINNET,\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_TESTNET]: new Token(\n    ChainId.MATIC_TESTNET,\n    '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n\n}\n// this has not to be mixed up with the ERC20 token WETH on BSC or MATIC\n// these are the respective wrapped network tokens, e.g. WBNB for Binance\n// or WMATIC for Polygon\nexport const WRAPPED_NETWORK_TOKENS = {\n  [ChainId.BSC_MAINNET]: new Token(\n    ChainId.BSC_MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.BSC_TESTNET]: new Token(\n    ChainId.BSC_TESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_MAINNET]: new Token(\n    ChainId.ARBITRUM_MAINNET,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped ETH',\n    'https://www.binance.org'\n  ),\n  [ChainId.ARBITRUM_TETSNET_RINKEBY]: new Token(\n    ChainId.ARBITRUM_TETSNET_RINKEBY,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_MAINNET]: new Token(\n    ChainId.AVAX_MAINNET,\n    '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.AVAX_TESTNET]: new Token(\n    ChainId.AVAX_TESTNET,\n    '0xd00ae08403B9bbb9124bB305C09058E32C39A48c',\n    18,\n    'WAVAX',\n    'Wrapped AVAX',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_MAINNET]: new Token(\n    ChainId.MATIC_MAINNET,\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n  [ChainId.MATIC_TESTNET]: new Token(\n    ChainId.MATIC_TESTNET,\n    '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    18,\n    'WMATIC',\n    'Wrapped MATIC',\n    'https://www.binance.org'\n  ),\n\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Decimal from 'decimal.js-light'\nimport _Big, { RoundingMode } from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding } from '../../constants'\nimport { ONE } from '../../constants'\nimport { parseBigintIsh } from '../../utils'\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp\n}\n\nexport class Fraction {\n  public readonly numerator: JSBI\n  public readonly denominator: JSBI\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = ONE) {\n    this.numerator = parseBigintIsh(numerator)\n    this.denominator = parseBigintIsh(denominator)\n  }\n\n  // performs floor division\n  public get quotient(): JSBI {\n    return JSBI.divide(this.numerator, this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.add(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.subtract(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.lessThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.equal(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.greaterThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.numerator),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(this.denominator, otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n}\n","import { currencyEquals } from '../token'\nimport { Currency, ETHER, NETWORK_CCY } from '../currency'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Big from 'big.js'\nimport toFormat from 'toformat'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { BigintIsh, Rounding, TEN, SolidityType, ChainId } from '../../constants'\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../utils'\nimport { Fraction } from './fraction'\n\nconst Big = toFormat(_Big)\n\nexport class CurrencyAmount extends Fraction {\n  public readonly currency: Currency\n\n  /**\n   * Helper that calls the constructor with the ETHER currency\n   * @param amount ether amount in wei\n   */\n  public static ether(amount: BigintIsh): CurrencyAmount {\n    return new CurrencyAmount(ETHER, amount)\n  }\n\n  /**\n   * Helper that calls the constructor with the more flexible network currency\n   * dependent on the selected chainId\n   * @param amount ether amount in wei\n   */\n  public static networkCCYAmount(chainId: ChainId, amount: BigintIsh): CurrencyAmount {\n    return new CurrencyAmount(NETWORK_CCY[chainId], amount)\n  }\n\n  // amount _must_ be raw, i.e. in the native representation\n  protected constructor(currency: Currency, amount: BigintIsh) {\n    const parsedAmount = parseBigintIsh(amount)\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\n\n    super(parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(currency.decimals)))\n    this.currency = currency\n  }\n\n  public get raw(): JSBI {\n    return this.numerator\n  }\n\n  public add(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, JSBI.add(this.raw, other.raw))\n  }\n\n  public subtract(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, JSBI.subtract(this.raw, other.raw))\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\n  }\n\n  public toBigNumber(): BigNumber { return BigNumber.from(this.numerator.toString()) }\n}\n","import { CurrencyAmount } from './currencyAmount'\nimport { Token } from '../token'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\n\nimport { BigintIsh } from '../../constants'\n\n\n// minimal interface so the input output comparator may be shared across types\nexport interface InputOutput {\n  readonly inputAmount: CurrencyAmount\n  readonly outputAmount: CurrencyAmount\n}\n\nexport class TokenAmount extends CurrencyAmount {\n  public readonly token: Token\n\n  // amount _must_ be raw, i.e. in the native representation\n  public constructor(token: Token, amount: BigintIsh) {\n    super(token, amount)\n    this.token = token\n  }\n\n  public add(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.add(this.raw, other.raw))\n  }\n\n  public subtract(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.subtract(this.raw, other.raw))\n  }\n}\n","import { Token } from '../token'\nimport { TokenAmount } from './tokenAmount'\nimport { currencyEquals } from '../token'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\n\nimport { BigintIsh, Rounding, TEN } from '../../constants'\nimport { Currency } from '../currency'\nimport { Route } from '../route'\nimport { Fraction } from './fraction'\nimport { CurrencyAmount } from './currencyAmount'\n\nexport class Price extends Fraction {\n  public readonly baseCurrency: Currency // input i.e. denominator\n  public readonly quoteCurrency: Currency // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n  public static fromRoute(route: Route): Price {\n    const prices: Price[] = []\n    for (const [i, pair] of route.pairs.entries()) {\n      prices.push(\n        route.path[i].equals(pair.token0)\n          ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.raw, pair.reserve1.raw)\n          : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.raw, pair.reserve0.raw)\n      )\n    }\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n  }\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  public constructor(baseCurrency: Currency, quoteCurrency: Currency, denominator: BigintIsh, numerator: BigintIsh) {\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      JSBI.exponentiate(TEN, JSBI.BigInt(baseCurrency.decimals)),\n      JSBI.exponentiate(TEN, JSBI.BigInt(quoteCurrency.decimals))\n    )\n  }\n\n  public get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n\n  public get adjusted(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public invert(): Price {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  public multiply(other: Price): Price {\n    invariant(currencyEquals(this.quoteCurrency, other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  // performs floor division on overflow\n  public quote(currencyAmount: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(currencyAmount.currency, this.baseCurrency), 'TOKEN')\n    if (this.quoteCurrency instanceof Token) {\n      return new TokenAmount(this.quoteCurrency, super.multiply(currencyAmount.raw).quotient)\n    }\n    return CurrencyAmount.ether(super.multiply(currencyAmount.raw).quotient)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\n\nimport {\n  BigintIsh,\n  FACTORY_ADDRESS,\n  INIT_CODE_HASH,\n  MINIMUM_LIQUIDITY,\n  ZERO,\n  ONE,\n  FIVE,\n  FEES_NUMERATOR,\n  FEES_DENOMINATOR,\n  ChainId,\n} from '../constants'\nimport { sqrt, parseBigintIsh } from '../utils'\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors'\nimport { Token } from './token'\n\nlet PAIR_ADDRESS_CACHE: { [token0Address: string]: { [token1Address: string]: string } } = {}\n\nexport class Pair {\n  public readonly liquidityToken: Token\n  private readonly tokenAmounts: [TokenAmount, TokenAmount]\n\n  public static getAddress(tokenA: Token, tokenB: Token): string {\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID')\n    const chainId = tokenA.chainId\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n\n    if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address] === undefined) {\n      PAIR_ADDRESS_CACHE = {\n        ...PAIR_ADDRESS_CACHE,\n        [tokens[0].address]: {\n          ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\n          [tokens[1].address]: getCreate2Address(\n            FACTORY_ADDRESS[chainId],\n            keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]),\n            INIT_CODE_HASH[chainId]\n          ),\n        },\n      }\n    }\n\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address]\n  }\n\n  public constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount) {\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].token.chainId,\n      Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token),\n      18,\n      tokenAmounts[0].token.chainId === 56 ? 'Cake-LP' : 'Requiem-LP',\n      tokenAmounts[0].token.chainId === 56 ? 'Pancake LPs' : 'Requiem LPs'\n    )\n    this.tokenAmounts = tokenAmounts as [TokenAmount, TokenAmount]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price {\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price {\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].token\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].token\n  }\n\n  public get reserve0(): TokenAmount {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): TokenAmount {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): TokenAmount {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pair] {\n    invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.token)\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR)\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee)\n    const outputAmount = new TokenAmount(\n      inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\n    invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.raw, ZERO) ||\n      JSBI.equal(this.reserve1.raw, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.token)\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR)\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR)\n    const inputAmount = new TokenAmount(\n      outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getLiquidityMinted(\n    totalSupply: TokenAmount,\n    tokenAmountA: TokenAmount,\n    tokenAmountB: TokenAmount\n  ): TokenAmount {\n    invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return new TokenAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: TokenAmount,\n    liquidity: TokenAmount,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): TokenAmount {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: TokenAmount\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      invariant(!!kLast, 'K_LAST')\n      const kLastParsed = parseBigintIsh(kLast)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return new TokenAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n    )\n  }\n}\n","import { BigNumber } from 'ethers'\nimport invariant from 'tiny-invariant'\nimport { SwapStorage } from './swapStorage'\n\nconst MAX_ITERATION = 256\nexport const A_PRECISION = BigNumber.from(100)\nconst FEE_DENOMINATOR = BigNumber.from(1e10)\n\n\nexport function _xp(balances: BigNumber[], rates: BigNumber[]): BigNumber[] {\n    let result = []\n    for (let i = 0; i < balances.length; i++) {\n        result.push(rates[i].mul(balances[i]))\n    }\n    return result\n}\n\n\nexport function _getAPrecise(blockTimestamp: BigNumber,\n    swapStorage: SwapStorage\n): BigNumber {\n    if (blockTimestamp.gte(swapStorage.futureATime)) {\n        return swapStorage.futureA;\n    }\n\n    if (swapStorage.futureA.gt(swapStorage.initialA)) {\n        return swapStorage.initialA.add(\n            swapStorage.futureA.sub(swapStorage.initialA).mul(blockTimestamp.sub(swapStorage.initialATime)).div(\n                swapStorage.futureATime.sub(swapStorage.initialATime)))\n    }\n\n    return swapStorage.initialA.sub(swapStorage.initialA.sub(swapStorage.futureA).mul(blockTimestamp.sub(swapStorage.initialATime))).div(\n        swapStorage.futureATime.sub(swapStorage.initialATime))\n}\n\nexport function _sumOf(x: BigNumber[]): BigNumber {\n    let sum = BigNumber.from(0);\n    for (let i = 0; i < x.length; i++) {\n        sum = sum.add(x[i])\n    }\n    return sum\n}\n\n\nexport function _distance(x: BigNumber, y: BigNumber): BigNumber {\n    return x.gt(y) ? x.sub(y) : y.sub(x)\n}\n\n/**\n * Calculate D for *NORMALIZED* balances of each tokens\n * @param xp normalized balances of token\n */\nexport function _getD(xp: BigNumber[], amp: BigNumber): BigNumber {\n    const nCoins = xp.length;\n    let sum = _sumOf(xp)\n    if (sum.eq(0)) {\n        return BigNumber.from(0)\n    }\n\n    let Dprev = BigNumber.from(0)\n    let D = sum;\n    let Ann = amp.mul(nCoins)\n\n    for (let i = 0; i < MAX_ITERATION; i++) {\n        let D_P = D;\n        for (let j = 0; j < xp.length; j++) {\n            D_P = D_P.mul(D).div(xp[j].mul(nCoins))\n        }\n\n        Dprev = D;\n        D = ((Ann.mul(sum)).div(A_PRECISION).add(D_P.mul(nCoins)).mul(D)).div(\n            ((Ann.sub(A_PRECISION)).mul(D).div(A_PRECISION)).add(D_P.mul(nCoins + 1)))\n\n        if (_distance(D, Dprev).lte(1)) {\n            return D;\n        }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    invariant(\"invariantCalculationFailed\");\n    return D\n}\n\nexport function _getY(\n    inIndex: number,\n    outIndex: number,\n    inBalance: BigNumber,\n    // self, shoudl be replaced with swapStorage object\n    blockTimestamp: BigNumber,\n    swapStorage: SwapStorage,\n    normalizedBalances: BigNumber[]\n\n): BigNumber {\n    invariant(inIndex != outIndex, \"sameToken\");\n    const nCoins = normalizedBalances.length;\n    invariant(inIndex < nCoins && outIndex < nCoins, \"indexOutOfRange\");\n\n    let amp = _getAPrecise(blockTimestamp, swapStorage);\n    let Ann = amp.mul(nCoins)\n    let D = _getD(normalizedBalances, amp);\n    let sum = BigNumber.from(0) // sum of new balances except output token\n    let c = D;\n    for (let i = 0; i < nCoins; i++) {\n        if (i == outIndex) {\n            continue;\n        }\n\n        let x = i == inIndex ? inBalance : normalizedBalances[i];\n        sum = sum.add(x)\n        c = (c.mul(D)).div(x.mul(nCoins))\n    }\n\n    c = c.mul(D.mul(A_PRECISION)).div(Ann.mul(nCoins))\n    let b = sum.add(D.mul(A_PRECISION).div(Ann))\n\n    let lastY = BigNumber.from(0)\n    let y = D;\n    for (let index = 0; index < MAX_ITERATION; index++) {\n        lastY = y;\n        y = ((y.mul(y)).add(c)).div(y.mul(2).add(b).sub(D))\n        if (_distance(lastY, y).lte(1)) {\n            return y;\n        }\n    }\n\n    invariant(\"yCalculationFailed\")\n    return BigNumber.from(0)\n}\n\nexport function calculateSwap(inIndex: number, outIndex: number, inAmount: BigNumber, // standard fields\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    swapStorage: SwapStorage\n): BigNumber {\n    let normalizedBalances = _xp(balances, swapStorage.tokenMultipliers)\n    let newInBalance = normalizedBalances[inIndex].add(inAmount.mul(swapStorage.tokenMultipliers[inIndex]))\n    let outBalance = _getY(\n        inIndex,\n        outIndex,\n        newInBalance,\n        blockTimestamp, swapStorage,\n        normalizedBalances\n    )\n\n    let outAmount = ((normalizedBalances[outIndex].sub(outBalance)).sub(1)).div(swapStorage.tokenMultipliers[outIndex])\n    let _fee = swapStorage.fee.mul(outAmount).div(FEE_DENOMINATOR)\n    return outAmount.sub(_fee)\n}\n\n\n\n// function to calculate the amounts of stables from the amounts of LP\nexport function _calculateRemoveLiquidity(\n    amount: BigNumber,\n    swapStorage: SwapStorage,\n    totalSupply: BigNumber,\n    currentWithdrawFee: BigNumber,\n    balances: BigNumber[]\n): BigNumber[] {\n\n    invariant(amount <= totalSupply, \"Cannot exceed total supply\");\n\n    let feeAdjustedAmount = amount.mul(FEE_DENOMINATOR.sub(currentWithdrawFee)).div(\n        FEE_DENOMINATOR)\n\n    let amounts = []\n\n    for (let i = 0; i < swapStorage.tokenMultipliers.length; i++) {\n        amounts.push((balances[i].mul(feeAdjustedAmount)).div(totalSupply))\n    }\n    return amounts;\n}\n\n\nfunction _getYD(\n    A: BigNumber,\n    index: number,\n    xp: BigNumber[],\n    D: BigNumber\n): BigNumber {\n    let nCoins = xp.length;\n    invariant(index < nCoins, \"INDEX\");\n    let Ann = A.mul(nCoins)\n    let c = D;\n    let s = BigNumber.from(0)\n    let _x = BigNumber.from(0)\n    let yPrev = BigNumber.from(0)\n\n    for (let i = 0; i < nCoins; i++) {\n        if (i == index) {\n            continue;\n        }\n        _x = xp[i];\n        s = s.add(_x)\n        c = (c.mul(D)).div(_x.mul(nCoins))\n    }\n\n    c = (c.mul(D).mul(A_PRECISION)).div(Ann.mul(nCoins))\n    let b = s.add(D.mul(A_PRECISION).div(Ann))\n    let y = D;\n\n    for (let i = 0; i < MAX_ITERATION; i++) {\n        yPrev = y;\n        y = ((y.mul(y)).add(c)).div(((y.mul(2)).add(b)).sub(D))\n        if (_distance(yPrev, y).lt(1)) {\n            return y;\n        }\n    }\n    invariant(\"invariantCalculationFailed\")\n    return BigNumber.from(0)\n}\n\nfunction _feePerToken(swapStorage: SwapStorage): BigNumber {\n    let nCoins = swapStorage.tokenMultipliers.length;\n    return (swapStorage.fee.mul(nCoins)).div(4 * (nCoins - 1));\n}\n\n\nexport function _calculateRemoveLiquidityOneToken(\n    swapStorage: SwapStorage,\n    tokenAmount: BigNumber,\n    index: number,\n    blockTimestamp: BigNumber,\n    balances: BigNumber[],\n    totalSupply: BigNumber,\n    currentWithdrawFee: BigNumber\n): { [returnVal: string]: BigNumber }// {dy:BigNumber, fee:BigNumber} \n{\n    invariant(index < swapStorage.tokenMultipliers.length, \"indexOutOfRange\")\n\n    let amp = _getAPrecise(blockTimestamp, swapStorage)\n    let xp = _xp(balances, swapStorage.tokenMultipliers)\n    let D0 = _getD(xp, amp);\n    let D1 = D0.sub((tokenAmount.mul(D0)).div(totalSupply))\n    let newY = _getYD(amp, index, xp, D1);\n    let reducedXP = xp;\n    let _fee = _feePerToken(swapStorage);\n\n    for (let i = 0; i < swapStorage.tokenMultipliers.length; i++) {\n        let expectedDx = BigNumber.from(0)\n        if (i == index) {\n            expectedDx = ((xp[i].mul(D1)).div(D0)).sub(newY)\n        } else {\n            expectedDx = xp[i].sub(xp[i].mul(D1).div(D0))\n        }\n        reducedXP[i] = reducedXP[i].sub(_fee.mul(expectedDx).div(FEE_DENOMINATOR))\n    }\n\n    let dy = reducedXP[index].sub(_getYD(amp, index, reducedXP, D1))\n    dy = (dy.sub(1)).div(swapStorage.tokenMultipliers[index])\n    let fee = ((xp[index].sub(newY)).div(swapStorage.tokenMultipliers[index])).sub(dy)\n    dy = dy.mul(FEE_DENOMINATOR.sub(currentWithdrawFee)).div(FEE_DENOMINATOR)\n    return { \"dy\": dy, \"fee\": fee }\n}\n\n\n/**\n * Estimate amount of LP token minted or burned at deposit or withdrawal\n * without taking fees into account\n */\nexport function _calculateTokenAmount(\n    swapStorage: SwapStorage,\n    amounts: BigNumber[],\n    deposit: boolean,\n    balances: BigNumber[],\n    blockTimestamp: BigNumber,\n    totalSupply: BigNumber\n): BigNumber {\n    let nCoins = swapStorage.tokenMultipliers.length;\n    invariant(amounts.length == nCoins, \"invalidAmountsLength\");\n    let amp = _getAPrecise(blockTimestamp, swapStorage);\n    let D0 = _getD(_xp(balances, swapStorage.tokenMultipliers), amp);\n\n    let newBalances = balances;\n    for (let i = 0; i < nCoins; i++) {\n        if (deposit) {\n            newBalances[i] = newBalances[i].add(amounts[i])\n        } else {\n            newBalances[i] = newBalances[i].add(amounts[i])\n        }\n    }\n\n    let D1 = _getD(_xp(newBalances, swapStorage.tokenMultipliers), amp);\n\n\n    if (totalSupply.eq(0)) {\n        return D1; // first depositor take it all\n    }\n\n    let diff = deposit ? D1.sub(D0) : D0.sub(D1)\n    return (diff.mul(totalSupply)).div(D0)\n}","import { BigNumber } from \"ethers\"\n\nexport class SwapStorage {\n    public readonly tokenMultipliers: BigNumber[]\n    public readonly fee: BigNumber\n    public readonly adminFee: BigNumber\n    public readonly initialA: BigNumber\n    public readonly futureA: BigNumber\n    public readonly initialATime: BigNumber\n    public readonly futureATime: BigNumber\n    public readonly lpAddress: string\n\n    constructor(tokenMultipliers: BigNumber[],\n        fee: BigNumber,\n        adminFee: BigNumber,\n        initialA: BigNumber,\n        futureA: BigNumber,\n        initialATime: BigNumber,\n        futureATime: BigNumber,\n        lpAddress: string) {\n        this.lpAddress = lpAddress\n        this.tokenMultipliers = tokenMultipliers\n        this.fee = fee\n        this.adminFee = adminFee\n        this.initialA = initialA\n        this.futureA = futureA\n        this.initialATime = initialATime\n        this.futureATime = futureATime\n    }\n\n    public static mock(): SwapStorage {\n        const dummy = BigNumber.from(0)\n        return new SwapStorage([dummy], dummy, dummy, dummy, dummy, dummy, dummy, '')\n    }\n\n}","import invariant from 'tiny-invariant'\nimport { BigNumber } from 'ethers'\nimport {\n  _getAPrecise,\n  calculateSwap,\n  _calculateRemoveLiquidity,\n  _calculateRemoveLiquidityOneToken,\n  _calculateTokenAmount\n} from './stableCalc'\nimport { Contract } from '@ethersproject/contracts'\nimport { ethers } from 'ethers'\nimport { SwapStorage } from './swapStorage'\nimport {\n  BigintIsh,\n  ChainId,\n  STABLE_POOL_ADDRESS\n} from '../constants'\nimport StableSwap from '../abis/RequiemStableSwap.json'\nimport { Token } from './token'\nimport { TokenAmount } from '../entities'\nimport { Pair } from '..'\n/**\n  * A class that contains relevant stablePool information\n  * It is mainly designed to save the map between the indices\n  * and actual tokens in the pool and access the swap with addresses\n  * instead of the index\n  */\nexport class StablePool {\n  // the only LP token\n  public readonly liquidityToken: Token\n  // the index-token map \n  public readonly tokens: { [index: number]: Token }\n  public tokenBalances: BigNumber[]\n  public _A: BigNumber\n  public swapStorage: SwapStorage\n  // public readonly rates: BigNumber[]\n  public blockTimestamp: BigNumber\n\n  public readonly lpTotalSupply: BigNumber\n  public currentWithdrawFee: BigNumber\n\n  public static getAddress(chainId: number): string {\n    return STABLE_POOL_ADDRESS[chainId]\n  }\n\n  public constructor(\n    tokens: { [index: number]: Token },\n    tokenBalances: BigNumber[],\n    _A: BigNumber,\n    swapStorage: SwapStorage,\n    blockTimestamp: number,\n    lpTotalSupply: BigNumber,\n    currentWithdrawFee: BigNumber\n  ) {\n    this.currentWithdrawFee = currentWithdrawFee\n    this.lpTotalSupply = lpTotalSupply\n    this.swapStorage = swapStorage\n    this.blockTimestamp = BigNumber.from(blockTimestamp)\n    this.tokens = tokens\n    this.tokenBalances = tokenBalances\n    this._A = _A\n    this.liquidityToken = new Token(\n      tokens[0].chainId,\n      StablePool.getAddress(tokens[0].chainId),\n      18,\n      'RequiemStable-LP',\n      'Requiem StableSwap LPs'\n    )\n\n    for (let i = 0; i < Object.values(this.tokens).length; i++) {\n      invariant(tokens[i].address != ethers.constants.AddressZero, \"invalidTokenAddress\");\n      invariant(tokens[i].decimals <= 18, \"invalidDecimals\");\n      invariant(tokens[i].chainId === tokens[0].chainId, 'INVALID TOKENS')\n    }\n  }\n\n  public static mock() {\n    const dummy = BigNumber.from(0)\n    return new StablePool({ 0: new Token(-1, '', 1) }, [dummy], dummy, SwapStorage.mock(), 0, dummy, dummy)\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    let res = false\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      res || token.equals(this.tokens[i])\n    }\n\n    return res\n  }\n\n  public set setCurrentWithdrawFee(feeToSet: BigNumber) {\n    this.currentWithdrawFee = feeToSet\n  }\n\n  // maps the index to the token in the stablePool\n  public tokenFromIndex(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public indexFromToken(token: Token): number {\n    for (let index = 0; index < Object.keys(this.tokens).length; index++) {\n      if (token.equals(this.tokens[index])) {\n        return index\n      }\n    }\n    throw new Error('token not in pool');\n  }\n\n  public getBalances(): BigNumber[] {\n    return Object.keys(this.tokens).map((_, index) => (this.tokenBalances[index]))\n  }\n\n\n  public generatePairs(pairs: Pair[]) {\n    let relevantStables: Token[] = []\n    let generatedPairs: Pair[] = []\n    pairs.forEach(pair => {\n      if (Object.values(this.tokens).includes(pair.token0)) {\n        relevantStables.push(pair.token0)\n      }\n      if (Object.values(this.tokens).includes(pair.token1)) {\n        relevantStables.push(pair.token1)\n      }\n    })\n    if (relevantStables.length === 0) {\n      return []\n    }\n    for (let i = 0; i < relevantStables.length; i++) {\n      for (let j = i + 1; j < relevantStables.length; j++) {\n        //generatedPairs.push(new Pair(relevantStables[i], relevantStables[j]))\n      }\n    }\n    return generatedPairs\n  }\n\n  // calculates the output amount usingn the input for the swableSwap\n  // requires the view on a contract as manual calculation on the frontend would\n  // be inefficient\n  public async calculateSwapViaPing(\n    inIndex: number,\n    outIndex: number,\n    inAmount: BigintIsh,\n    provider: ethers.Signer | ethers.providers.Provider): Promise<BigintIsh> {\n\n    const outAmount: BigintIsh = await new Contract(this.liquidityToken.address, new ethers.utils.Interface(StableSwap), provider).calculateSwap(inIndex, outIndex, inAmount)\n\n    return outAmount\n  }\n\n\n  // calculates the swap output amount without\n  // pinging the blockchain for data\n  public calculateSwap(\n    inIndex: number,\n    outIndex: number,\n    inAmount: BigNumber): BigNumber {\n\n    const outAmount: BigNumber = calculateSwap(\n      inIndex,\n      outIndex,\n      inAmount,\n      this.getBalances(),\n      this.blockTimestamp,\n      this.swapStorage)\n\n    return outAmount\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount, outIndex: number): TokenAmount {\n    const swap = this.calculateSwap(this.indexFromToken(inputAmount.token), outIndex, inputAmount.toBigNumber())\n    return new TokenAmount(this.tokenFromIndex(outIndex), swap.toBigInt())\n  }\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.tokens[0].chainId\n  }\n\n  public token(index: number): Token {\n    return this.tokens[index]\n  }\n\n  public reserveOf(token: Token): BigNumber {\n    invariant(this.involvesToken(token), 'TOKEN')\n    for (let i = 0; i < Object.keys(this.tokens).length; i++) {\n      if (token.equals(this.tokens[i]))\n        return this.tokenBalances[i]\n    }\n    return BigNumber.from(0)\n  }\n\n  public calculateRemoveLiquidity(amountLp: BigNumber): BigNumber[] {\n    return _calculateRemoveLiquidity(\n      amountLp,\n      this.swapStorage,\n      this.lpTotalSupply,\n      this.currentWithdrawFee,\n      this.getBalances()\n    )\n  }\n\n  public calculateRemoveLiquidityOneToken(amount: BigNumber, index: number): { [returnVal: string]: BigNumber } {\n    return _calculateRemoveLiquidityOneToken(\n      this.swapStorage,\n      amount,\n      index,\n      this.blockTimestamp,\n      this.getBalances(),\n      this.lpTotalSupply,\n      this.currentWithdrawFee\n    )\n  }\n\n  public getLiquidityMinted(amounts: BigNumber[], deposit: boolean) {\n    return _calculateTokenAmount(\n      this.swapStorage,\n      amounts,\n      deposit,\n      this.getBalances(),\n      this.blockTimestamp,\n      this.lpTotalSupply\n    )\n  }\n\n  public setSwapStorage(swapStorage: SwapStorage) {\n    this.swapStorage = swapStorage\n  }\n\n  public setTokenBalances(tokenBalances: BigNumber[]) {\n    this.tokenBalances = tokenBalances\n  }\n\n  public setBlockTimestamp(blockTimestamp: BigNumber) {\n    this.blockTimestamp = blockTimestamp\n  }\n\n  /*\n    public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, StablePool] {\n      invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n      if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n        throw new InsufficientReservesError()\n      }\n      const inputReserve = this.reserveOf(inputAmount.token)\n      const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n      const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR)\n      const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\n      const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee)\n      const outputAmount = new TokenAmount(\n        inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n        JSBI.divide(numerator, denominator)\n      )\n      if (JSBI.equal(outputAmount.raw, ZERO)) {\n        throw new InsufficientInputAmountError()\n      }\n      return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n    }\n  \n    public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\n      invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n      if (\n        JSBI.equal(this.reserve0.raw, ZERO) ||\n        JSBI.equal(this.reserve1.raw, ZERO) ||\n        JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\n      ) {\n        throw new InsufficientReservesError()\n      }\n  \n      const outputReserve = this.reserveOf(outputAmount.token)\n      const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n      const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR)\n      const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR)\n      const inputAmount = new TokenAmount(\n        outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n        JSBI.add(JSBI.divide(numerator, denominator), ONE)\n      )\n      return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n    }\n  \n    public getLiquidityMinted(\n      totalSupply: TokenAmount,\n      tokenAmountA: TokenAmount,\n      tokenAmountB: TokenAmount\n    ): TokenAmount {\n      invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n      const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n        ? [tokenAmountA, tokenAmountB]\n        : [tokenAmountB, tokenAmountA]\n      invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n  \n      let liquidity: JSBI\n      if (JSBI.equal(totalSupply.raw, ZERO)) {\n        liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\n      } else {\n        const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\n        const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\n        liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n      }\n      if (!JSBI.greaterThan(liquidity, ZERO)) {\n        throw new InsufficientInputAmountError()\n      }\n      return new TokenAmount(this.liquidityToken, liquidity)\n    }\n  \n    public getLiquidityValue(\n      token: Token,\n      totalSupply: TokenAmount,\n      liquidity: TokenAmount,\n      feeOn: boolean = false,\n      kLast?: BigintIsh\n    ): TokenAmount {\n      invariant(this.involvesToken(token), 'TOKEN')\n      invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n      invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n      invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n  \n      let totalSupplyAdjusted: TokenAmount\n      if (!feeOn) {\n        totalSupplyAdjusted = totalSupply\n      } else {\n        invariant(!!kLast, 'K_LAST')\n        const kLastParsed = parseBigintIsh(kLast)\n        if (!JSBI.equal(kLastParsed, ZERO)) {\n          const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\n          const rootKLast = sqrt(kLastParsed)\n          if (JSBI.greaterThan(rootK, rootKLast)) {\n            const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\n            const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n            const feeLiquidity = JSBI.divide(numerator, denominator)\n            totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n          } else {\n            totalSupplyAdjusted = totalSupply\n          }\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      }\n  \n      return new TokenAmount(\n        token,\n        JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n      )\n    } */\n}\n","import { Rounding, _100 } from '../../constants'\nimport { Fraction } from './fraction'\n\nconst _100_PERCENT = new Fraction(_100)\n\nexport class Percent extends Fraction {\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { ChainId } from '../constants'\nimport invariant from 'tiny-invariant'\n\nimport { Currency, NETWORK_CCY } from './currency'\nimport { Token, WRAPPED_NETWORK_TOKENS } from './token'\nimport { Pair } from './pair'\nimport { Price } from './fractions/price'\nimport { StablePool } from './stablePool'\n\n// new version of the route \n// the first verion to include the stable pool for less friction\nexport class RouteV3 {\n  public readonly stablePool: StablePool\n  public readonly pairs: Pair[]\n  public readonly path: Token[]\n  public readonly input: Currency\n  public readonly output: Currency\n  public readonly midPrice: Price\n\n  public constructor(pairs: Pair[], input: Currency, output?: Currency, stablePool?: StablePool) {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(\n      pairs.every(pair => pair.chainId === pairs[0].chainId),\n      'CHAIN_IDS'\n    )\n    invariant(\n      (input instanceof Token && pairs[0].involvesToken(input)) ||\n      (input === NETWORK_CCY[pairs[0].chainId] && pairs[0].involvesToken(WRAPPED_NETWORK_TOKENS[pairs[0].chainId])),\n      'INPUT'\n    )\n    invariant(\n      typeof output === 'undefined' ||\n      (output instanceof Token && pairs[pairs.length - 1].involvesToken(output)) ||\n      (output === NETWORK_CCY[pairs[0].chainId] && pairs[pairs.length - 1].involvesToken(WRAPPED_NETWORK_TOKENS[pairs[0].chainId])),\n      'OUTPUT'\n    )\n\n    const path: Token[] = [input instanceof Token ? input : WRAPPED_NETWORK_TOKENS[pairs[0].chainId]]\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\n      path.push(output)\n    }\n    this.stablePool = stablePool ?? StablePool.mock()\n    this.pairs = pairs\n    this.path = path\n    this.midPrice = Price.fromRoute(this)\n    this.input = input\n    this.output = output ?? path[path.length - 1]\n  }\n\n\n  public connectPairs(){\n    \n  }\n\n  public get chainId(): ChainId {\n    return this.pairs[0].chainId\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\nimport { sortedInsert } from '../utils'\nimport { Currency, NETWORK_CCY } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount, InputOutput } from './fractions/tokenAmount'\nimport { Pair } from './pair'\nimport { RouteV3 } from './routeV3'\nimport { currencyEquals, Token, WRAPPED_NETWORK_TOKENS } from './token'\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nfunction computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n  return new Percent(slippage.numerator, slippage.denominator)\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparatorV3(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparatorV3(a: TradeV3, b: TradeV3) {\n  const ioComp = inputOutputComparatorV3(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptionsV3 {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === NETWORK_CCY[chainId]) return new TokenAmount(WRAPPED_NETWORK_TOKENS[chainId], currencyAmount.raw)\n  invariant(false, 'CURRENCY')\n}\n\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n  if (currency instanceof Token) return currency\n  if (currency === NETWORK_CCY[chainId]) return WRAPPED_NETWORK_TOKENS[chainId]\n  invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class TradeV3 {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: RouteV3\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The mid price after the trade executes assuming no slippage.\n   */\n  public readonly nextMidPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: RouteV3, amountIn: CurrencyAmount): TradeV3 {\n    return new TradeV3(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: RouteV3, amountOut: CurrencyAmount): TradeV3 {\n    return new TradeV3(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(route: RouteV3, amount: CurrencyAmount, tradeType: TradeType) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    const nextPairs: Pair[] = new Array(route.pairs.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n        nextPairs[i] = nextPair\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i])\n        amounts[i - 1] = inputAmount\n        nextPairs[i - 1] = nextPair\n      }\n    }\n\n    this.route = route\n    this.tradeType = tradeType\n    this.inputAmount =\n      tradeType === TradeType.EXACT_INPUT\n        ? amount\n        : route.input === NETWORK_CCY[route.chainId]\n          ? CurrencyAmount.networkCCYAmount(route.chainId,amounts[0].raw)\n          : amounts[0]\n    this.outputAmount =\n      tradeType === TradeType.EXACT_OUTPUT\n        ? amount\n        : route.output === NETWORK_CCY[route.chainId]\n          ? CurrencyAmount.networkCCYAmount(route.chainId,amounts[amounts.length - 1].raw)\n          : amounts[amounts.length - 1]\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    this.nextMidPrice = Price.fromRoute(new RouteV3(nextPairs, route.input))\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return this.outputAmount instanceof TokenAmount\n        ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n        : CurrencyAmount.networkCCYAmount(this.route.chainId, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return this.inputAmount instanceof TokenAmount\n        ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n        : CurrencyAmount.networkCCYAmount(this.route.chainId,slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn(\n    pairs: Pair[],\n    currencyAmountIn: CurrencyAmount,\n    currencyOut: Currency,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptionsV3 = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountIn: CurrencyAmount = currencyAmountIn,\n    bestTrades: TradeV3[] = []\n  ): TradeV3[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountIn instanceof TokenAmount\n        ? currencyAmountIn.token.chainId\n        : currencyOut instanceof Token\n          ? currencyOut.chainId\n          : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = wrappedAmount(currencyAmountIn, chainId)\n    const tokenOut = wrappedCurrency(currencyOut, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: TokenAmount\n      try {\n        ;[amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if ((error as any).isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new TradeV3(\n            new RouteV3([...currentPairs, pair], originalAmountIn.currency, currencyOut),\n            originalAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparatorV3\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        TradeV3.bestTradeExactIn(\n          pairsExcludingThisPair,\n          amountOut,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentPairs, pair],\n          originalAmountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut(\n    pairs: Pair[],\n    currencyIn: Currency,\n    currencyAmountOut: CurrencyAmount,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptionsV3 = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountOut: CurrencyAmount = currencyAmountOut,\n    bestTrades: TradeV3[] = []\n  ): TradeV3[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountOut instanceof TokenAmount\n        ? currencyAmountOut.token.chainId\n        : currencyIn instanceof Token\n          ? currencyIn.chainId\n          : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountOut = wrappedAmount(currencyAmountOut, chainId)\n    const tokenIn = wrappedCurrency(currencyIn, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: TokenAmount\n      try {\n        ;[amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if ((error as any).isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new TradeV3(\n            new RouteV3([pair, ...currentPairs], currencyIn, originalAmountOut.currency),\n            originalAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparatorV3\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        TradeV3.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          amountIn,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [pair, ...currentPairs],\n          originalAmountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","import { Token } from './token'\nimport { ChainId } from '../constants'\n\nexport const STABLECOINS: { [chainId: number]: Token[] } = {\n  43113: [\n    new Token(ChainId.AVAX_TESTNET, '0xCa9eC7085Ed564154a9233e1e7D8fEF460438EEA', 6, 'USDC', 'USD Coin'),\n    new Token(ChainId.AVAX_TESTNET, '0x0bE04001Ad4725c697b6c6bD8Bc23d9848992CA0', 6, 'USDT', 'Tether USD'),\n    new Token(ChainId.AVAX_TESTNET, '0x66960440491bCc68BD30B2b0B08fF9e7aB3F9078', 18, 'DAI', 'Dai Stablecoin'),\n    new Token(ChainId.AVAX_TESTNET, '0xCCf7ed44c5A0f3Cb5c9a9B9f765F8D836fb93BA1', 18, 'TUSD', 'True USD'),\n  ]\n}\n\n\nexport const STABLES_INDEX_MAP: { [chainId: number]: { [index: number]: Token } } = {\n  43113: {\n    0: STABLECOINS[43113][0],\n    1: STABLECOINS[43113][1],\n    2: STABLECOINS[43113][2],\n    3: STABLECOINS[43113][3]\n  }\n}","import { ChainId } from '../constants'\nimport invariant from 'tiny-invariant'\n\nimport { Currency, NETWORK_CCY } from './currency'\nimport { Token, WRAPPED_NETWORK_TOKENS } from './token'\nimport { Pair } from './pair'\nimport { Price } from './fractions/price'\n\nexport class Route {\n  public readonly pairs: Pair[]\n  public readonly path: Token[]\n  public readonly input: Currency\n  public readonly output: Currency\n  public readonly midPrice: Price\n\n  public constructor(pairs: Pair[], input: Currency, output?: Currency) {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(\n      pairs.every(pair => pair.chainId === pairs[0].chainId),\n      'CHAIN_IDS'\n    )\n    invariant(\n      (input instanceof Token && pairs[0].involvesToken(input)) ||\n      (input === NETWORK_CCY[pairs[0].chainId] && pairs[0].involvesToken(WRAPPED_NETWORK_TOKENS[pairs[0].chainId])),\n      'INPUT'\n    )\n    invariant(\n      typeof output === 'undefined' ||\n      (output instanceof Token && pairs[pairs.length - 1].involvesToken(output)) ||\n      (output === NETWORK_CCY[pairs[0].chainId] && pairs[pairs.length - 1].involvesToken(WRAPPED_NETWORK_TOKENS[pairs[0].chainId])),\n      'OUTPUT'\n    )\n\n    const path: Token[] = [input instanceof Token ? input : WRAPPED_NETWORK_TOKENS[pairs[0].chainId]]\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\n      path.push(output)\n    }\n\n    this.pairs = pairs\n    this.path = path\n    this.midPrice = Price.fromRoute(this)\n    this.input = input\n    this.output = output ?? path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.pairs[0].chainId\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\nimport { sortedInsert } from '../utils'\nimport { Currency, NETWORK_CCY } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount, InputOutput } from './fractions/tokenAmount'\nimport { Pair } from './pair'\nimport { Route } from './route'\nimport { currencyEquals, Token, WRAPPED_NETWORK_TOKENS } from './token'\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nfunction computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n  return new Percent(slippage.numerator, slippage.denominator)\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Trade, b: Trade) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === NETWORK_CCY[chainId]) return new TokenAmount(WRAPPED_NETWORK_TOKENS[chainId], currencyAmount.raw)\n  invariant(false, 'CURRENCY')\n}\n\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n  if (currency instanceof Token) return currency\n  if (currency === NETWORK_CCY[chainId]) return WRAPPED_NETWORK_TOKENS[chainId]\n  invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: Route\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The mid price after the trade executes assuming no slippage.\n   */\n  public readonly nextMidPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: Route, amountIn: CurrencyAmount): Trade {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: Route, amountOut: CurrencyAmount): Trade {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(route: Route, amount: CurrencyAmount, tradeType: TradeType) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    const nextPairs: Pair[] = new Array(route.pairs.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n        nextPairs[i] = nextPair\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i])\n        amounts[i - 1] = inputAmount\n        nextPairs[i - 1] = nextPair\n      }\n    }\n\n    this.route = route\n    this.tradeType = tradeType\n    this.inputAmount =\n      tradeType === TradeType.EXACT_INPUT\n        ? amount\n        : route.input === NETWORK_CCY[route.chainId]\n          ? CurrencyAmount.networkCCYAmount(route.chainId,amounts[0].raw)\n          : amounts[0]\n    this.outputAmount =\n      tradeType === TradeType.EXACT_OUTPUT\n        ? amount\n        : route.output === NETWORK_CCY[route.chainId]\n          ? CurrencyAmount.networkCCYAmount(route.chainId,amounts[amounts.length - 1].raw)\n          : amounts[amounts.length - 1]\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input))\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return this.outputAmount instanceof TokenAmount\n        ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n        : CurrencyAmount.networkCCYAmount(this.route.chainId, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return this.inputAmount instanceof TokenAmount\n        ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n        : CurrencyAmount.networkCCYAmount(this.route.chainId,slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn(\n    pairs: Pair[],\n    currencyAmountIn: CurrencyAmount,\n    currencyOut: Currency,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountIn: CurrencyAmount = currencyAmountIn,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountIn instanceof TokenAmount\n        ? currencyAmountIn.token.chainId\n        : currencyOut instanceof Token\n          ? currencyOut.chainId\n          : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = wrappedAmount(currencyAmountIn, chainId)\n    const tokenOut = wrappedCurrency(currencyOut, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: TokenAmount\n      try {\n        ;[amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if ((error as any).isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut),\n            originalAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          amountOut,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentPairs, pair],\n          originalAmountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut(\n    pairs: Pair[],\n    currencyIn: Currency,\n    currencyAmountOut: CurrencyAmount,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountOut: CurrencyAmount = currencyAmountOut,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountOut instanceof TokenAmount\n        ? currencyAmountOut.token.chainId\n        : currencyIn instanceof Token\n          ? currencyIn.chainId\n          : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountOut = wrappedAmount(currencyAmountOut, chainId)\n    const tokenIn = wrappedCurrency(currencyIn, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: TokenAmount\n      try {\n        ;[amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if ((error as any).isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency),\n            originalAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          amountIn,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [pair, ...currentPairs],\n          originalAmountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","import { TradeType } from './constants'\nimport invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from './utils'\nimport { CurrencyAmount, NETWORK_CCY, Percent, Trade } from './entities'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\nexport interface TradeOptionsDeadline extends Omit<TradeOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Pancake Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Pancake Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Pancake Router, and has static methods for helping execute trades.\n */\nexport abstract class Router {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(trade: Trade, options: TradeOptions | TradeOptionsDeadline): SwapParameters {\n    const etherIn = trade.inputAmount.currency === NETWORK_CCY[trade.route.chainId]\n    const etherOut = trade.outputAmount.currency === NETWORK_CCY[trade.route.chainId]\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map((token) => token.address)\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = useFeeOnTransfer\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n            : 'swapExactTokensForTokens'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n      case TradeType.EXACT_OUTPUT:\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = 'swapTokensForExactTokens'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n","import { Contract } from '@ethersproject/contracts'\nimport { getNetwork } from '@ethersproject/networks'\nimport { getDefaultProvider } from '@ethersproject/providers'\nimport { TokenAmount } from './entities/fractions/tokenAmount'\nimport { Pair } from './entities/pair'\nimport IPancakePair from '@pancakeswap-libs/pancake-swap-core/build/IPancakePair.json'\nimport invariant from 'tiny-invariant'\nimport ERC20 from './abis/ERC20.json'\nimport { ChainId } from './constants'\nimport { Token } from './entities/token'\n\nlet TOKEN_DECIMALS_CACHE: { [chainId: number]: { [address: string]: number } } = {\n  [ChainId.BSC_MAINNET]: {\n    '0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A': 9 // DGD\n  }\n}\n\n/**\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\n */\nexport abstract class Fetcher {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * Fetch information for a given token on the given chain, using the given ethers provider.\n   * @param chainId chain of the token\n   * @param address address of the token on the chain\n   * @param provider provider used to fetch the token\n   * @param symbol optional symbol of the token\n   * @param name optional name of the token\n   */\n  public static async fetchTokenData(\n    chainId: ChainId,\n    address: string,\n    provider = getDefaultProvider(getNetwork(chainId)),\n    symbol?: string,\n    name?: string\n  ): Promise<Token> {\n    const parsedDecimals =\n      typeof TOKEN_DECIMALS_CACHE?.[chainId]?.[address] === 'number'\n        ? TOKEN_DECIMALS_CACHE[chainId][address]\n        : await new Contract(address, ERC20, provider).decimals().then((decimals: number): number => {\n            TOKEN_DECIMALS_CACHE = {\n              ...TOKEN_DECIMALS_CACHE,\n              [chainId]: {\n                ...TOKEN_DECIMALS_CACHE?.[chainId],\n                [address]: decimals\n              }\n            }\n            return decimals\n          })\n    return new Token(chainId, address, parsedDecimals, symbol, name)\n  }\n\n  /**\n   * Fetches information about a pair and constructs a pair from the given two tokens.\n   * @param tokenA first token\n   * @param tokenB second token\n   * @param provider the provider to use to fetch the data\n   */\n  public static async fetchPairData(\n    tokenA: Token,\n    tokenB: Token,\n    provider = getDefaultProvider(getNetwork(tokenA.chainId))\n  ): Promise<Pair> {\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID')\n    const address = Pair.getAddress(tokenA, tokenB)\n    const [reserves0, reserves1] = await new Contract(address, IPancakePair.abi, provider).getReserves()\n    const balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0]\n    return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]))\n  }\n\n}\n","import { ethers } from 'ethers'\n// import { BigNumber } from 'ethers'\n// import { getNetwork } from '@ethersproject/networks'\n// import { getDefaultProvider } from '@ethersproject/providers'\n// import { TokenAmount } from './entities/fractions/tokenAmount'\n// import { Pair } from './entities/pair'\nimport { StablePool } from './entities/stablePool'\n// import IPancakePair from '@pancakeswap-libs/pancake-swap-core/build/IPancakePair.json'\n// import invariant from 'tiny-invariant'\n// import ERC20 from './abis/ERC20.json'\nimport StableSwap from './abis/RequiemStableSwap.json'\n// import { STABLES_INDEX_MAP } from './entities/stables'\n// import { Token } from './entities/token'\n\n\n/**\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\n */\nexport abstract class StablesFetcher {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() { }\n\n  /**\n   * Fetches information about the stablePool and constructs a StablePool Object from the contract deployed.\n   * @param tokenA first token\n   * @param tokenB second token\n   * @param provider the provider to use to fetch the data\n   */\n  public static async fetchStablePoolData(\n    chainId: number,\n    provider: ethers.providers.Provider\n  ): Promise<StablePool> {\n    const address = StablePool.getAddress(chainId)\n    console.log(\"address\", address)\n    const tokenAddresses = await new ethers.Contract(address, StableSwap, provider).getTokens()\n    console.log(\"TokenAddresses\", tokenAddresses)\n    // const tokenReserves = await new ethers.Contract(address, StableSwap, provider).getTokenBalances()\n    let indexes = []\n    for (let i = 0; i < tokenAddresses.length; i++) {\n      indexes.push(i)\n    }\n    // const tokenMap = Object.assign({},\n    //   ...(tokenAddresses as string[]).map((_, index) => ({\n    //     [index]: new TokenAmount(\n    //       STABLES_INDEX_MAP[chainId][index],\n    //       tokenReserves[index])\n    //   })))\n    return StablePool.mock()\n  }\n\n}\n"],"names":["ChainId","TradeType","Rounding","SolidityType","FACTORY_ADDRESS","INIT_CODE_HASH","STABLE_POOL_ADDRESS","MINIMUM_LIQUIDITY","JSBI","BigInt","ZERO","ONE","TWO","THREE","FIVE","TEN","_100","FEES_NUMERATOR","FEES_DENOMINATOR","SOLIDITY_TYPE_MAXIMA","uint8","uint256","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","name","_this","constructor","setPrototypeOf","prototype","Error","InsufficientInputAmountError","_this2","validateSolidityTypeInstance","value","solidityType","greaterThanOrEqual","invariant","lessThanOrEqual","validateAndParseAddress","address","getAddress","error","parseBigintIsh","bigintIsh","toString","sqrt","y","x","z","greaterThan","add","divide","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop","Currency","decimals","symbol","NETWORK_CCY","BSC_MAINNET","BSC_TESTNET","ARBITRUM_MAINNET","ARBITRUM_TETSNET_RINKEBY","AVAX_MAINNET","AVAX_TESTNET","MATIC_MAINNET","MATIC_TESTNET","ETHER","Token","chainId","projectLink","equals","other","this","sortsBefore","toLowerCase","currencyEquals","currencyA","currencyB","WETH","WRAPPED_NETWORK_TOKENS","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","numerator","denominator","invert","otherParsed","equal","multiply","subtract","equalTo","toSignificant","significantDigits","format","rounding","groupSeparator","Number","isInteger","set","precision","quotient","div","toSignificantDigits","decimalPlaces","toFixed","DP","RM","remainder","CurrencyAmount","currency","amount","parsedAmount","exponentiate","ether","networkCCYAmount","raw","toExact","toBigNumber","BigNumber","from","TokenAmount","token","Price","baseCurrency","quoteCurrency","scalar","fromRoute","route","prices","pairs","entries","pair","path","token0","reserve0","reserve1","slice","reduce","accumulator","currentValue","fraction","quote","currencyAmount","_Fraction","adjusted","PAIR_ADDRESS_CACHE","Pair","tokenAmountA","tokenAmountB","tokenAmounts","liquidityToken","tokenA","tokenB","tokens","undefined","_PAIR_ADDRESS_CACHE2","getCreate2Address","keccak256","pack","involvesToken","token1","priceOf","token0Price","token1Price","reserveOf","getOutputAmount","inputAmount","inputReserve","outputReserve","inputAmountWithFee","outputAmount","getInputAmount","getLiquidityMinted","totalSupply","liquidity","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","A_PRECISION","FEE_DENOMINATOR","_xp","balances","rates","result","i","mul","_getAPrecise","blockTimestamp","swapStorage","gte","futureATime","futureA","gt","initialA","sub","initialATime","_distance","_getD","xp","amp","nCoins","sum","_sumOf","eq","Dprev","D","Ann","D_P","j","lte","_getYD","A","index","c","s","_x","b","lt","SwapStorage","tokenMultipliers","fee","adminFee","lpAddress","mock","dummy","StablePool","tokenBalances","_A","lpTotalSupply","currentWithdrawFee","values","ethers","constants","AddressZero","keys","tokenFromIndex","indexFromToken","getBalances","map","_","generatePairs","relevantStables","forEach","includes","calculateSwapViaPing","inIndex","outIndex","inAmount","provider","Contract","utils","Interface","StableSwap","calculateSwap","normalizedBalances","outBalance","inBalance","_getY","outAmount","_fee","swap","toBigInt","calculateRemoveLiquidity","amountLp","feeAdjustedAmount","amounts","_calculateRemoveLiquidity","calculateRemoveLiquidityOneToken","tokenAmount","D0","D1","newY","reducedXP","_feePerToken","expectedDx","dy","_calculateRemoveLiquidityOneToken","deposit","newBalances","_calculateTokenAmount","setSwapStorage","setTokenBalances","setBlockTimestamp","feeToSet","_100_PERCENT","Percent","RouteV3","input","output","stablePool","every","currentInput","midPrice","connectPairs","inputOutputComparatorV3","a","tradeComparatorV3","ioComp","priceImpact","wrappedAmount","wrappedCurrency","TradeV3","tradeType","exactQuote","slippage","Array","nextPairs","EXACT_INPUT","nextPair","EXACT_OUTPUT","executionPrice","nextMidPrice","exactIn","amountIn","exactOut","amountOut","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","currentPairs","originalAmountIn","bestTrades","maxNumResults","maxHops","tokenOut","isInsufficientInputAmountError","pairsExcludingThisPair","concat","bestTradeExactOut","currencyIn","currencyAmountOut","originalAmountOut","tokenIn","isInsufficientReservesError","STABLECOINS","STABLES_INDEX_MAP","Route","inputOutputComparator","tradeComparator","Trade","toHex","Router","swapCallParameters","trade","options","etherIn","etherOut","ttl","methodName","args","to","recipient","allowedSlippage","deadline","Math","floor","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer","TOKEN_DECIMALS_CACHE","Fetcher","fetchTokenData","parsedDecimals","getDefaultProvider","getNetwork","_TOKEN_DECIMALS_CACHE2","_TOKEN_DECIMALS_CACHE3","ERC20","then","_TOKEN_DECIMALS_CACHE4","fetchPairData","IPancakePair","abi","getReserves","reserves0","reserves1","StablesFetcher","fetchStablePoolData","console","log","getTokens","tokenAddresses","indexes"],"mappings":"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"}