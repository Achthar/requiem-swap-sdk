import { BigNumber } from '@ethersproject/bignumber';
/**
     * @dev General Description:
     *     Determine a value of precision.
     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.
     *     Return the result along with the precision used.
     *
     * Detailed Description:
     *     Instead of calculating "base ^ exp", we calculate "e ^ (log(base) * exp)".
     *     The value of "log(base)" is represented with an integer slightly smaller than "log(base) * 2 ^ precision".
     *     The larger "precision" is, the more accurately this value represents the real value.
     *     However, the larger "precision" is, the more bits are required in order to store this value.
     *     And the exponentiation function, which takes "x" and calculates "e ^ x", is limited to a maximum exponent (maximum value of "x").
     *     This maximum exponent depends on the "precision" used, and it is given by "maxExpArray[precision] >> (MAX_PRECISION - precision)".
     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.
     *     This allows us to compute "base ^ exp" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.
     *     This functions assumes that "_expN < 2 ^ 256 / log(MAX_NUM - 1)", otherwise the multiplication should be replaced with a "safeMul".
     *     Since we rely on unsigned-integer arithmetic and "base < 1" ==> "log(base) < 0", this function does not support "_baseN < _baseD".
     */
export declare function power(_baseN: BigNumber, _baseD: BigNumber, _expN: BigNumber, _expD: BigNumber): [BigNumber, number];
/**
 * @dev computes log(x / FIXED_1) * FIXED_1.
 * This functions assumes that "x >= FIXED_1", because the output would be negative otherwise.
 */
export declare function generalLog(x: BigNumber): BigNumber;
/**
    * @dev computes log(x / FIXED_1) * FIXED_1
    * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1
    * Auto-generated via "PrintFunctionOptimalLog.py"
    * Detailed description:
    * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2
    * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent
    * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1
    * - The natural logarithm of the input is calculated by summing up the intermediate results above
    * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)
    */
export declare function optimalLog(x: BigNumber): BigNumber;
export declare function optimalExp(x: BigNumber): BigNumber;
/**
   * @dev this function can be auto-generated by the script "PrintFunctionGeneralExp.py".
   * it approximates "e ^ x" via maclaurin summation: "(x^0)/0! + (x^1)/1! + ... + (x^n)/n!".
   * it returns "e ^ (x / 2 ^ precision) * 2 ^ precision", that is, the result is upshifted for accuracy.
   * the global "maxExpArray" maps each "precision" to "((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1".
   * the maximum permitted value for "x" is therefore given by "maxExpArray[precision] >> (MAX_PRECISION - precision)".
   */
export declare function generalExp(_x: BigNumber, _precision: BigNumber): BigNumber;
/**
    * @dev the global "maxExpArray" is sorted in descending order, and therefore the following statements are equivalent:
    * - This function finds the position of [the smallest value in "maxExpArray" larger than or equal to "x"]
    * - This function finds the highest position of [a value in "maxExpArray" larger than or equal to "x"]
    */
export declare function findPositionInMaxExpArray(_x: BigNumber): number;
/**
 * @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset,
 *
 * Formula:
 * return = reserveOut * (1 - (reserveIn * 10000 / (reserveIn * 10000 + amountIn * (10000 - swapFee))) ^ (tokenWeightIn / tokenWeightOut))
 *
 * @param amountIn                  source reserve amount
 * @param reserveIn    source reserve balance
 * @param reserveOut    target reserve balance
 * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)
 * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)
 * @param swapFee                  swap fee of the conversion
 *
 * @return amountOut
 */
export declare function getAmountOut(amountIn: BigNumber, reserveIn: BigNumber, reserveOut: BigNumber, tokenWeightIn: BigNumber, tokenWeightOut: BigNumber, swapFee: BigNumber): BigNumber;
/**
 * @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset
 *
 * Formula:
 * return = reserveIn * ( (reserveOut / (reserveOut - amountOut)) ^ (tokenWeightOut / tokenWeightIn) - 1) * (10000/ (10000 - swapFee)
 *
 * @param amountOut     target reserve amount
 * @param reserveIn    source reserve balance
 * @param reserveOut    target reserve balance
 * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)
 * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)
 * @param swapFee                  swap fee of the conversion
 *
 * @return amountIn
 */
export declare function getAmountIn(amountOut: BigNumber, reserveIn: BigNumber, reserveOut: BigNumber, tokenWeightIn: BigNumber, tokenWeightOut: BigNumber, swapFee: BigNumber): BigNumber;
